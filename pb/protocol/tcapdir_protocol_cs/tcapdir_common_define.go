// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2021-07-08 12:01:04
package tcapdir_protocol_cs

import (
	"encoding/binary"
	"errors"

	"github.com/tencentyun/tsf4g/tdrcom"
)

const TCAPDIR_URL_LEN int64 = 64
const TCAPDIR_URL_LEN_MORE int64 = 1024

// 最多拉取的表数量
const TCAPDIR_MAX_TABLE int64 = 256

// 最多支持的dir server的个数
const TCAPDIR_MAX_DIR_SERVER_COUNT int64 = 10

// 心跳默认时间
const TCAPDIR_HEART_BEAT_TIME int64 = 30

// 压缩阈值
const TCAPDIR_COMPRESS_THRESHOLD int64 = 0
const (
	TableInfoBaseVersion    uint32 = 1
	TableInfoCurrentVersion uint32 = 1
)

// TableInfo
type TableInfo struct {
	Name string `tdr_field:"Name"`

	ZoneID int32 `tdr_field:"ZoneID"`
}

func NewTableInfo() *TableInfo {
	obj := new(TableInfo)
	obj.Init()
	return obj
}

func (this *TableInfo) GetBaseVersion() uint32 {
	return TableInfoBaseVersion
}

func (this *TableInfo) GetCurrentVersion() uint32 {
	return TableInfoCurrentVersion
}

func (this *TableInfo) Init() {

}

func (this *TableInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TableInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TableInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TableInfoCurrentVersion {
		cutVer = TableInfoCurrentVersion
	}
	// check cut version
	if cutVer < TableInfoBaseVersion {
		return errors.New("TableInfo cut version must large than TableInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("TableInfo.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("TableInfo.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("TableInfo.ZoneID pack error\n" + err.Error())
	}

	return nil
}

func (this *TableInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TableInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TableInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TableInfoCurrentVersion {
		cutVer = TableInfoCurrentVersion
	}
	// check version
	if cutVer < TableInfoBaseVersion {
		errors.New("TableInfo cut version must large than TableInfoBaseVersion\n")
	}

	var NameSize uint32
	err = binary.Read(r, binary.BigEndian, &NameSize)
	if err != nil {
		return errors.New("TableInfo.Name string size unpack error\n" + err.Error())
	}

	NameBytes := make([]byte, NameSize)
	err = binary.Read(r, binary.BigEndian, NameBytes)
	if err != nil {
		return errors.New("TableInfo.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(NameBytes[:len(NameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("TableInfo.ZoneID unpack error\n" + err.Error())
	}

	return err
}

const (
	TableAccessBaseVersion      uint32 = 1
	TableAccessCurrentVersion   uint32 = 120
	TableAccessURLV6Version     uint32 = 120
	TableAccessProxyIDVersion   uint32 = 53
	TableAccessPublicURLVersion uint32 = 107
	TableAccessVpcURLVersion    uint32 = 107
	TableAccessVpcURLV6Version  uint32 = 120
)

// TableAccess
type TableAccess struct {
	URL string `tdr_field:"URL"`

	URLV6 string `tdr_field:"URLV6"`

	ProxyID string `tdr_field:"ProxyID"`

	PublicURL string `tdr_field:"PublicURL"`

	VpcURL string `tdr_field:"VpcURL"`

	VpcURLV6 string `tdr_field:"VpcURLV6"`
}

func NewTableAccess() *TableAccess {
	obj := new(TableAccess)
	obj.Init()
	return obj
}

func (this *TableAccess) GetBaseVersion() uint32 {
	return TableAccessBaseVersion
}

func (this *TableAccess) GetCurrentVersion() uint32 {
	return TableAccessCurrentVersion
}

func (this *TableAccess) Init() {

}

func (this *TableAccess) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TableAccess Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TableAccess) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TableAccessCurrentVersion {
		cutVer = TableAccessCurrentVersion
	}
	// check cut version
	if cutVer < TableAccessBaseVersion {
		return errors.New("TableAccess cut version must large than TableAccessBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.URL))+1)
	if err != nil {
		return errors.New("TableAccess.URL string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.URL), 0))
	if err != nil {
		return errors.New("TableAccess.URL string content pack error\n" + err.Error())
	}

	if cutVer >= TableAccessURLV6Version {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.URLV6))+1)
		if err != nil {
			return errors.New("TableAccess.URLV6 string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.URLV6), 0))
		if err != nil {
			return errors.New("TableAccess.URLV6 string content pack error\n" + err.Error())
		}

	}
	if cutVer >= TableAccessProxyIDVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.ProxyID))+1)
		if err != nil {
			return errors.New("TableAccess.ProxyID string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.ProxyID), 0))
		if err != nil {
			return errors.New("TableAccess.ProxyID string content pack error\n" + err.Error())
		}

	}
	if cutVer >= TableAccessPublicURLVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.PublicURL))+1)
		if err != nil {
			return errors.New("TableAccess.PublicURL string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.PublicURL), 0))
		if err != nil {
			return errors.New("TableAccess.PublicURL string content pack error\n" + err.Error())
		}

	}
	if cutVer >= TableAccessVpcURLVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.VpcURL))+1)
		if err != nil {
			return errors.New("TableAccess.VpcURL string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.VpcURL), 0))
		if err != nil {
			return errors.New("TableAccess.VpcURL string content pack error\n" + err.Error())
		}

	}
	if cutVer >= TableAccessVpcURLV6Version {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.VpcURLV6))+1)
		if err != nil {
			return errors.New("TableAccess.VpcURLV6 string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.VpcURLV6), 0))
		if err != nil {
			return errors.New("TableAccess.VpcURLV6 string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TableAccess) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TableAccess data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TableAccess) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TableAccessCurrentVersion {
		cutVer = TableAccessCurrentVersion
	}
	// check version
	if cutVer < TableAccessBaseVersion {
		errors.New("TableAccess cut version must large than TableAccessBaseVersion\n")
	}

	var URLSize uint32
	err = binary.Read(r, binary.BigEndian, &URLSize)
	if err != nil {
		return errors.New("TableAccess.URL string size unpack error\n" + err.Error())
	}

	URLBytes := make([]byte, URLSize)
	err = binary.Read(r, binary.BigEndian, URLBytes)
	if err != nil {
		return errors.New("TableAccess.URL string content unpack error\n" + err.Error())
	}
	this.URL = string(URLBytes[:len(URLBytes)-1])

	if cutVer >= TableAccessURLV6Version {

		var URLV6Size uint32
		err = binary.Read(r, binary.BigEndian, &URLV6Size)
		if err != nil {
			return errors.New("TableAccess.URLV6 string size unpack error\n" + err.Error())
		}

		URLV6Bytes := make([]byte, URLV6Size)
		err = binary.Read(r, binary.BigEndian, URLV6Bytes)
		if err != nil {
			return errors.New("TableAccess.URLV6 string content unpack error\n" + err.Error())
		}
		this.URLV6 = string(URLV6Bytes[:len(URLV6Bytes)-1])

	}
	if cutVer >= TableAccessProxyIDVersion {

		var ProxyIDSize uint32
		err = binary.Read(r, binary.BigEndian, &ProxyIDSize)
		if err != nil {
			return errors.New("TableAccess.ProxyID string size unpack error\n" + err.Error())
		}

		ProxyIDBytes := make([]byte, ProxyIDSize)
		err = binary.Read(r, binary.BigEndian, ProxyIDBytes)
		if err != nil {
			return errors.New("TableAccess.ProxyID string content unpack error\n" + err.Error())
		}
		this.ProxyID = string(ProxyIDBytes[:len(ProxyIDBytes)-1])

	}
	if cutVer >= TableAccessPublicURLVersion {

		var PublicURLSize uint32
		err = binary.Read(r, binary.BigEndian, &PublicURLSize)
		if err != nil {
			return errors.New("TableAccess.PublicURL string size unpack error\n" + err.Error())
		}

		PublicURLBytes := make([]byte, PublicURLSize)
		err = binary.Read(r, binary.BigEndian, PublicURLBytes)
		if err != nil {
			return errors.New("TableAccess.PublicURL string content unpack error\n" + err.Error())
		}
		this.PublicURL = string(PublicURLBytes[:len(PublicURLBytes)-1])

	}
	if cutVer >= TableAccessVpcURLVersion {

		var VpcURLSize uint32
		err = binary.Read(r, binary.BigEndian, &VpcURLSize)
		if err != nil {
			return errors.New("TableAccess.VpcURL string size unpack error\n" + err.Error())
		}

		VpcURLBytes := make([]byte, VpcURLSize)
		err = binary.Read(r, binary.BigEndian, VpcURLBytes)
		if err != nil {
			return errors.New("TableAccess.VpcURL string content unpack error\n" + err.Error())
		}
		this.VpcURL = string(VpcURLBytes[:len(VpcURLBytes)-1])

	}
	if cutVer >= TableAccessVpcURLV6Version {

		var VpcURLV6Size uint32
		err = binary.Read(r, binary.BigEndian, &VpcURLV6Size)
		if err != nil {
			return errors.New("TableAccess.VpcURLV6 string size unpack error\n" + err.Error())
		}

		VpcURLV6Bytes := make([]byte, VpcURLV6Size)
		err = binary.Read(r, binary.BigEndian, VpcURLV6Bytes)
		if err != nil {
			return errors.New("TableAccess.VpcURLV6 string content unpack error\n" + err.Error())
		}
		this.VpcURLV6 = string(VpcURLV6Bytes[:len(VpcURLV6Bytes)-1])

	}
	return err
}

const (
	TableAccessListBaseVersion    uint32 = 1
	TableAccessListCurrentVersion uint32 = 120
)

// TableAccessList
type TableAccessList struct {
	Table *TableInfo `tdr_field:"Table"`

	BeatPeriod int16 `tdr_field:"BeatPeriod"`

	AccessCount int16 `tdr_field:"AccessCount"`

	AccessList []*TableAccess `tdr_field:"AccessList" tdr_count:"1024" tdr_refer:"AccessCount"`
}

func NewTableAccessList() *TableAccessList {
	obj := new(TableAccessList)
	obj.Init()
	return obj
}

func (this *TableAccessList) GetBaseVersion() uint32 {
	return TableAccessListBaseVersion
}

func (this *TableAccessList) GetCurrentVersion() uint32 {
	return TableAccessListCurrentVersion
}

func (this *TableAccessList) Init() {
	this.Table = NewTableInfo()

	this.BeatPeriod = 10

}

func (this *TableAccessList) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TableAccessList Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TableAccessList) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TableAccessListCurrentVersion {
		cutVer = TableAccessListCurrentVersion
	}
	// check cut version
	if cutVer < TableAccessListBaseVersion {
		return errors.New("TableAccessList cut version must large than TableAccessListBaseVersion\n")
	}

	var err error

	err = this.Table.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TableAccessList.Table pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BeatPeriod)
	if err != nil {
		return errors.New("TableAccessList.BeatPeriod pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AccessCount)
	if err != nil {
		return errors.New("TableAccessList.AccessCount pack error\n" + err.Error())
	}

	if this.AccessCount < 0 {
		return errors.New("TableAccessList.AccessList's refer AccessCount should >= 0")
	}
	if this.AccessCount > 1024 {
		return errors.New("TableAccessList.AccessList's refer AccessCount should <= count 1024")
	}
	if len(this.AccessList) < int(this.AccessCount) {
		return errors.New("TableAccessList.AccessList's length should > AccessCount")
	}
	if this.AccessCount > 0 {
		for i := 0; i < int(this.AccessCount); i++ {
			err = this.AccessList[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TableAccessList.AccessList pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TableAccessList) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TableAccessList data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TableAccessList) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TableAccessListCurrentVersion {
		cutVer = TableAccessListCurrentVersion
	}
	// check version
	if cutVer < TableAccessListBaseVersion {
		errors.New("TableAccessList cut version must large than TableAccessListBaseVersion\n")
	}

	err = this.Table.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TableAccessList.Table unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BeatPeriod)
	if err != nil {
		return errors.New("TableAccessList.BeatPeriod unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AccessCount)
	if err != nil {
		return errors.New("TableAccessList.AccessCount unpack error\n" + err.Error())
	}

	if this.AccessCount < 0 {
		return errors.New("TableAccessList.AccessList's refer AccessCount should >= 0")
	}
	if this.AccessCount > 1024 {
		return errors.New("TableAccessList.AccessList's refer AccessCount should <= count 1024")
	}

	if this.AccessList == nil {
		this.AccessList = make([]*TableAccess, int(this.AccessCount))
		for i := 0; i < int(this.AccessCount); i++ {
			this.AccessList[i] = NewTableAccess()
		}
	}

	for i := 0; i < int(this.AccessCount); i++ {
		err = this.AccessList[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TableAccessList.AccessList unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	DirPolicyBaseVersion    uint32 = 1
	DirPolicyCurrentVersion uint32 = 1
)

// DirPolicy
type DirPolicy struct {
	BeatPeriod int16 `tdr_field:"BeatPeriod"`

	ReconnectSpan int16 `tdr_field:"ReconnectSpan"`

	ReconnectCount int16 `tdr_field:"ReconnectCount"`

	ReportQosLevel int16 `tdr_field:"ReportQosLevel"`
}

func NewDirPolicy() *DirPolicy {
	obj := new(DirPolicy)
	obj.Init()
	return obj
}

func (this *DirPolicy) GetBaseVersion() uint32 {
	return DirPolicyBaseVersion
}

func (this *DirPolicy) GetCurrentVersion() uint32 {
	return DirPolicyCurrentVersion
}

func (this *DirPolicy) Init() {

}

func (this *DirPolicy) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DirPolicy Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DirPolicy) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DirPolicyCurrentVersion {
		cutVer = DirPolicyCurrentVersion
	}
	// check cut version
	if cutVer < DirPolicyBaseVersion {
		return errors.New("DirPolicy cut version must large than DirPolicyBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.BeatPeriod)
	if err != nil {
		return errors.New("DirPolicy.BeatPeriod pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ReconnectSpan)
	if err != nil {
		return errors.New("DirPolicy.ReconnectSpan pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ReconnectCount)
	if err != nil {
		return errors.New("DirPolicy.ReconnectCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ReportQosLevel)
	if err != nil {
		return errors.New("DirPolicy.ReportQosLevel pack error\n" + err.Error())
	}

	return nil
}

func (this *DirPolicy) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DirPolicy data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DirPolicy) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DirPolicyCurrentVersion {
		cutVer = DirPolicyCurrentVersion
	}
	// check version
	if cutVer < DirPolicyBaseVersion {
		errors.New("DirPolicy cut version must large than DirPolicyBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.BeatPeriod)
	if err != nil {
		return errors.New("DirPolicy.BeatPeriod unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ReconnectSpan)
	if err != nil {
		return errors.New("DirPolicy.ReconnectSpan unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ReconnectCount)
	if err != nil {
		return errors.New("DirPolicy.ReconnectCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ReportQosLevel)
	if err != nil {
		return errors.New("DirPolicy.ReportQosLevel unpack error\n" + err.Error())
	}

	return err
}
