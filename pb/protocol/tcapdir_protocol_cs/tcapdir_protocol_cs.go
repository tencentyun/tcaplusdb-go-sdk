// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2020-11-12 20:09:54
package tcapdir_protocol_cs

import (
	"encoding/binary"
	"errors"
	"io"

	"git.code.com/tsf4g/tdrcom"
)

const TCAPDIR_MEMO_LEN int64 = 256
const TCAPDIR_USER_DEFINED_TEXT_LEN int64 = 512

// 认证请求协议
const TCAPDIR_CS_CMD_SIGNUP_REQ int64 = 100

// 认证返回协议
const TCAPDIR_CS_CMD_SIGNUP_RES int64 = 101

// 心跳请求协议
const TCAPDIR_CS_CMD_HEARTBEAT_REQ int64 = 102

// 心跳返回协议
const TCAPDIR_CS_CMD_HEARTBEAT_RES int64 = 103

// 获取dir server列表请求
const TCAPDIR_CS_CMD_GET_DIR_SERVER_LIST_REQ int64 = 104

// 获取dir server列表响应
const TCAPDIR_CS_CMD_GET_DIR_SERVER_LIST_RES int64 = 105

// 获取指定app_id , zone_id下所有表和访问点地址请求
const TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_REQ int64 = 106

// 获取指定app_id , zone_id下所有表和访问点地址响应
const TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_RES int64 = 107

// 动态建表请求
const TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_REQ int64 = 108

// 动态建表应答
const TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_RES int64 = 109

// 动态清表请求
const TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_REQ int64 = 110

// 动态清表应答
const TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_RES int64 = 111

// 获取配置数据请求
const TCAPDIR_CS_CMD_GET_CONF_DATA_REQ int64 = 112

// 获取配置数据应答
const TCAPDIR_CS_CMD_GET_CONF_DATA_RES int64 = 113

// 清理表请求
const TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_REQ int64 = 114

// 清理表应答
const TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_RES int64 = 115

// Api上报Tcaproxy质量数据给Tcapdir请求
const TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_REQ int64 = 116

// Api上报Tcaproxy质量数据给Tcapdir应答
const TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_RES int64 = 117

// 获取分布式索引信息请求
const TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_REQ int64 = 118

// 获取分布式索引信息应答
const TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_RES int64 = 119

// linux64
const TCAPDIR_PLATFORM_LINUX64 int64 = 0

// linux32
const TCAPDIR_PLATFORM_LINUX32 int64 = 1

// windows64
const TCAPDIR_PLATFORM_WIN64 int64 = 2

// windows32
const TCAPDIR_PLATFORM_WIN32 int64 = 3

// 其他平台
const TCAPDIR_PLATFORM_OTHER int64 = 4
const (
	ClientInfoBaseVersion      uint32 = 1
	ClientInfoCurrentVersion   uint32 = 112
	ClientInfoVersionVersion   uint32 = 2
	ClientInfoGitSHA1Version   uint32 = 112
	ClientInfoGitBranchVersion uint32 = 112
)

// ClientInfo
type ClientInfo struct {
	ApiVersion uint32 `tdr_field:"ApiVersion"`

	DetailVer string `tdr_field:"DetailVer"`

	Platform int16 `tdr_field:"Platform"`

	TableCount int16 `tdr_field:"TableCount"`

	TraitBits uint32 `tdr_field:"TraitBits"`

	HostTime uint64 `tdr_field:"HostTime"`

	Version string `tdr_field:"Version"`

	GitSHA1 string `tdr_field:"GitSHA1"`

	GitBranch string `tdr_field:"GitBranch"`
}

func NewClientInfo() *ClientInfo {
	obj := new(ClientInfo)
	obj.Init()
	return obj
}

func (this *ClientInfo) GetBaseVersion() uint32 {
	return ClientInfoBaseVersion
}

func (this *ClientInfo) GetCurrentVersion() uint32 {
	return ClientInfoCurrentVersion
}

func (this *ClientInfo) Init() {

}

func (this *ClientInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ClientInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ClientInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ClientInfoCurrentVersion {
		cutVer = ClientInfoCurrentVersion
	}
	// check cut version
	if cutVer < ClientInfoBaseVersion {
		return errors.New("ClientInfo cut version must large than ClientInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ApiVersion)
	if err != nil {
		return errors.New("ClientInfo.ApiVersion pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.DetailVer))+1)
	if err != nil {
		return errors.New("ClientInfo.DetailVer string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.DetailVer), 0))
	if err != nil {
		return errors.New("ClientInfo.DetailVer string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Platform)
	if err != nil {
		return errors.New("ClientInfo.Platform pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TableCount)
	if err != nil {
		return errors.New("ClientInfo.TableCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TraitBits)
	if err != nil {
		return errors.New("ClientInfo.TraitBits pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.HostTime)
	if err != nil {
		return errors.New("ClientInfo.HostTime pack error\n" + err.Error())
	}

	if cutVer >= ClientInfoVersionVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Version))+1)
		if err != nil {
			return errors.New("ClientInfo.Version string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Version), 0))
		if err != nil {
			return errors.New("ClientInfo.Version string content pack error\n" + err.Error())
		}

	}
	if cutVer >= ClientInfoGitSHA1Version {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.GitSHA1))+1)
		if err != nil {
			return errors.New("ClientInfo.GitSHA1 string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.GitSHA1), 0))
		if err != nil {
			return errors.New("ClientInfo.GitSHA1 string content pack error\n" + err.Error())
		}

	}
	if cutVer >= ClientInfoGitBranchVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.GitBranch))+1)
		if err != nil {
			return errors.New("ClientInfo.GitBranch string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.GitBranch), 0))
		if err != nil {
			return errors.New("ClientInfo.GitBranch string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *ClientInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ClientInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ClientInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ClientInfoCurrentVersion {
		cutVer = ClientInfoCurrentVersion
	}
	// check version
	if cutVer < ClientInfoBaseVersion {
		errors.New("ClientInfo cut version must large than ClientInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ApiVersion)
	if err != nil {
		return errors.New("ClientInfo.ApiVersion unpack error\n" + err.Error())
	}

	var DetailVerSize uint32
	err = binary.Read(r, binary.BigEndian, &DetailVerSize)
	if err != nil {
		return errors.New("ClientInfo.DetailVer string size unpack error\n" + err.Error())
	}

	DetailVerBytes := make([]byte, DetailVerSize)
	err = binary.Read(r, binary.BigEndian, DetailVerBytes)
	if err != nil {
		return errors.New("ClientInfo.DetailVer string content unpack error\n" + err.Error())
	}
	this.DetailVer = string(DetailVerBytes[:len(DetailVerBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Platform)
	if err != nil {
		return errors.New("ClientInfo.Platform unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TableCount)
	if err != nil {
		return errors.New("ClientInfo.TableCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TraitBits)
	if err != nil {
		return errors.New("ClientInfo.TraitBits unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.HostTime)
	if err != nil {
		return errors.New("ClientInfo.HostTime unpack error\n" + err.Error())
	}

	if cutVer >= ClientInfoVersionVersion {

		var VersionSize uint32
		err = binary.Read(r, binary.BigEndian, &VersionSize)
		if err != nil {
			return errors.New("ClientInfo.Version string size unpack error\n" + err.Error())
		}

		VersionBytes := make([]byte, VersionSize)
		err = binary.Read(r, binary.BigEndian, VersionBytes)
		if err != nil {
			return errors.New("ClientInfo.Version string content unpack error\n" + err.Error())
		}
		this.Version = string(VersionBytes[:len(VersionBytes)-1])

	}
	if cutVer >= ClientInfoGitSHA1Version {

		var GitSHA1Size uint32
		err = binary.Read(r, binary.BigEndian, &GitSHA1Size)
		if err != nil {
			return errors.New("ClientInfo.GitSHA1 string size unpack error\n" + err.Error())
		}

		GitSHA1Bytes := make([]byte, GitSHA1Size)
		err = binary.Read(r, binary.BigEndian, GitSHA1Bytes)
		if err != nil {
			return errors.New("ClientInfo.GitSHA1 string content unpack error\n" + err.Error())
		}
		this.GitSHA1 = string(GitSHA1Bytes[:len(GitSHA1Bytes)-1])

	}
	if cutVer >= ClientInfoGitBranchVersion {

		var GitBranchSize uint32
		err = binary.Read(r, binary.BigEndian, &GitBranchSize)
		if err != nil {
			return errors.New("ClientInfo.GitBranch string size unpack error\n" + err.Error())
		}

		GitBranchBytes := make([]byte, GitBranchSize)
		err = binary.Read(r, binary.BigEndian, GitBranchBytes)
		if err != nil {
			return errors.New("ClientInfo.GitBranch string content unpack error\n" + err.Error())
		}
		this.GitBranch = string(GitBranchBytes[:len(GitBranchBytes)-1])

	}
	return err
}

const (
	ConfDataBaseVersion                            uint32 = 5
	ConfDataCurrentVersion                         uint32 = 103
	ConfDataProxyUnavailableThresholdVersion       uint32 = 53
	ConfDataProxyAvailableCheckPeriodVersion       uint32 = 53
	ConfDataProxyAvailableCheckTimesVersion        uint32 = 53
	ConfDataProxyAvailableRecheckIntervalVersion   uint32 = 53
	ConfDataResponseTimeoutVersion                 uint32 = 53
	ConfDataMaxTraverseNodeCountPerTimeVersion     uint32 = 53
	ConfDataCollectCenterBusinessIDVersion         uint32 = 53
	ConfDataDynamicErrorCodeVersion                uint32 = 53
	ConfDataCollectCountVersion                    uint32 = 53
	ConfDataCollectUrlListVersion                  uint32 = 53
	ConfDataReportPeriodVersion                    uint32 = 53
	ConfDataMetalibIDVersion                       uint32 = 54
	ConfDataDynamicConnectTcapdirSwitchVersion     uint32 = 55
	ConfDataGdataBuzidVersion                      uint32 = 86
	ConfDataGdataLogidVersion                      uint32 = 86
	ConfDataUserDefinedLatencyMSVersion            uint32 = 86
	ConfDataLowMiddleLatencyThresholdMSVersion     uint32 = 86
	ConfDataMiddleHighLatencyThresholdMSVersion    uint32 = 86
	ConfDataMaxReportTableNumPerLoopVersion        uint32 = 86
	ConfDataMaxReportAccessNumPerLoopVersion       uint32 = 86
	ConfDataDirAvailableCheckPeriodVersion         uint32 = 86
	ConfDataApiFromDirHeartBeatTimeVersion         uint32 = 86
	ConfDataApiFromProxyHeartBeatTimeVersion       uint32 = 86
	ConfDataDirUpdateListIntervalVersion           uint32 = 86
	ConfDataDirUpdateTablesAndAcessIntervalVersion uint32 = 86
	ConfDataNeedCheckTableVersion                  uint32 = 103
)

// ConfData
type ConfData struct {
	HeartBeatTime int32 `tdr_field:"HeartBeatTime"`

	CompressThreshold int32 `tdr_field:"CompressThreshold"`

	ProxyUnavailableThreshold int32 `tdr_field:"ProxyUnavailableThreshold"`

	ProxyAvailableCheckPeriod int32 `tdr_field:"ProxyAvailableCheckPeriod"`

	ProxyAvailableCheckTimes int32 `tdr_field:"ProxyAvailableCheckTimes"`

	ProxyAvailableRecheckInterval int32 `tdr_field:"ProxyAvailableRecheckInterval"`

	ResponseTimeout int32 `tdr_field:"ResponseTimeout"`

	MaxTraverseNodeCountPerTime int32 `tdr_field:"MaxTraverseNodeCountPerTime"`

	CollectCenterBusinessID int32 `tdr_field:"CollectCenterBusinessID"`

	DynamicErrorCode int32 `tdr_field:"DynamicErrorCode"`

	CollectCount int32 `tdr_field:"CollectCount"`

	CollectUrlList []string `tdr_field:"CollectUrlList" tdr_count:"32" tdr_refer:"CollectCount"`

	ReportPeriod int32 `tdr_field:"ReportPeriod"`

	MetalibID int32 `tdr_field:"MetalibID"`

	DynamicConnectTcapdirSwitch int32 `tdr_field:"DynamicConnectTcapdirSwitch"`

	GdataBuzid int32 `tdr_field:"GdataBuzid"`

	GdataLogid int32 `tdr_field:"GdataLogid"`

	UserDefinedLatencyMS int32 `tdr_field:"UserDefinedLatencyMS"`

	LowMiddleLatencyThresholdMS int32 `tdr_field:"LowMiddleLatencyThresholdMS"`

	MiddleHighLatencyThresholdMS int32 `tdr_field:"MiddleHighLatencyThresholdMS"`

	MaxReportTableNumPerLoop int32 `tdr_field:"MaxReportTableNumPerLoop"`

	MaxReportAccessNumPerLoop int32 `tdr_field:"MaxReportAccessNumPerLoop"`

	DirAvailableCheckPeriod int32 `tdr_field:"DirAvailableCheckPeriod"`

	ApiFromDirHeartBeatTime int32 `tdr_field:"ApiFromDirHeartBeatTime"`

	ApiFromProxyHeartBeatTime int32 `tdr_field:"ApiFromProxyHeartBeatTime"`

	DirUpdateListInterval int32 `tdr_field:"DirUpdateListInterval"`

	DirUpdateTablesAndAcessInterval int32 `tdr_field:"DirUpdateTablesAndAcessInterval"`

	NeedCheckTable int32 `tdr_field:"NeedCheckTable"`
}

func NewConfData() *ConfData {
	obj := new(ConfData)
	obj.Init()
	return obj
}

func (this *ConfData) GetBaseVersion() uint32 {
	return ConfDataBaseVersion
}

func (this *ConfData) GetCurrentVersion() uint32 {
	return ConfDataCurrentVersion
}

func (this *ConfData) Init() {
	this.HeartBeatTime = 30

	this.CompressThreshold = 0

	this.ProxyUnavailableThreshold = 90

	this.ProxyAvailableCheckPeriod = 10

	this.ProxyAvailableCheckTimes = 3

	this.ProxyAvailableRecheckInterval = 60

	this.ResponseTimeout = 3000

	this.MaxTraverseNodeCountPerTime = 100

	this.CollectCenterBusinessID = 0

	this.DynamicErrorCode = 0

	this.CollectCount = 0

	this.ReportPeriod = 60

	this.MetalibID = 0

	this.DynamicConnectTcapdirSwitch = 1

	this.GdataBuzid = 0

	this.GdataLogid = 0

	this.UserDefinedLatencyMS = 3000

	this.LowMiddleLatencyThresholdMS = 640

	this.MiddleHighLatencyThresholdMS = 1280

	this.MaxReportTableNumPerLoop = 64

	this.MaxReportAccessNumPerLoop = 50

	this.DirAvailableCheckPeriod = 30

	this.ApiFromDirHeartBeatTime = 10

	this.ApiFromProxyHeartBeatTime = 1

	this.DirUpdateListInterval = 60

	this.DirUpdateTablesAndAcessInterval = 300

	this.NeedCheckTable = 0

}

func (this *ConfData) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ConfData Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ConfData) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ConfDataCurrentVersion {
		cutVer = ConfDataCurrentVersion
	}
	// check cut version
	if cutVer < ConfDataBaseVersion {
		return errors.New("ConfData cut version must large than ConfDataBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.HeartBeatTime)
	if err != nil {
		return errors.New("ConfData.HeartBeatTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CompressThreshold)
	if err != nil {
		return errors.New("ConfData.CompressThreshold pack error\n" + err.Error())
	}

	if cutVer >= ConfDataProxyUnavailableThresholdVersion {

		err = binary.Write(w, binary.BigEndian, this.ProxyUnavailableThreshold)
		if err != nil {
			return errors.New("ConfData.ProxyUnavailableThreshold pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataProxyAvailableCheckPeriodVersion {

		err = binary.Write(w, binary.BigEndian, this.ProxyAvailableCheckPeriod)
		if err != nil {
			return errors.New("ConfData.ProxyAvailableCheckPeriod pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataProxyAvailableCheckTimesVersion {

		err = binary.Write(w, binary.BigEndian, this.ProxyAvailableCheckTimes)
		if err != nil {
			return errors.New("ConfData.ProxyAvailableCheckTimes pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataProxyAvailableRecheckIntervalVersion {

		err = binary.Write(w, binary.BigEndian, this.ProxyAvailableRecheckInterval)
		if err != nil {
			return errors.New("ConfData.ProxyAvailableRecheckInterval pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataResponseTimeoutVersion {

		err = binary.Write(w, binary.BigEndian, this.ResponseTimeout)
		if err != nil {
			return errors.New("ConfData.ResponseTimeout pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataMaxTraverseNodeCountPerTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.MaxTraverseNodeCountPerTime)
		if err != nil {
			return errors.New("ConfData.MaxTraverseNodeCountPerTime pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataCollectCenterBusinessIDVersion {

		err = binary.Write(w, binary.BigEndian, this.CollectCenterBusinessID)
		if err != nil {
			return errors.New("ConfData.CollectCenterBusinessID pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataDynamicErrorCodeVersion {

		err = binary.Write(w, binary.BigEndian, this.DynamicErrorCode)
		if err != nil {
			return errors.New("ConfData.DynamicErrorCode pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataCollectCountVersion {

		err = binary.Write(w, binary.BigEndian, this.CollectCount)
		if err != nil {
			return errors.New("ConfData.CollectCount pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataCollectUrlListVersion {

		if this.CollectCount < 0 {
			return errors.New("ConfData.CollectUrlList's refer CollectCount should >= 0")
		}
		if this.CollectCount > 32 {
			return errors.New("ConfData.CollectUrlList's refer CollectCount should <= count 32")
		}
		if len(this.CollectUrlList) < int(this.CollectCount) {
			return errors.New("ConfData.CollectUrlList's length should > CollectCount")
		}
		if this.CollectCount > 0 {
			for i := 0; i < int(this.CollectCount); i++ {
				err = binary.Write(w, binary.BigEndian, uint32(len(this.CollectUrlList[i]))+1)
				if err != nil {
					return errors.New("ConfData.CollectUrlList string size pack error\n" + err.Error())
				}
				err = binary.Write(w, binary.BigEndian, append([]byte(this.CollectUrlList[i]), 0))
				if err != nil {
					return errors.New("ConfData.CollectUrlList string content pack error\n" + err.Error())
				}

			}
		}

	}
	if cutVer >= ConfDataReportPeriodVersion {

		err = binary.Write(w, binary.BigEndian, this.ReportPeriod)
		if err != nil {
			return errors.New("ConfData.ReportPeriod pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataMetalibIDVersion {

		err = binary.Write(w, binary.BigEndian, this.MetalibID)
		if err != nil {
			return errors.New("ConfData.MetalibID pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataDynamicConnectTcapdirSwitchVersion {

		err = binary.Write(w, binary.BigEndian, this.DynamicConnectTcapdirSwitch)
		if err != nil {
			return errors.New("ConfData.DynamicConnectTcapdirSwitch pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataGdataBuzidVersion {

		err = binary.Write(w, binary.BigEndian, this.GdataBuzid)
		if err != nil {
			return errors.New("ConfData.GdataBuzid pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataGdataLogidVersion {

		err = binary.Write(w, binary.BigEndian, this.GdataLogid)
		if err != nil {
			return errors.New("ConfData.GdataLogid pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataUserDefinedLatencyMSVersion {

		err = binary.Write(w, binary.BigEndian, this.UserDefinedLatencyMS)
		if err != nil {
			return errors.New("ConfData.UserDefinedLatencyMS pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataLowMiddleLatencyThresholdMSVersion {

		err = binary.Write(w, binary.BigEndian, this.LowMiddleLatencyThresholdMS)
		if err != nil {
			return errors.New("ConfData.LowMiddleLatencyThresholdMS pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataMiddleHighLatencyThresholdMSVersion {

		err = binary.Write(w, binary.BigEndian, this.MiddleHighLatencyThresholdMS)
		if err != nil {
			return errors.New("ConfData.MiddleHighLatencyThresholdMS pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataMaxReportTableNumPerLoopVersion {

		err = binary.Write(w, binary.BigEndian, this.MaxReportTableNumPerLoop)
		if err != nil {
			return errors.New("ConfData.MaxReportTableNumPerLoop pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataMaxReportAccessNumPerLoopVersion {

		err = binary.Write(w, binary.BigEndian, this.MaxReportAccessNumPerLoop)
		if err != nil {
			return errors.New("ConfData.MaxReportAccessNumPerLoop pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataDirAvailableCheckPeriodVersion {

		err = binary.Write(w, binary.BigEndian, this.DirAvailableCheckPeriod)
		if err != nil {
			return errors.New("ConfData.DirAvailableCheckPeriod pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataApiFromDirHeartBeatTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.ApiFromDirHeartBeatTime)
		if err != nil {
			return errors.New("ConfData.ApiFromDirHeartBeatTime pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataApiFromProxyHeartBeatTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.ApiFromProxyHeartBeatTime)
		if err != nil {
			return errors.New("ConfData.ApiFromProxyHeartBeatTime pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataDirUpdateListIntervalVersion {

		err = binary.Write(w, binary.BigEndian, this.DirUpdateListInterval)
		if err != nil {
			return errors.New("ConfData.DirUpdateListInterval pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataDirUpdateTablesAndAcessIntervalVersion {

		err = binary.Write(w, binary.BigEndian, this.DirUpdateTablesAndAcessInterval)
		if err != nil {
			return errors.New("ConfData.DirUpdateTablesAndAcessInterval pack error\n" + err.Error())
		}

	}
	if cutVer >= ConfDataNeedCheckTableVersion {

		err = binary.Write(w, binary.BigEndian, this.NeedCheckTable)
		if err != nil {
			return errors.New("ConfData.NeedCheckTable pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *ConfData) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ConfData data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ConfData) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ConfDataCurrentVersion {
		cutVer = ConfDataCurrentVersion
	}
	// check version
	if cutVer < ConfDataBaseVersion {
		errors.New("ConfData cut version must large than ConfDataBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.HeartBeatTime)
	if err != nil {
		return errors.New("ConfData.HeartBeatTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CompressThreshold)
	if err != nil {
		return errors.New("ConfData.CompressThreshold unpack error\n" + err.Error())
	}

	if cutVer >= ConfDataProxyUnavailableThresholdVersion {

		err = binary.Read(r, binary.BigEndian, &this.ProxyUnavailableThreshold)
		if err != nil {
			return errors.New("ConfData.ProxyUnavailableThreshold unpack error\n" + err.Error())
		}

	} else {
		this.ProxyUnavailableThreshold = 90

	}
	if cutVer >= ConfDataProxyAvailableCheckPeriodVersion {

		err = binary.Read(r, binary.BigEndian, &this.ProxyAvailableCheckPeriod)
		if err != nil {
			return errors.New("ConfData.ProxyAvailableCheckPeriod unpack error\n" + err.Error())
		}

	} else {
		this.ProxyAvailableCheckPeriod = 10

	}
	if cutVer >= ConfDataProxyAvailableCheckTimesVersion {

		err = binary.Read(r, binary.BigEndian, &this.ProxyAvailableCheckTimes)
		if err != nil {
			return errors.New("ConfData.ProxyAvailableCheckTimes unpack error\n" + err.Error())
		}

	} else {
		this.ProxyAvailableCheckTimes = 3

	}
	if cutVer >= ConfDataProxyAvailableRecheckIntervalVersion {

		err = binary.Read(r, binary.BigEndian, &this.ProxyAvailableRecheckInterval)
		if err != nil {
			return errors.New("ConfData.ProxyAvailableRecheckInterval unpack error\n" + err.Error())
		}

	} else {
		this.ProxyAvailableRecheckInterval = 60

	}
	if cutVer >= ConfDataResponseTimeoutVersion {

		err = binary.Read(r, binary.BigEndian, &this.ResponseTimeout)
		if err != nil {
			return errors.New("ConfData.ResponseTimeout unpack error\n" + err.Error())
		}

	} else {
		this.ResponseTimeout = 3000

	}
	if cutVer >= ConfDataMaxTraverseNodeCountPerTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.MaxTraverseNodeCountPerTime)
		if err != nil {
			return errors.New("ConfData.MaxTraverseNodeCountPerTime unpack error\n" + err.Error())
		}

	} else {
		this.MaxTraverseNodeCountPerTime = 100

	}
	if cutVer >= ConfDataCollectCenterBusinessIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.CollectCenterBusinessID)
		if err != nil {
			return errors.New("ConfData.CollectCenterBusinessID unpack error\n" + err.Error())
		}

	} else {
		this.CollectCenterBusinessID = 0

	}
	if cutVer >= ConfDataDynamicErrorCodeVersion {

		err = binary.Read(r, binary.BigEndian, &this.DynamicErrorCode)
		if err != nil {
			return errors.New("ConfData.DynamicErrorCode unpack error\n" + err.Error())
		}

	} else {
		this.DynamicErrorCode = 0

	}
	if cutVer >= ConfDataCollectCountVersion {

		err = binary.Read(r, binary.BigEndian, &this.CollectCount)
		if err != nil {
			return errors.New("ConfData.CollectCount unpack error\n" + err.Error())
		}

	} else {
		this.CollectCount = 0

	}
	if cutVer >= ConfDataCollectUrlListVersion {

		if this.CollectCount < 0 {
			return errors.New("ConfData.CollectUrlList's refer CollectCount should >= 0")
		}
		if this.CollectCount > 32 {
			return errors.New("ConfData.CollectUrlList's refer CollectCount should <= count 32")
		}

		if this.CollectUrlList == nil {
			this.CollectUrlList = make([]string, int(this.CollectCount))
		}

		for i := 0; i < int(this.CollectCount); i++ {
			var CollectUrlListSize uint32
			err = binary.Read(r, binary.BigEndian, &CollectUrlListSize)
			if err != nil {
				return errors.New("ConfData.CollectUrlList string size unpack error\n" + err.Error())
			}

			CollectUrlListBytes := make([]byte, CollectUrlListSize)
			err = binary.Read(r, binary.BigEndian, CollectUrlListBytes)
			if err != nil {
				return errors.New("ConfData.CollectUrlList string content unpack error\n" + err.Error())
			}
			this.CollectUrlList[i] = string(CollectUrlListBytes[:len(CollectUrlListBytes)-1])

		}

	}
	if cutVer >= ConfDataReportPeriodVersion {

		err = binary.Read(r, binary.BigEndian, &this.ReportPeriod)
		if err != nil {
			return errors.New("ConfData.ReportPeriod unpack error\n" + err.Error())
		}

	} else {
		this.ReportPeriod = 60

	}
	if cutVer >= ConfDataMetalibIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.MetalibID)
		if err != nil {
			return errors.New("ConfData.MetalibID unpack error\n" + err.Error())
		}

	} else {
		this.MetalibID = 0

	}
	if cutVer >= ConfDataDynamicConnectTcapdirSwitchVersion {

		err = binary.Read(r, binary.BigEndian, &this.DynamicConnectTcapdirSwitch)
		if err != nil {
			return errors.New("ConfData.DynamicConnectTcapdirSwitch unpack error\n" + err.Error())
		}

	} else {
		this.DynamicConnectTcapdirSwitch = 1

	}
	if cutVer >= ConfDataGdataBuzidVersion {

		err = binary.Read(r, binary.BigEndian, &this.GdataBuzid)
		if err != nil {
			return errors.New("ConfData.GdataBuzid unpack error\n" + err.Error())
		}

	} else {
		this.GdataBuzid = 0

	}
	if cutVer >= ConfDataGdataLogidVersion {

		err = binary.Read(r, binary.BigEndian, &this.GdataLogid)
		if err != nil {
			return errors.New("ConfData.GdataLogid unpack error\n" + err.Error())
		}

	} else {
		this.GdataLogid = 0

	}
	if cutVer >= ConfDataUserDefinedLatencyMSVersion {

		err = binary.Read(r, binary.BigEndian, &this.UserDefinedLatencyMS)
		if err != nil {
			return errors.New("ConfData.UserDefinedLatencyMS unpack error\n" + err.Error())
		}

	} else {
		this.UserDefinedLatencyMS = 3000

	}
	if cutVer >= ConfDataLowMiddleLatencyThresholdMSVersion {

		err = binary.Read(r, binary.BigEndian, &this.LowMiddleLatencyThresholdMS)
		if err != nil {
			return errors.New("ConfData.LowMiddleLatencyThresholdMS unpack error\n" + err.Error())
		}

	} else {
		this.LowMiddleLatencyThresholdMS = 640

	}
	if cutVer >= ConfDataMiddleHighLatencyThresholdMSVersion {

		err = binary.Read(r, binary.BigEndian, &this.MiddleHighLatencyThresholdMS)
		if err != nil {
			return errors.New("ConfData.MiddleHighLatencyThresholdMS unpack error\n" + err.Error())
		}

	} else {
		this.MiddleHighLatencyThresholdMS = 1280

	}
	if cutVer >= ConfDataMaxReportTableNumPerLoopVersion {

		err = binary.Read(r, binary.BigEndian, &this.MaxReportTableNumPerLoop)
		if err != nil {
			return errors.New("ConfData.MaxReportTableNumPerLoop unpack error\n" + err.Error())
		}

	} else {
		this.MaxReportTableNumPerLoop = 64

	}
	if cutVer >= ConfDataMaxReportAccessNumPerLoopVersion {

		err = binary.Read(r, binary.BigEndian, &this.MaxReportAccessNumPerLoop)
		if err != nil {
			return errors.New("ConfData.MaxReportAccessNumPerLoop unpack error\n" + err.Error())
		}

	} else {
		this.MaxReportAccessNumPerLoop = 50

	}
	if cutVer >= ConfDataDirAvailableCheckPeriodVersion {

		err = binary.Read(r, binary.BigEndian, &this.DirAvailableCheckPeriod)
		if err != nil {
			return errors.New("ConfData.DirAvailableCheckPeriod unpack error\n" + err.Error())
		}

	} else {
		this.DirAvailableCheckPeriod = 30

	}
	if cutVer >= ConfDataApiFromDirHeartBeatTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ApiFromDirHeartBeatTime)
		if err != nil {
			return errors.New("ConfData.ApiFromDirHeartBeatTime unpack error\n" + err.Error())
		}

	} else {
		this.ApiFromDirHeartBeatTime = 10

	}
	if cutVer >= ConfDataApiFromProxyHeartBeatTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ApiFromProxyHeartBeatTime)
		if err != nil {
			return errors.New("ConfData.ApiFromProxyHeartBeatTime unpack error\n" + err.Error())
		}

	} else {
		this.ApiFromProxyHeartBeatTime = 1

	}
	if cutVer >= ConfDataDirUpdateListIntervalVersion {

		err = binary.Read(r, binary.BigEndian, &this.DirUpdateListInterval)
		if err != nil {
			return errors.New("ConfData.DirUpdateListInterval unpack error\n" + err.Error())
		}

	} else {
		this.DirUpdateListInterval = 60

	}
	if cutVer >= ConfDataDirUpdateTablesAndAcessIntervalVersion {

		err = binary.Read(r, binary.BigEndian, &this.DirUpdateTablesAndAcessInterval)
		if err != nil {
			return errors.New("ConfData.DirUpdateTablesAndAcessInterval unpack error\n" + err.Error())
		}

	} else {
		this.DirUpdateTablesAndAcessInterval = 300

	}
	if cutVer >= ConfDataNeedCheckTableVersion {

		err = binary.Read(r, binary.BigEndian, &this.NeedCheckTable)
		if err != nil {
			return errors.New("ConfData.NeedCheckTable unpack error\n" + err.Error())
		}

	} else {
		this.NeedCheckTable = 0

	}
	return err
}

const (
	AccessQosBaseVersion    uint32 = 110
	AccessQosCurrentVersion uint32 = 110
)

// AccessQos
type AccessQos struct {
	SvrId string `tdr_field:"SvrId"`

	RequestCount uint32 `tdr_field:"RequestCount"`

	TimeoutCount uint32 `tdr_field:"TimeoutCount"`

	ProxyReturnSystemErrCount uint32 `tdr_field:"ProxyReturnSystemErrCount"`
}

func NewAccessQos() *AccessQos {
	obj := new(AccessQos)
	obj.Init()
	return obj
}

func (this *AccessQos) GetBaseVersion() uint32 {
	return AccessQosBaseVersion
}

func (this *AccessQos) GetCurrentVersion() uint32 {
	return AccessQosCurrentVersion
}

func (this *AccessQos) Init() {

}

func (this *AccessQos) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("AccessQos Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *AccessQos) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > AccessQosCurrentVersion {
		cutVer = AccessQosCurrentVersion
	}
	// check cut version
	if cutVer < AccessQosBaseVersion {
		return errors.New("AccessQos cut version must large than AccessQosBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.SvrId))+1)
	if err != nil {
		return errors.New("AccessQos.SvrId string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.SvrId), 0))
	if err != nil {
		return errors.New("AccessQos.SvrId string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RequestCount)
	if err != nil {
		return errors.New("AccessQos.RequestCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TimeoutCount)
	if err != nil {
		return errors.New("AccessQos.TimeoutCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ProxyReturnSystemErrCount)
	if err != nil {
		return errors.New("AccessQos.ProxyReturnSystemErrCount pack error\n" + err.Error())
	}

	return nil
}

func (this *AccessQos) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("AccessQos data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *AccessQos) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > AccessQosCurrentVersion {
		cutVer = AccessQosCurrentVersion
	}
	// check version
	if cutVer < AccessQosBaseVersion {
		errors.New("AccessQos cut version must large than AccessQosBaseVersion\n")
	}

	var SvrIdSize uint32
	err = binary.Read(r, binary.BigEndian, &SvrIdSize)
	if err != nil {
		return errors.New("AccessQos.SvrId string size unpack error\n" + err.Error())
	}

	SvrIdBytes := make([]byte, SvrIdSize)
	err = binary.Read(r, binary.BigEndian, SvrIdBytes)
	if err != nil {
		return errors.New("AccessQos.SvrId string content unpack error\n" + err.Error())
	}
	this.SvrId = string(SvrIdBytes[:len(SvrIdBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.RequestCount)
	if err != nil {
		return errors.New("AccessQos.RequestCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TimeoutCount)
	if err != nil {
		return errors.New("AccessQos.TimeoutCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ProxyReturnSystemErrCount)
	if err != nil {
		return errors.New("AccessQos.ProxyReturnSystemErrCount unpack error\n" + err.Error())
	}

	return err
}

const (
	ApiReportAccessQosReqBaseVersion    uint32 = 110
	ApiReportAccessQosReqCurrentVersion uint32 = 110
)

// ApiReportAccessQosReq
type ApiReportAccessQosReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	IP string `tdr_field:"IP"`

	Pid int32 `tdr_field:"Pid"`

	AccessCount int32 `tdr_field:"AccessCount"`

	AccessQos []*AccessQos `tdr_field:"AccessQos" tdr_count:"200" tdr_refer:"AccessCount"`
}

func NewApiReportAccessQosReq() *ApiReportAccessQosReq {
	obj := new(ApiReportAccessQosReq)
	obj.Init()
	return obj
}

func (this *ApiReportAccessQosReq) GetBaseVersion() uint32 {
	return ApiReportAccessQosReqBaseVersion
}

func (this *ApiReportAccessQosReq) GetCurrentVersion() uint32 {
	return ApiReportAccessQosReqCurrentVersion
}

func (this *ApiReportAccessQosReq) Init() {

}

func (this *ApiReportAccessQosReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ApiReportAccessQosReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ApiReportAccessQosReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ApiReportAccessQosReqCurrentVersion {
		cutVer = ApiReportAccessQosReqCurrentVersion
	}
	// check cut version
	if cutVer < ApiReportAccessQosReqBaseVersion {
		return errors.New("ApiReportAccessQosReq cut version must large than ApiReportAccessQosReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.IP))+1)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.IP string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.IP), 0))
	if err != nil {
		return errors.New("ApiReportAccessQosReq.IP string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Pid)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.Pid pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AccessCount)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.AccessCount pack error\n" + err.Error())
	}

	if this.AccessCount < 0 {
		return errors.New("ApiReportAccessQosReq.AccessQos's refer AccessCount should >= 0")
	}
	if this.AccessCount > 200 {
		return errors.New("ApiReportAccessQosReq.AccessQos's refer AccessCount should <= count 200")
	}
	if len(this.AccessQos) < int(this.AccessCount) {
		return errors.New("ApiReportAccessQosReq.AccessQos's length should > AccessCount")
	}
	if this.AccessCount > 0 {
		for i := 0; i < int(this.AccessCount); i++ {
			err = this.AccessQos[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("ApiReportAccessQosReq.AccessQos pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *ApiReportAccessQosReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ApiReportAccessQosReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ApiReportAccessQosReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ApiReportAccessQosReqCurrentVersion {
		cutVer = ApiReportAccessQosReqCurrentVersion
	}
	// check version
	if cutVer < ApiReportAccessQosReqBaseVersion {
		errors.New("ApiReportAccessQosReq cut version must large than ApiReportAccessQosReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.ZoneID unpack error\n" + err.Error())
	}

	var IPSize uint32
	err = binary.Read(r, binary.BigEndian, &IPSize)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.IP string size unpack error\n" + err.Error())
	}

	IPBytes := make([]byte, IPSize)
	err = binary.Read(r, binary.BigEndian, IPBytes)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.IP string content unpack error\n" + err.Error())
	}
	this.IP = string(IPBytes[:len(IPBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Pid)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.Pid unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AccessCount)
	if err != nil {
		return errors.New("ApiReportAccessQosReq.AccessCount unpack error\n" + err.Error())
	}

	if this.AccessCount < 0 {
		return errors.New("ApiReportAccessQosReq.AccessQos's refer AccessCount should >= 0")
	}
	if this.AccessCount > 200 {
		return errors.New("ApiReportAccessQosReq.AccessQos's refer AccessCount should <= count 200")
	}

	if this.AccessQos == nil {
		this.AccessQos = make([]*AccessQos, int(this.AccessCount))
		for i := 0; i < int(this.AccessCount); i++ {
			this.AccessQos[i] = NewAccessQos()
		}
	}

	for i := 0; i < int(this.AccessCount); i++ {
		err = this.AccessQos[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ApiReportAccessQosReq.AccessQos unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	ApiReportAccessQosResBaseVersion    uint32 = 110
	ApiReportAccessQosResCurrentVersion uint32 = 110
)

// ApiReportAccessQosRes
type ApiReportAccessQosRes struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	Result int32 `tdr_field:"Result"`
}

func NewApiReportAccessQosRes() *ApiReportAccessQosRes {
	obj := new(ApiReportAccessQosRes)
	obj.Init()
	return obj
}

func (this *ApiReportAccessQosRes) GetBaseVersion() uint32 {
	return ApiReportAccessQosResBaseVersion
}

func (this *ApiReportAccessQosRes) GetCurrentVersion() uint32 {
	return ApiReportAccessQosResCurrentVersion
}

func (this *ApiReportAccessQosRes) Init() {

}

func (this *ApiReportAccessQosRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ApiReportAccessQosRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ApiReportAccessQosRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ApiReportAccessQosResCurrentVersion {
		cutVer = ApiReportAccessQosResCurrentVersion
	}
	// check cut version
	if cutVer < ApiReportAccessQosResBaseVersion {
		return errors.New("ApiReportAccessQosRes cut version must large than ApiReportAccessQosResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("ApiReportAccessQosRes.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("ApiReportAccessQosRes.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("ApiReportAccessQosRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *ApiReportAccessQosRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ApiReportAccessQosRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ApiReportAccessQosRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ApiReportAccessQosResCurrentVersion {
		cutVer = ApiReportAccessQosResCurrentVersion
	}
	// check version
	if cutVer < ApiReportAccessQosResBaseVersion {
		errors.New("ApiReportAccessQosRes cut version must large than ApiReportAccessQosResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("ApiReportAccessQosRes.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("ApiReportAccessQosRes.ZoneID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("ApiReportAccessQosRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TableQosBaseVersion    uint32 = 1
	TableQosCurrentVersion uint32 = 1
)

// TableQos
type TableQos struct {
	TableName string `tdr_field:"TableName"`

	ZoneID int32 `tdr_field:"ZoneID"`

	AccessCount int16 `tdr_field:"AccessCount"`

	AccessErrCount uint32 `tdr_field:"AccessErrCount"`

	QueryErrCount uint32 `tdr_field:"QueryErrCount"`

	InsertErrCount uint32 `tdr_field:"InsertErrCount"`

	UpdateErrCount uint32 `tdr_field:"UpdateErrCount"`

	ReplaceErrCount uint32 `tdr_field:"ReplaceErrCount"`

	DeleteErrCount uint32 `tdr_field:"DeleteErrCount"`

	PackErrorCount int32 `tdr_field:"PackErrorCount"`

	UnpackErrorCount int32 `tdr_field:"UnpackErrorCount"`

	SendErrorCount int32 `tdr_field:"SendErrorCount"`

	RecvErrorCount int32 `tdr_field:"RecvErrorCount"`

	RounteErrorCount int32 `tdr_field:"RounteErrorCount"`

	OtherErrorCount int32 `tdr_field:"OtherErrorCount"`

	LastError int32 `tdr_field:"LastError"`

	MostError int32 `tdr_field:"MostError"`

	ExceptError int32 `tdr_field:"ExceptError"`

	Memo string `tdr_field:"Memo"`
}

func NewTableQos() *TableQos {
	obj := new(TableQos)
	obj.Init()
	return obj
}

func (this *TableQos) GetBaseVersion() uint32 {
	return TableQosBaseVersion
}

func (this *TableQos) GetCurrentVersion() uint32 {
	return TableQosCurrentVersion
}

func (this *TableQos) Init() {

}

func (this *TableQos) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TableQos Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TableQos) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TableQosCurrentVersion {
		cutVer = TableQosCurrentVersion
	}
	// check cut version
	if cutVer < TableQosBaseVersion {
		return errors.New("TableQos cut version must large than TableQosBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("TableQos.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("TableQos.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("TableQos.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AccessCount)
	if err != nil {
		return errors.New("TableQos.AccessCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AccessErrCount)
	if err != nil {
		return errors.New("TableQos.AccessErrCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.QueryErrCount)
	if err != nil {
		return errors.New("TableQos.QueryErrCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.InsertErrCount)
	if err != nil {
		return errors.New("TableQos.InsertErrCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.UpdateErrCount)
	if err != nil {
		return errors.New("TableQos.UpdateErrCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ReplaceErrCount)
	if err != nil {
		return errors.New("TableQos.ReplaceErrCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.DeleteErrCount)
	if err != nil {
		return errors.New("TableQos.DeleteErrCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.PackErrorCount)
	if err != nil {
		return errors.New("TableQos.PackErrorCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.UnpackErrorCount)
	if err != nil {
		return errors.New("TableQos.UnpackErrorCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SendErrorCount)
	if err != nil {
		return errors.New("TableQos.SendErrorCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecvErrorCount)
	if err != nil {
		return errors.New("TableQos.RecvErrorCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RounteErrorCount)
	if err != nil {
		return errors.New("TableQos.RounteErrorCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.OtherErrorCount)
	if err != nil {
		return errors.New("TableQos.OtherErrorCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LastError)
	if err != nil {
		return errors.New("TableQos.LastError pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MostError)
	if err != nil {
		return errors.New("TableQos.MostError pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ExceptError)
	if err != nil {
		return errors.New("TableQos.ExceptError pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Memo))+1)
	if err != nil {
		return errors.New("TableQos.Memo string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Memo), 0))
	if err != nil {
		return errors.New("TableQos.Memo string content pack error\n" + err.Error())
	}

	return nil
}

func (this *TableQos) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TableQos data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TableQos) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TableQosCurrentVersion {
		cutVer = TableQosCurrentVersion
	}
	// check version
	if cutVer < TableQosBaseVersion {
		errors.New("TableQos cut version must large than TableQosBaseVersion\n")
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("TableQos.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("TableQos.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("TableQos.ZoneID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AccessCount)
	if err != nil {
		return errors.New("TableQos.AccessCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AccessErrCount)
	if err != nil {
		return errors.New("TableQos.AccessErrCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.QueryErrCount)
	if err != nil {
		return errors.New("TableQos.QueryErrCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.InsertErrCount)
	if err != nil {
		return errors.New("TableQos.InsertErrCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.UpdateErrCount)
	if err != nil {
		return errors.New("TableQos.UpdateErrCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ReplaceErrCount)
	if err != nil {
		return errors.New("TableQos.ReplaceErrCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.DeleteErrCount)
	if err != nil {
		return errors.New("TableQos.DeleteErrCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.PackErrorCount)
	if err != nil {
		return errors.New("TableQos.PackErrorCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.UnpackErrorCount)
	if err != nil {
		return errors.New("TableQos.UnpackErrorCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SendErrorCount)
	if err != nil {
		return errors.New("TableQos.SendErrorCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecvErrorCount)
	if err != nil {
		return errors.New("TableQos.RecvErrorCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RounteErrorCount)
	if err != nil {
		return errors.New("TableQos.RounteErrorCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.OtherErrorCount)
	if err != nil {
		return errors.New("TableQos.OtherErrorCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LastError)
	if err != nil {
		return errors.New("TableQos.LastError unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.MostError)
	if err != nil {
		return errors.New("TableQos.MostError unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ExceptError)
	if err != nil {
		return errors.New("TableQos.ExceptError unpack error\n" + err.Error())
	}

	var MemoSize uint32
	err = binary.Read(r, binary.BigEndian, &MemoSize)
	if err != nil {
		return errors.New("TableQos.Memo string size unpack error\n" + err.Error())
	}

	MemoBytes := make([]byte, MemoSize)
	err = binary.Read(r, binary.BigEndian, MemoBytes)
	if err != nil {
		return errors.New("TableQos.Memo string content unpack error\n" + err.Error())
	}
	this.Memo = string(MemoBytes[:len(MemoBytes)-1])

	return err
}

const (
	QosReportBaseVersion            uint32 = 1
	QosReportCurrentVersion         uint32 = 51
	QosReportUserDefinedTextVersion uint32 = 51
)

// QosReport
type QosReport struct {
	LastBeatCost int16 `tdr_field:"LastBeatCost"`

	TableCount int16 `tdr_field:"TableCount"`

	TableQos []*TableQos `tdr_field:"TableQos" tdr_count:"256" tdr_refer:"TableCount"`

	UserDefinedText string `tdr_field:"UserDefinedText"`
}

func NewQosReport() *QosReport {
	obj := new(QosReport)
	obj.Init()
	return obj
}

func (this *QosReport) GetBaseVersion() uint32 {
	return QosReportBaseVersion
}

func (this *QosReport) GetCurrentVersion() uint32 {
	return QosReportCurrentVersion
}

func (this *QosReport) Init() {

}

func (this *QosReport) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("QosReport Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *QosReport) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > QosReportCurrentVersion {
		cutVer = QosReportCurrentVersion
	}
	// check cut version
	if cutVer < QosReportBaseVersion {
		return errors.New("QosReport cut version must large than QosReportBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.LastBeatCost)
	if err != nil {
		return errors.New("QosReport.LastBeatCost pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TableCount)
	if err != nil {
		return errors.New("QosReport.TableCount pack error\n" + err.Error())
	}

	if this.TableCount < 0 {
		return errors.New("QosReport.TableQos's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("QosReport.TableQos's refer TableCount should <= count 256")
	}
	if len(this.TableQos) < int(this.TableCount) {
		return errors.New("QosReport.TableQos's length should > TableCount")
	}
	if this.TableCount > 0 {
		for i := 0; i < int(this.TableCount); i++ {
			err = this.TableQos[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("QosReport.TableQos pack error\n" + err.Error())
			}

		}
	}

	if cutVer >= QosReportUserDefinedTextVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.UserDefinedText))+1)
		if err != nil {
			return errors.New("QosReport.UserDefinedText string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.UserDefinedText), 0))
		if err != nil {
			return errors.New("QosReport.UserDefinedText string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *QosReport) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("QosReport data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *QosReport) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > QosReportCurrentVersion {
		cutVer = QosReportCurrentVersion
	}
	// check version
	if cutVer < QosReportBaseVersion {
		errors.New("QosReport cut version must large than QosReportBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.LastBeatCost)
	if err != nil {
		return errors.New("QosReport.LastBeatCost unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TableCount)
	if err != nil {
		return errors.New("QosReport.TableCount unpack error\n" + err.Error())
	}

	if this.TableCount < 0 {
		return errors.New("QosReport.TableQos's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("QosReport.TableQos's refer TableCount should <= count 256")
	}

	if this.TableQos == nil {
		this.TableQos = make([]*TableQos, int(this.TableCount))
		for i := 0; i < int(this.TableCount); i++ {
			this.TableQos[i] = NewTableQos()
		}
	}

	for i := 0; i < int(this.TableCount); i++ {
		err = this.TableQos[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("QosReport.TableQos unpack error\n" + err.Error())
		}

	}

	if cutVer >= QosReportUserDefinedTextVersion {

		var UserDefinedTextSize uint32
		err = binary.Read(r, binary.BigEndian, &UserDefinedTextSize)
		if err != nil {
			return errors.New("QosReport.UserDefinedText string size unpack error\n" + err.Error())
		}

		UserDefinedTextBytes := make([]byte, UserDefinedTextSize)
		err = binary.Read(r, binary.BigEndian, UserDefinedTextBytes)
		if err != nil {
			return errors.New("QosReport.UserDefinedText string content unpack error\n" + err.Error())
		}
		this.UserDefinedText = string(UserDefinedTextBytes[:len(UserDefinedTextBytes)-1])

	}
	return err
}

const (
	ReqSignUpAppBaseVersion    uint32 = 1
	ReqSignUpAppCurrentVersion uint32 = 112
)

// ReqSignUpApp
type ReqSignUpApp struct {
	Signature string `tdr_field:"Signature"`

	Type int16 `tdr_field:"Type"`

	ClientInfo *ClientInfo `tdr_field:"ClientInfo"`

	TableCount int16 `tdr_field:"TableCount"`

	TableList []*TableInfo `tdr_field:"TableList" tdr_count:"256" tdr_refer:"TableCount"`
}

func NewReqSignUpApp() *ReqSignUpApp {
	obj := new(ReqSignUpApp)
	obj.Init()
	return obj
}

func (this *ReqSignUpApp) GetBaseVersion() uint32 {
	return ReqSignUpAppBaseVersion
}

func (this *ReqSignUpApp) GetCurrentVersion() uint32 {
	return ReqSignUpAppCurrentVersion
}

func (this *ReqSignUpApp) Init() {

	this.ClientInfo = NewClientInfo()

}

func (this *ReqSignUpApp) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ReqSignUpApp Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ReqSignUpApp) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ReqSignUpAppCurrentVersion {
		cutVer = ReqSignUpAppCurrentVersion
	}
	// check cut version
	if cutVer < ReqSignUpAppBaseVersion {
		return errors.New("ReqSignUpApp cut version must large than ReqSignUpAppBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Signature))+1)
	if err != nil {
		return errors.New("ReqSignUpApp.Signature string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Signature), 0))
	if err != nil {
		return errors.New("ReqSignUpApp.Signature string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type)
	if err != nil {
		return errors.New("ReqSignUpApp.Type pack error\n" + err.Error())
	}

	err = this.ClientInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("ReqSignUpApp.ClientInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TableCount)
	if err != nil {
		return errors.New("ReqSignUpApp.TableCount pack error\n" + err.Error())
	}

	if this.TableCount < 0 {
		return errors.New("ReqSignUpApp.TableList's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("ReqSignUpApp.TableList's refer TableCount should <= count 256")
	}
	if len(this.TableList) < int(this.TableCount) {
		return errors.New("ReqSignUpApp.TableList's length should > TableCount")
	}
	if this.TableCount > 0 {
		for i := 0; i < int(this.TableCount); i++ {
			err = this.TableList[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("ReqSignUpApp.TableList pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *ReqSignUpApp) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ReqSignUpApp data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ReqSignUpApp) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ReqSignUpAppCurrentVersion {
		cutVer = ReqSignUpAppCurrentVersion
	}
	// check version
	if cutVer < ReqSignUpAppBaseVersion {
		errors.New("ReqSignUpApp cut version must large than ReqSignUpAppBaseVersion\n")
	}

	var SignatureSize uint32
	err = binary.Read(r, binary.BigEndian, &SignatureSize)
	if err != nil {
		return errors.New("ReqSignUpApp.Signature string size unpack error\n" + err.Error())
	}

	SignatureBytes := make([]byte, SignatureSize)
	err = binary.Read(r, binary.BigEndian, SignatureBytes)
	if err != nil {
		return errors.New("ReqSignUpApp.Signature string content unpack error\n" + err.Error())
	}
	this.Signature = string(SignatureBytes[:len(SignatureBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type)
	if err != nil {
		return errors.New("ReqSignUpApp.Type unpack error\n" + err.Error())
	}

	err = this.ClientInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("ReqSignUpApp.ClientInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TableCount)
	if err != nil {
		return errors.New("ReqSignUpApp.TableCount unpack error\n" + err.Error())
	}

	if this.TableCount < 0 {
		return errors.New("ReqSignUpApp.TableList's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("ReqSignUpApp.TableList's refer TableCount should <= count 256")
	}

	if this.TableList == nil {
		this.TableList = make([]*TableInfo, int(this.TableCount))
		for i := 0; i < int(this.TableCount); i++ {
			this.TableList[i] = NewTableInfo()
		}
	}

	for i := 0; i < int(this.TableCount); i++ {
		err = this.TableList[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ReqSignUpApp.TableList unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	ResSignUpAppBaseVersion    uint32 = 1
	ResSignUpAppCurrentVersion uint32 = 107
)

// ResSignUpApp
type ResSignUpApp struct {
	Result int32 `tdr_field:"Result"`

	HasPolicy int16 `tdr_field:"HasPolicy"`

	TableCount int16 `tdr_field:"TableCount"`

	DirPolicy *DirPolicy `tdr_field:"DirPolicy" tdr_refer:"HasPolicy"`

	TableList []*TableAccessList `tdr_field:"TableList" tdr_count:"256" tdr_refer:"TableCount"`
}

func NewResSignUpApp() *ResSignUpApp {
	obj := new(ResSignUpApp)
	obj.Init()
	return obj
}

func (this *ResSignUpApp) GetBaseVersion() uint32 {
	return ResSignUpAppBaseVersion
}

func (this *ResSignUpApp) GetCurrentVersion() uint32 {
	return ResSignUpAppCurrentVersion
}

func (this *ResSignUpApp) Init() {

	this.DirPolicy = NewDirPolicy()

}

func (this *ResSignUpApp) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ResSignUpApp Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ResSignUpApp) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ResSignUpAppCurrentVersion {
		cutVer = ResSignUpAppCurrentVersion
	}
	// check cut version
	if cutVer < ResSignUpAppBaseVersion {
		return errors.New("ResSignUpApp cut version must large than ResSignUpAppBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("ResSignUpApp.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.HasPolicy)
	if err != nil {
		return errors.New("ResSignUpApp.HasPolicy pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TableCount)
	if err != nil {
		return errors.New("ResSignUpApp.TableCount pack error\n" + err.Error())
	}

	if this.HasPolicy != 0 && this.HasPolicy != 1 {
		return errors.New("ResSignUpApp.DirPolicy is not array, this.HasPolicy should be 0 or 1")
	}
	if this.HasPolicy == 1 {
		err = this.DirPolicy.PackTo(cutVer, w)
		if err != nil {
			return errors.New("ResSignUpApp.DirPolicy pack error\n" + err.Error())
		}

	}

	if this.TableCount < 0 {
		return errors.New("ResSignUpApp.TableList's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("ResSignUpApp.TableList's refer TableCount should <= count 256")
	}
	if len(this.TableList) < int(this.TableCount) {
		return errors.New("ResSignUpApp.TableList's length should > TableCount")
	}
	if this.TableCount > 0 {
		for i := 0; i < int(this.TableCount); i++ {
			err = this.TableList[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("ResSignUpApp.TableList pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *ResSignUpApp) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ResSignUpApp data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ResSignUpApp) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ResSignUpAppCurrentVersion {
		cutVer = ResSignUpAppCurrentVersion
	}
	// check version
	if cutVer < ResSignUpAppBaseVersion {
		errors.New("ResSignUpApp cut version must large than ResSignUpAppBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("ResSignUpApp.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.HasPolicy)
	if err != nil {
		return errors.New("ResSignUpApp.HasPolicy unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TableCount)
	if err != nil {
		return errors.New("ResSignUpApp.TableCount unpack error\n" + err.Error())
	}

	if this.HasPolicy != 0 && this.HasPolicy != 1 {
		return errors.New("ResSignUpApp.DirPolicy is not array, this.HasPolicy should be 0 or 1")
	}
	if this.HasPolicy == 1 {
		err = this.DirPolicy.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ResSignUpApp.DirPolicy unpack error\n" + err.Error())
		}

	}

	if this.TableCount < 0 {
		return errors.New("ResSignUpApp.TableList's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("ResSignUpApp.TableList's refer TableCount should <= count 256")
	}

	if this.TableList == nil {
		this.TableList = make([]*TableAccessList, int(this.TableCount))
		for i := 0; i < int(this.TableCount); i++ {
			this.TableList[i] = NewTableAccessList()
		}
	}

	for i := 0; i < int(this.TableCount); i++ {
		err = this.TableList[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ResSignUpApp.TableList unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	ReqHeartBeatBaseVersion    uint32 = 1
	ReqHeartBeatCurrentVersion uint32 = 51
)

// ReqHeartBeat
type ReqHeartBeat struct {
	HostTime uint64 `tdr_field:"HostTime"`

	WithQos int16 `tdr_field:"WithQos"`

	QosReport *QosReport `tdr_field:"QosReport" tdr_refer:"WithQos"`
}

func NewReqHeartBeat() *ReqHeartBeat {
	obj := new(ReqHeartBeat)
	obj.Init()
	return obj
}

func (this *ReqHeartBeat) GetBaseVersion() uint32 {
	return ReqHeartBeatBaseVersion
}

func (this *ReqHeartBeat) GetCurrentVersion() uint32 {
	return ReqHeartBeatCurrentVersion
}

func (this *ReqHeartBeat) Init() {

	this.WithQos = 0

	this.QosReport = NewQosReport()

}

func (this *ReqHeartBeat) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ReqHeartBeat Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ReqHeartBeat) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ReqHeartBeatCurrentVersion {
		cutVer = ReqHeartBeatCurrentVersion
	}
	// check cut version
	if cutVer < ReqHeartBeatBaseVersion {
		return errors.New("ReqHeartBeat cut version must large than ReqHeartBeatBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.HostTime)
	if err != nil {
		return errors.New("ReqHeartBeat.HostTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.WithQos)
	if err != nil {
		return errors.New("ReqHeartBeat.WithQos pack error\n" + err.Error())
	}

	if this.WithQos != 0 && this.WithQos != 1 {
		return errors.New("ReqHeartBeat.QosReport is not array, this.WithQos should be 0 or 1")
	}
	if this.WithQos == 1 {
		err = this.QosReport.PackTo(cutVer, w)
		if err != nil {
			return errors.New("ReqHeartBeat.QosReport pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *ReqHeartBeat) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ReqHeartBeat data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ReqHeartBeat) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ReqHeartBeatCurrentVersion {
		cutVer = ReqHeartBeatCurrentVersion
	}
	// check version
	if cutVer < ReqHeartBeatBaseVersion {
		errors.New("ReqHeartBeat cut version must large than ReqHeartBeatBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.HostTime)
	if err != nil {
		return errors.New("ReqHeartBeat.HostTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.WithQos)
	if err != nil {
		return errors.New("ReqHeartBeat.WithQos unpack error\n" + err.Error())
	}

	if this.WithQos != 0 && this.WithQos != 1 {
		return errors.New("ReqHeartBeat.QosReport is not array, this.WithQos should be 0 or 1")
	}
	if this.WithQos == 1 {
		err = this.QosReport.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ReqHeartBeat.QosReport unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	ResHeartBeatBaseVersion    uint32 = 1
	ResHeartBeatCurrentVersion uint32 = 1
)

// ResHeartBeat
type ResHeartBeat struct {
	HostTime uint64 `tdr_field:"HostTime"`

	ServTime uint64 `tdr_field:"ServTime"`
}

func NewResHeartBeat() *ResHeartBeat {
	obj := new(ResHeartBeat)
	obj.Init()
	return obj
}

func (this *ResHeartBeat) GetBaseVersion() uint32 {
	return ResHeartBeatBaseVersion
}

func (this *ResHeartBeat) GetCurrentVersion() uint32 {
	return ResHeartBeatCurrentVersion
}

func (this *ResHeartBeat) Init() {

}

func (this *ResHeartBeat) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ResHeartBeat Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ResHeartBeat) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ResHeartBeatCurrentVersion {
		cutVer = ResHeartBeatCurrentVersion
	}
	// check cut version
	if cutVer < ResHeartBeatBaseVersion {
		return errors.New("ResHeartBeat cut version must large than ResHeartBeatBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.HostTime)
	if err != nil {
		return errors.New("ResHeartBeat.HostTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ServTime)
	if err != nil {
		return errors.New("ResHeartBeat.ServTime pack error\n" + err.Error())
	}

	return nil
}

func (this *ResHeartBeat) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ResHeartBeat data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ResHeartBeat) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ResHeartBeatCurrentVersion {
		cutVer = ResHeartBeatCurrentVersion
	}
	// check version
	if cutVer < ResHeartBeatBaseVersion {
		errors.New("ResHeartBeat cut version must large than ResHeartBeatBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.HostTime)
	if err != nil {
		return errors.New("ResHeartBeat.HostTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ServTime)
	if err != nil {
		return errors.New("ResHeartBeat.ServTime unpack error\n" + err.Error())
	}

	return err
}

const (
	ResGetDirServerListBaseVersion    uint32 = 3
	ResGetDirServerListCurrentVersion uint32 = 3
)

// ResGetDirServerList
type ResGetDirServerList struct {
	Result int32 `tdr_field:"Result"`

	DirServerCount int32 `tdr_field:"DirServerCount"`

	DirServer []string `tdr_field:"DirServer" tdr_count:"10" tdr_refer:"DirServerCount"`
}

func NewResGetDirServerList() *ResGetDirServerList {
	obj := new(ResGetDirServerList)
	obj.Init()
	return obj
}

func (this *ResGetDirServerList) GetBaseVersion() uint32 {
	return ResGetDirServerListBaseVersion
}

func (this *ResGetDirServerList) GetCurrentVersion() uint32 {
	return ResGetDirServerListCurrentVersion
}

func (this *ResGetDirServerList) Init() {

}

func (this *ResGetDirServerList) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ResGetDirServerList Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ResGetDirServerList) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ResGetDirServerListCurrentVersion {
		cutVer = ResGetDirServerListCurrentVersion
	}
	// check cut version
	if cutVer < ResGetDirServerListBaseVersion {
		return errors.New("ResGetDirServerList cut version must large than ResGetDirServerListBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("ResGetDirServerList.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.DirServerCount)
	if err != nil {
		return errors.New("ResGetDirServerList.DirServerCount pack error\n" + err.Error())
	}

	if this.DirServerCount < 0 {
		return errors.New("ResGetDirServerList.DirServer's refer DirServerCount should >= 0")
	}
	if this.DirServerCount > 10 {
		return errors.New("ResGetDirServerList.DirServer's refer DirServerCount should <= count 10")
	}
	if len(this.DirServer) < int(this.DirServerCount) {
		return errors.New("ResGetDirServerList.DirServer's length should > DirServerCount")
	}
	if this.DirServerCount > 0 {
		for i := 0; i < int(this.DirServerCount); i++ {
			err = binary.Write(w, binary.BigEndian, uint32(len(this.DirServer[i]))+1)
			if err != nil {
				return errors.New("ResGetDirServerList.DirServer string size pack error\n" + err.Error())
			}
			err = binary.Write(w, binary.BigEndian, append([]byte(this.DirServer[i]), 0))
			if err != nil {
				return errors.New("ResGetDirServerList.DirServer string content pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *ResGetDirServerList) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ResGetDirServerList data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ResGetDirServerList) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ResGetDirServerListCurrentVersion {
		cutVer = ResGetDirServerListCurrentVersion
	}
	// check version
	if cutVer < ResGetDirServerListBaseVersion {
		errors.New("ResGetDirServerList cut version must large than ResGetDirServerListBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("ResGetDirServerList.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.DirServerCount)
	if err != nil {
		return errors.New("ResGetDirServerList.DirServerCount unpack error\n" + err.Error())
	}

	if this.DirServerCount < 0 {
		return errors.New("ResGetDirServerList.DirServer's refer DirServerCount should >= 0")
	}
	if this.DirServerCount > 10 {
		return errors.New("ResGetDirServerList.DirServer's refer DirServerCount should <= count 10")
	}

	if this.DirServer == nil {
		this.DirServer = make([]string, int(this.DirServerCount))
	}

	for i := 0; i < int(this.DirServerCount); i++ {
		var DirServerSize uint32
		err = binary.Read(r, binary.BigEndian, &DirServerSize)
		if err != nil {
			return errors.New("ResGetDirServerList.DirServer string size unpack error\n" + err.Error())
		}

		DirServerBytes := make([]byte, DirServerSize)
		err = binary.Read(r, binary.BigEndian, DirServerBytes)
		if err != nil {
			return errors.New("ResGetDirServerList.DirServer string content unpack error\n" + err.Error())
		}
		this.DirServer[i] = string(DirServerBytes[:len(DirServerBytes)-1])

	}

	return err
}

const (
	ReqGetTablesAndAccessBaseVersion       uint32 = 3
	ReqGetTablesAndAccessCurrentVersion    uint32 = 85
	ReqGetTablesAndAccessIdentityIdVersion uint32 = 85
)

// ReqGetTablesAndAccess
type ReqGetTablesAndAccess struct {
	ZoneID int32 `tdr_field:"ZoneID"`

	Signature string `tdr_field:"Signature"`

	Version string `tdr_field:"Version"`

	IdentityId string `tdr_field:"IdentityId"`
}

func NewReqGetTablesAndAccess() *ReqGetTablesAndAccess {
	obj := new(ReqGetTablesAndAccess)
	obj.Init()
	return obj
}

func (this *ReqGetTablesAndAccess) GetBaseVersion() uint32 {
	return ReqGetTablesAndAccessBaseVersion
}

func (this *ReqGetTablesAndAccess) GetCurrentVersion() uint32 {
	return ReqGetTablesAndAccessCurrentVersion
}

func (this *ReqGetTablesAndAccess) Init() {

}

func (this *ReqGetTablesAndAccess) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ReqGetTablesAndAccess Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ReqGetTablesAndAccess) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ReqGetTablesAndAccessCurrentVersion {
		cutVer = ReqGetTablesAndAccessCurrentVersion
	}
	// check cut version
	if cutVer < ReqGetTablesAndAccessBaseVersion {
		return errors.New("ReqGetTablesAndAccess cut version must large than ReqGetTablesAndAccessBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Signature))+1)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Signature string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Signature), 0))
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Signature string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Version))+1)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Version string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Version), 0))
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Version string content pack error\n" + err.Error())
	}

	if cutVer >= ReqGetTablesAndAccessIdentityIdVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.IdentityId))+1)
		if err != nil {
			return errors.New("ReqGetTablesAndAccess.IdentityId string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.IdentityId), 0))
		if err != nil {
			return errors.New("ReqGetTablesAndAccess.IdentityId string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *ReqGetTablesAndAccess) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ReqGetTablesAndAccess data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ReqGetTablesAndAccess) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ReqGetTablesAndAccessCurrentVersion {
		cutVer = ReqGetTablesAndAccessCurrentVersion
	}
	// check version
	if cutVer < ReqGetTablesAndAccessBaseVersion {
		errors.New("ReqGetTablesAndAccess cut version must large than ReqGetTablesAndAccessBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.ZoneID unpack error\n" + err.Error())
	}

	var SignatureSize uint32
	err = binary.Read(r, binary.BigEndian, &SignatureSize)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Signature string size unpack error\n" + err.Error())
	}

	SignatureBytes := make([]byte, SignatureSize)
	err = binary.Read(r, binary.BigEndian, SignatureBytes)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Signature string content unpack error\n" + err.Error())
	}
	this.Signature = string(SignatureBytes[:len(SignatureBytes)-1])

	var VersionSize uint32
	err = binary.Read(r, binary.BigEndian, &VersionSize)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Version string size unpack error\n" + err.Error())
	}

	VersionBytes := make([]byte, VersionSize)
	err = binary.Read(r, binary.BigEndian, VersionBytes)
	if err != nil {
		return errors.New("ReqGetTablesAndAccess.Version string content unpack error\n" + err.Error())
	}
	this.Version = string(VersionBytes[:len(VersionBytes)-1])

	if cutVer >= ReqGetTablesAndAccessIdentityIdVersion {

		var IdentityIdSize uint32
		err = binary.Read(r, binary.BigEndian, &IdentityIdSize)
		if err != nil {
			return errors.New("ReqGetTablesAndAccess.IdentityId string size unpack error\n" + err.Error())
		}

		IdentityIdBytes := make([]byte, IdentityIdSize)
		err = binary.Read(r, binary.BigEndian, IdentityIdBytes)
		if err != nil {
			return errors.New("ReqGetTablesAndAccess.IdentityId string content unpack error\n" + err.Error())
		}
		this.IdentityId = string(IdentityIdBytes[:len(IdentityIdBytes)-1])

	}
	return err
}

const (
	ResGetTablesAndAccessBaseVersion         uint32 = 3
	ResGetTablesAndAccessCurrentVersion      uint32 = 103
	ResGetTablesAndAccessSetIDVersion        uint32 = 53
	ResGetTablesAndAccessSetNameVersion      uint32 = 53
	ResGetTablesAndAccessAppIDVersion        uint32 = 53
	ResGetTablesAndAccessAppNameVersion      uint32 = 53
	ResGetTablesAndAccessZoneIDVersion       uint32 = 50
	ResGetTablesAndAccessZoneNameVersion     uint32 = 53
	ResGetTablesAndAccessAccessIdListVersion uint32 = 53
	ResGetTablesAndAccessConfDataVersion     uint32 = 5
)

// ResGetTablesAndAccess
type ResGetTablesAndAccess struct {
	Result int32 `tdr_field:"Result"`

	SetID int32 `tdr_field:"SetID"`

	SetName string `tdr_field:"SetName"`

	AppID int32 `tdr_field:"AppID"`

	AppName string `tdr_field:"AppName"`

	ZoneID int32 `tdr_field:"ZoneID"`

	ZoneName string `tdr_field:"ZoneName"`

	TableCount int32 `tdr_field:"TableCount"`

	TableNameList []string `tdr_field:"TableNameList" tdr_count:"256" tdr_refer:"TableCount"`

	AccessCount int32 `tdr_field:"AccessCount"`

	AccessUrlList []string `tdr_field:"AccessUrlList" tdr_count:"200" tdr_refer:"AccessCount"`

	AccessIdList []string `tdr_field:"AccessIdList" tdr_count:"200" tdr_refer:"AccessCount"`

	ConfData *ConfData `tdr_field:"ConfData"`
}

func NewResGetTablesAndAccess() *ResGetTablesAndAccess {
	obj := new(ResGetTablesAndAccess)
	obj.Init()
	return obj
}

func (this *ResGetTablesAndAccess) GetBaseVersion() uint32 {
	return ResGetTablesAndAccessBaseVersion
}

func (this *ResGetTablesAndAccess) GetCurrentVersion() uint32 {
	return ResGetTablesAndAccessCurrentVersion
}

func (this *ResGetTablesAndAccess) Init() {

	this.ConfData = NewConfData()

}

func (this *ResGetTablesAndAccess) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ResGetTablesAndAccess Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ResGetTablesAndAccess) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ResGetTablesAndAccessCurrentVersion {
		cutVer = ResGetTablesAndAccessCurrentVersion
	}
	// check cut version
	if cutVer < ResGetTablesAndAccessBaseVersion {
		return errors.New("ResGetTablesAndAccess cut version must large than ResGetTablesAndAccessBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("ResGetTablesAndAccess.Result pack error\n" + err.Error())
	}

	if cutVer >= ResGetTablesAndAccessSetIDVersion {

		err = binary.Write(w, binary.BigEndian, this.SetID)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.SetID pack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessSetNameVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.SetName))+1)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.SetName string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.SetName), 0))
		if err != nil {
			return errors.New("ResGetTablesAndAccess.SetName string content pack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessAppIDVersion {

		err = binary.Write(w, binary.BigEndian, this.AppID)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AppID pack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessAppNameVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.AppName))+1)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AppName string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.AppName), 0))
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AppName string content pack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessZoneIDVersion {

		err = binary.Write(w, binary.BigEndian, this.ZoneID)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ZoneID pack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessZoneNameVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.ZoneName))+1)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ZoneName string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.ZoneName), 0))
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ZoneName string content pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.TableCount)
	if err != nil {
		return errors.New("ResGetTablesAndAccess.TableCount pack error\n" + err.Error())
	}

	if this.TableCount < 0 {
		return errors.New("ResGetTablesAndAccess.TableNameList's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("ResGetTablesAndAccess.TableNameList's refer TableCount should <= count 256")
	}
	if len(this.TableNameList) < int(this.TableCount) {
		return errors.New("ResGetTablesAndAccess.TableNameList's length should > TableCount")
	}
	if this.TableCount > 0 {
		for i := 0; i < int(this.TableCount); i++ {
			err = binary.Write(w, binary.BigEndian, uint32(len(this.TableNameList[i]))+1)
			if err != nil {
				return errors.New("ResGetTablesAndAccess.TableNameList string size pack error\n" + err.Error())
			}
			err = binary.Write(w, binary.BigEndian, append([]byte(this.TableNameList[i]), 0))
			if err != nil {
				return errors.New("ResGetTablesAndAccess.TableNameList string content pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.AccessCount)
	if err != nil {
		return errors.New("ResGetTablesAndAccess.AccessCount pack error\n" + err.Error())
	}

	if this.AccessCount < 0 {
		return errors.New("ResGetTablesAndAccess.AccessUrlList's refer AccessCount should >= 0")
	}
	if this.AccessCount > 200 {
		return errors.New("ResGetTablesAndAccess.AccessUrlList's refer AccessCount should <= count 200")
	}
	if len(this.AccessUrlList) < int(this.AccessCount) {
		return errors.New("ResGetTablesAndAccess.AccessUrlList's length should > AccessCount")
	}
	if this.AccessCount > 0 {
		for i := 0; i < int(this.AccessCount); i++ {
			err = binary.Write(w, binary.BigEndian, uint32(len(this.AccessUrlList[i]))+1)
			if err != nil {
				return errors.New("ResGetTablesAndAccess.AccessUrlList string size pack error\n" + err.Error())
			}
			err = binary.Write(w, binary.BigEndian, append([]byte(this.AccessUrlList[i]), 0))
			if err != nil {
				return errors.New("ResGetTablesAndAccess.AccessUrlList string content pack error\n" + err.Error())
			}

		}
	}

	if cutVer >= ResGetTablesAndAccessAccessIdListVersion {

		if this.AccessCount < 0 {
			return errors.New("ResGetTablesAndAccess.AccessIdList's refer AccessCount should >= 0")
		}
		if this.AccessCount > 200 {
			return errors.New("ResGetTablesAndAccess.AccessIdList's refer AccessCount should <= count 200")
		}
		if len(this.AccessIdList) < int(this.AccessCount) {
			return errors.New("ResGetTablesAndAccess.AccessIdList's length should > AccessCount")
		}
		if this.AccessCount > 0 {
			for i := 0; i < int(this.AccessCount); i++ {
				err = binary.Write(w, binary.BigEndian, uint32(len(this.AccessIdList[i]))+1)
				if err != nil {
					return errors.New("ResGetTablesAndAccess.AccessIdList string size pack error\n" + err.Error())
				}
				err = binary.Write(w, binary.BigEndian, append([]byte(this.AccessIdList[i]), 0))
				if err != nil {
					return errors.New("ResGetTablesAndAccess.AccessIdList string content pack error\n" + err.Error())
				}

			}
		}

	}
	if cutVer >= ResGetTablesAndAccessConfDataVersion {

		err = this.ConfData.PackTo(cutVer, w)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ConfData pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *ResGetTablesAndAccess) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ResGetTablesAndAccess data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ResGetTablesAndAccess) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ResGetTablesAndAccessCurrentVersion {
		cutVer = ResGetTablesAndAccessCurrentVersion
	}
	// check version
	if cutVer < ResGetTablesAndAccessBaseVersion {
		errors.New("ResGetTablesAndAccess cut version must large than ResGetTablesAndAccessBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("ResGetTablesAndAccess.Result unpack error\n" + err.Error())
	}

	if cutVer >= ResGetTablesAndAccessSetIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.SetID)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.SetID unpack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessSetNameVersion {

		var SetNameSize uint32
		err = binary.Read(r, binary.BigEndian, &SetNameSize)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.SetName string size unpack error\n" + err.Error())
		}

		SetNameBytes := make([]byte, SetNameSize)
		err = binary.Read(r, binary.BigEndian, SetNameBytes)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.SetName string content unpack error\n" + err.Error())
		}
		this.SetName = string(SetNameBytes[:len(SetNameBytes)-1])

	}
	if cutVer >= ResGetTablesAndAccessAppIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.AppID)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AppID unpack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessAppNameVersion {

		var AppNameSize uint32
		err = binary.Read(r, binary.BigEndian, &AppNameSize)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AppName string size unpack error\n" + err.Error())
		}

		AppNameBytes := make([]byte, AppNameSize)
		err = binary.Read(r, binary.BigEndian, AppNameBytes)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AppName string content unpack error\n" + err.Error())
		}
		this.AppName = string(AppNameBytes[:len(AppNameBytes)-1])

	}
	if cutVer >= ResGetTablesAndAccessZoneIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.ZoneID)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ZoneID unpack error\n" + err.Error())
		}

	}
	if cutVer >= ResGetTablesAndAccessZoneNameVersion {

		var ZoneNameSize uint32
		err = binary.Read(r, binary.BigEndian, &ZoneNameSize)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ZoneName string size unpack error\n" + err.Error())
		}

		ZoneNameBytes := make([]byte, ZoneNameSize)
		err = binary.Read(r, binary.BigEndian, ZoneNameBytes)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ZoneName string content unpack error\n" + err.Error())
		}
		this.ZoneName = string(ZoneNameBytes[:len(ZoneNameBytes)-1])

	}

	err = binary.Read(r, binary.BigEndian, &this.TableCount)
	if err != nil {
		return errors.New("ResGetTablesAndAccess.TableCount unpack error\n" + err.Error())
	}

	if this.TableCount < 0 {
		return errors.New("ResGetTablesAndAccess.TableNameList's refer TableCount should >= 0")
	}
	if this.TableCount > 256 {
		return errors.New("ResGetTablesAndAccess.TableNameList's refer TableCount should <= count 256")
	}

	if this.TableNameList == nil {
		this.TableNameList = make([]string, int(this.TableCount))
	}

	for i := 0; i < int(this.TableCount); i++ {
		var TableNameListSize uint32
		err = binary.Read(r, binary.BigEndian, &TableNameListSize)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.TableNameList string size unpack error\n" + err.Error())
		}

		TableNameListBytes := make([]byte, TableNameListSize)
		err = binary.Read(r, binary.BigEndian, TableNameListBytes)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.TableNameList string content unpack error\n" + err.Error())
		}
		this.TableNameList[i] = string(TableNameListBytes[:len(TableNameListBytes)-1])

	}

	err = binary.Read(r, binary.BigEndian, &this.AccessCount)
	if err != nil {
		return errors.New("ResGetTablesAndAccess.AccessCount unpack error\n" + err.Error())
	}

	if this.AccessCount < 0 {
		return errors.New("ResGetTablesAndAccess.AccessUrlList's refer AccessCount should >= 0")
	}
	if this.AccessCount > 200 {
		return errors.New("ResGetTablesAndAccess.AccessUrlList's refer AccessCount should <= count 200")
	}

	if this.AccessUrlList == nil {
		this.AccessUrlList = make([]string, int(this.AccessCount))
	}

	for i := 0; i < int(this.AccessCount); i++ {
		var AccessUrlListSize uint32
		err = binary.Read(r, binary.BigEndian, &AccessUrlListSize)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AccessUrlList string size unpack error\n" + err.Error())
		}

		AccessUrlListBytes := make([]byte, AccessUrlListSize)
		err = binary.Read(r, binary.BigEndian, AccessUrlListBytes)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.AccessUrlList string content unpack error\n" + err.Error())
		}
		this.AccessUrlList[i] = string(AccessUrlListBytes[:len(AccessUrlListBytes)-1])

	}

	if cutVer >= ResGetTablesAndAccessAccessIdListVersion {

		if this.AccessCount < 0 {
			return errors.New("ResGetTablesAndAccess.AccessIdList's refer AccessCount should >= 0")
		}
		if this.AccessCount > 200 {
			return errors.New("ResGetTablesAndAccess.AccessIdList's refer AccessCount should <= count 200")
		}

		if this.AccessIdList == nil {
			this.AccessIdList = make([]string, int(this.AccessCount))
		}

		for i := 0; i < int(this.AccessCount); i++ {
			var AccessIdListSize uint32
			err = binary.Read(r, binary.BigEndian, &AccessIdListSize)
			if err != nil {
				return errors.New("ResGetTablesAndAccess.AccessIdList string size unpack error\n" + err.Error())
			}

			AccessIdListBytes := make([]byte, AccessIdListSize)
			err = binary.Read(r, binary.BigEndian, AccessIdListBytes)
			if err != nil {
				return errors.New("ResGetTablesAndAccess.AccessIdList string content unpack error\n" + err.Error())
			}
			this.AccessIdList[i] = string(AccessIdListBytes[:len(AccessIdListBytes)-1])

		}

	}
	if cutVer >= ResGetTablesAndAccessConfDataVersion {

		err = this.ConfData.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ResGetTablesAndAccess.ConfData unpack error\n" + err.Error())
		}

	} else {
		this.ConfData.Init()

	}
	return err
}

const (
	KeyFieldItemBaseVersion    uint32 = 1
	KeyFieldItemCurrentVersion uint32 = 1
)

// KeyFieldItem
type KeyFieldItem struct {
	Name string `tdr_field:"Name"`

	Type byte `tdr_field:"Type"`

	Length uint32 `tdr_field:"Length"`

	DistFactor byte `tdr_field:"DistFactor"`

	Index byte `tdr_field:"Index"`

	Desc string `tdr_field:"Desc"`
}

func NewKeyFieldItem() *KeyFieldItem {
	obj := new(KeyFieldItem)
	obj.Init()
	return obj
}

func (this *KeyFieldItem) GetBaseVersion() uint32 {
	return KeyFieldItemBaseVersion
}

func (this *KeyFieldItem) GetCurrentVersion() uint32 {
	return KeyFieldItemCurrentVersion
}

func (this *KeyFieldItem) Init() {

	this.Length = 0

}

func (this *KeyFieldItem) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("KeyFieldItem Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *KeyFieldItem) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > KeyFieldItemCurrentVersion {
		cutVer = KeyFieldItemCurrentVersion
	}
	// check cut version
	if cutVer < KeyFieldItemBaseVersion {
		return errors.New("KeyFieldItem cut version must large than KeyFieldItemBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("KeyFieldItem.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("KeyFieldItem.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type)
	if err != nil {
		return errors.New("KeyFieldItem.Type pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Length)
	if err != nil {
		return errors.New("KeyFieldItem.Length pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.DistFactor)
	if err != nil {
		return errors.New("KeyFieldItem.DistFactor pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Index)
	if err != nil {
		return errors.New("KeyFieldItem.Index pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Desc))+1)
	if err != nil {
		return errors.New("KeyFieldItem.Desc string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Desc), 0))
	if err != nil {
		return errors.New("KeyFieldItem.Desc string content pack error\n" + err.Error())
	}

	return nil
}

func (this *KeyFieldItem) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("KeyFieldItem data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *KeyFieldItem) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > KeyFieldItemCurrentVersion {
		cutVer = KeyFieldItemCurrentVersion
	}
	// check version
	if cutVer < KeyFieldItemBaseVersion {
		errors.New("KeyFieldItem cut version must large than KeyFieldItemBaseVersion\n")
	}

	var NameSize uint32
	err = binary.Read(r, binary.BigEndian, &NameSize)
	if err != nil {
		return errors.New("KeyFieldItem.Name string size unpack error\n" + err.Error())
	}

	NameBytes := make([]byte, NameSize)
	err = binary.Read(r, binary.BigEndian, NameBytes)
	if err != nil {
		return errors.New("KeyFieldItem.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(NameBytes[:len(NameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type)
	if err != nil {
		return errors.New("KeyFieldItem.Type unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Length)
	if err != nil {
		return errors.New("KeyFieldItem.Length unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.DistFactor)
	if err != nil {
		return errors.New("KeyFieldItem.DistFactor unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Index)
	if err != nil {
		return errors.New("KeyFieldItem.Index unpack error\n" + err.Error())
	}

	var DescSize uint32
	err = binary.Read(r, binary.BigEndian, &DescSize)
	if err != nil {
		return errors.New("KeyFieldItem.Desc string size unpack error\n" + err.Error())
	}

	DescBytes := make([]byte, DescSize)
	err = binary.Read(r, binary.BigEndian, DescBytes)
	if err != nil {
		return errors.New("KeyFieldItem.Desc string content unpack error\n" + err.Error())
	}
	this.Desc = string(DescBytes[:len(DescBytes)-1])

	return err
}

const (
	ValueFieldItemBaseVersion    uint32 = 1
	ValueFieldItemCurrentVersion uint32 = 1
)

// ValueFieldItem
type ValueFieldItem struct {
	Name string `tdr_field:"Name"`

	Type byte `tdr_field:"Type"`

	Length uint32 `tdr_field:"Length"`

	DefaultValue string `tdr_field:"DefaultValue"`

	Desc string `tdr_field:"Desc"`
}

func NewValueFieldItem() *ValueFieldItem {
	obj := new(ValueFieldItem)
	obj.Init()
	return obj
}

func (this *ValueFieldItem) GetBaseVersion() uint32 {
	return ValueFieldItemBaseVersion
}

func (this *ValueFieldItem) GetCurrentVersion() uint32 {
	return ValueFieldItemCurrentVersion
}

func (this *ValueFieldItem) Init() {

	this.Length = 0

}

func (this *ValueFieldItem) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ValueFieldItem Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ValueFieldItem) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ValueFieldItemCurrentVersion {
		cutVer = ValueFieldItemCurrentVersion
	}
	// check cut version
	if cutVer < ValueFieldItemBaseVersion {
		return errors.New("ValueFieldItem cut version must large than ValueFieldItemBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("ValueFieldItem.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("ValueFieldItem.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type)
	if err != nil {
		return errors.New("ValueFieldItem.Type pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Length)
	if err != nil {
		return errors.New("ValueFieldItem.Length pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.DefaultValue))+1)
	if err != nil {
		return errors.New("ValueFieldItem.DefaultValue string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.DefaultValue), 0))
	if err != nil {
		return errors.New("ValueFieldItem.DefaultValue string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Desc))+1)
	if err != nil {
		return errors.New("ValueFieldItem.Desc string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Desc), 0))
	if err != nil {
		return errors.New("ValueFieldItem.Desc string content pack error\n" + err.Error())
	}

	return nil
}

func (this *ValueFieldItem) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ValueFieldItem data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ValueFieldItem) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ValueFieldItemCurrentVersion {
		cutVer = ValueFieldItemCurrentVersion
	}
	// check version
	if cutVer < ValueFieldItemBaseVersion {
		errors.New("ValueFieldItem cut version must large than ValueFieldItemBaseVersion\n")
	}

	var NameSize uint32
	err = binary.Read(r, binary.BigEndian, &NameSize)
	if err != nil {
		return errors.New("ValueFieldItem.Name string size unpack error\n" + err.Error())
	}

	NameBytes := make([]byte, NameSize)
	err = binary.Read(r, binary.BigEndian, NameBytes)
	if err != nil {
		return errors.New("ValueFieldItem.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(NameBytes[:len(NameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type)
	if err != nil {
		return errors.New("ValueFieldItem.Type unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Length)
	if err != nil {
		return errors.New("ValueFieldItem.Length unpack error\n" + err.Error())
	}

	var DefaultValueSize uint32
	err = binary.Read(r, binary.BigEndian, &DefaultValueSize)
	if err != nil {
		return errors.New("ValueFieldItem.DefaultValue string size unpack error\n" + err.Error())
	}

	DefaultValueBytes := make([]byte, DefaultValueSize)
	err = binary.Read(r, binary.BigEndian, DefaultValueBytes)
	if err != nil {
		return errors.New("ValueFieldItem.DefaultValue string content unpack error\n" + err.Error())
	}
	this.DefaultValue = string(DefaultValueBytes[:len(DefaultValueBytes)-1])

	var DescSize uint32
	err = binary.Read(r, binary.BigEndian, &DescSize)
	if err != nil {
		return errors.New("ValueFieldItem.Desc string size unpack error\n" + err.Error())
	}

	DescBytes := make([]byte, DescSize)
	err = binary.Read(r, binary.BigEndian, DescBytes)
	if err != nil {
		return errors.New("ValueFieldItem.Desc string content unpack error\n" + err.Error())
	}
	this.Desc = string(DescBytes[:len(DescBytes)-1])

	return err
}

const (
	DynamicAddTableReqBaseVersion    uint32 = 4
	DynamicAddTableReqCurrentVersion uint32 = 4
)

// DynamicAddTableReq
type DynamicAddTableReq struct {
	TableName string `tdr_field:"TableName"`

	TaskID int32 `tdr_field:"TaskID"`

	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	Volume uint32 `tdr_field:"Volume"`

	AvgKeySize uint32 `tdr_field:"AvgKeySize"`

	AvgValueSize uint32 `tdr_field:"AvgValueSize"`

	ReadLoad uint32 `tdr_field:"ReadLoad"`

	WriteLoad uint32 `tdr_field:"WriteLoad"`

	Compress byte `tdr_field:"Compress"`

	EnginePara string `tdr_field:"EnginePara"`

	DMRatio byte `tdr_field:"DMRatio"`

	Memo string `tdr_field:"Memo"`

	KeyFieldNum uint32 `tdr_field:"KeyFieldNum"`

	KeyFields []*KeyFieldItem `tdr_field:"KeyFields" tdr_count:"8" tdr_refer:"KeyFieldNum"`

	ValueFieldNum uint32 `tdr_field:"ValueFieldNum"`

	ValueFields []*ValueFieldItem `tdr_field:"ValueFields" tdr_count:"256" tdr_refer:"ValueFieldNum"`
}

func NewDynamicAddTableReq() *DynamicAddTableReq {
	obj := new(DynamicAddTableReq)
	obj.Init()
	return obj
}

func (this *DynamicAddTableReq) GetBaseVersion() uint32 {
	return DynamicAddTableReqBaseVersion
}

func (this *DynamicAddTableReq) GetCurrentVersion() uint32 {
	return DynamicAddTableReqCurrentVersion
}

func (this *DynamicAddTableReq) Init() {

	this.Volume = 0

	this.KeyFieldNum = 0

	this.ValueFieldNum = 0

}

func (this *DynamicAddTableReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DynamicAddTableReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DynamicAddTableReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DynamicAddTableReqCurrentVersion {
		cutVer = DynamicAddTableReqCurrentVersion
	}
	// check cut version
	if cutVer < DynamicAddTableReqBaseVersion {
		return errors.New("DynamicAddTableReq cut version must large than DynamicAddTableReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("DynamicAddTableReq.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("DynamicAddTableReq.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TaskID)
	if err != nil {
		return errors.New("DynamicAddTableReq.TaskID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("DynamicAddTableReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("DynamicAddTableReq.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Volume)
	if err != nil {
		return errors.New("DynamicAddTableReq.Volume pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AvgKeySize)
	if err != nil {
		return errors.New("DynamicAddTableReq.AvgKeySize pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AvgValueSize)
	if err != nil {
		return errors.New("DynamicAddTableReq.AvgValueSize pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ReadLoad)
	if err != nil {
		return errors.New("DynamicAddTableReq.ReadLoad pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.WriteLoad)
	if err != nil {
		return errors.New("DynamicAddTableReq.WriteLoad pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Compress)
	if err != nil {
		return errors.New("DynamicAddTableReq.Compress pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.EnginePara))+1)
	if err != nil {
		return errors.New("DynamicAddTableReq.EnginePara string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.EnginePara), 0))
	if err != nil {
		return errors.New("DynamicAddTableReq.EnginePara string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.DMRatio)
	if err != nil {
		return errors.New("DynamicAddTableReq.DMRatio pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Memo))+1)
	if err != nil {
		return errors.New("DynamicAddTableReq.Memo string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Memo), 0))
	if err != nil {
		return errors.New("DynamicAddTableReq.Memo string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.KeyFieldNum)
	if err != nil {
		return errors.New("DynamicAddTableReq.KeyFieldNum pack error\n" + err.Error())
	}

	if this.KeyFieldNum < 0 {
		return errors.New("DynamicAddTableReq.KeyFields's refer KeyFieldNum should >= 0")
	}
	if this.KeyFieldNum > 8 {
		return errors.New("DynamicAddTableReq.KeyFields's refer KeyFieldNum should <= count 8")
	}
	if len(this.KeyFields) < int(this.KeyFieldNum) {
		return errors.New("DynamicAddTableReq.KeyFields's length should > KeyFieldNum")
	}
	if this.KeyFieldNum > 0 {
		for i := 0; i < int(this.KeyFieldNum); i++ {
			err = this.KeyFields[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("DynamicAddTableReq.KeyFields pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.ValueFieldNum)
	if err != nil {
		return errors.New("DynamicAddTableReq.ValueFieldNum pack error\n" + err.Error())
	}

	if this.ValueFieldNum < 0 {
		return errors.New("DynamicAddTableReq.ValueFields's refer ValueFieldNum should >= 0")
	}
	if this.ValueFieldNum > 256 {
		return errors.New("DynamicAddTableReq.ValueFields's refer ValueFieldNum should <= count 256")
	}
	if len(this.ValueFields) < int(this.ValueFieldNum) {
		return errors.New("DynamicAddTableReq.ValueFields's length should > ValueFieldNum")
	}
	if this.ValueFieldNum > 0 {
		for i := 0; i < int(this.ValueFieldNum); i++ {
			err = this.ValueFields[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("DynamicAddTableReq.ValueFields pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *DynamicAddTableReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DynamicAddTableReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DynamicAddTableReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DynamicAddTableReqCurrentVersion {
		cutVer = DynamicAddTableReqCurrentVersion
	}
	// check version
	if cutVer < DynamicAddTableReqBaseVersion {
		errors.New("DynamicAddTableReq cut version must large than DynamicAddTableReqBaseVersion\n")
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("DynamicAddTableReq.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("DynamicAddTableReq.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.TaskID)
	if err != nil {
		return errors.New("DynamicAddTableReq.TaskID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("DynamicAddTableReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("DynamicAddTableReq.ZoneID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Volume)
	if err != nil {
		return errors.New("DynamicAddTableReq.Volume unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AvgKeySize)
	if err != nil {
		return errors.New("DynamicAddTableReq.AvgKeySize unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AvgValueSize)
	if err != nil {
		return errors.New("DynamicAddTableReq.AvgValueSize unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ReadLoad)
	if err != nil {
		return errors.New("DynamicAddTableReq.ReadLoad unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.WriteLoad)
	if err != nil {
		return errors.New("DynamicAddTableReq.WriteLoad unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Compress)
	if err != nil {
		return errors.New("DynamicAddTableReq.Compress unpack error\n" + err.Error())
	}

	var EngineParaSize uint32
	err = binary.Read(r, binary.BigEndian, &EngineParaSize)
	if err != nil {
		return errors.New("DynamicAddTableReq.EnginePara string size unpack error\n" + err.Error())
	}

	EngineParaBytes := make([]byte, EngineParaSize)
	err = binary.Read(r, binary.BigEndian, EngineParaBytes)
	if err != nil {
		return errors.New("DynamicAddTableReq.EnginePara string content unpack error\n" + err.Error())
	}
	this.EnginePara = string(EngineParaBytes[:len(EngineParaBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.DMRatio)
	if err != nil {
		return errors.New("DynamicAddTableReq.DMRatio unpack error\n" + err.Error())
	}

	var MemoSize uint32
	err = binary.Read(r, binary.BigEndian, &MemoSize)
	if err != nil {
		return errors.New("DynamicAddTableReq.Memo string size unpack error\n" + err.Error())
	}

	MemoBytes := make([]byte, MemoSize)
	err = binary.Read(r, binary.BigEndian, MemoBytes)
	if err != nil {
		return errors.New("DynamicAddTableReq.Memo string content unpack error\n" + err.Error())
	}
	this.Memo = string(MemoBytes[:len(MemoBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.KeyFieldNum)
	if err != nil {
		return errors.New("DynamicAddTableReq.KeyFieldNum unpack error\n" + err.Error())
	}

	if this.KeyFieldNum < 0 {
		return errors.New("DynamicAddTableReq.KeyFields's refer KeyFieldNum should >= 0")
	}
	if this.KeyFieldNum > 8 {
		return errors.New("DynamicAddTableReq.KeyFields's refer KeyFieldNum should <= count 8")
	}

	if this.KeyFields == nil {
		this.KeyFields = make([]*KeyFieldItem, int(this.KeyFieldNum))
		for i := 0; i < int(this.KeyFieldNum); i++ {
			this.KeyFields[i] = NewKeyFieldItem()
		}
	}

	for i := 0; i < int(this.KeyFieldNum); i++ {
		err = this.KeyFields[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("DynamicAddTableReq.KeyFields unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.ValueFieldNum)
	if err != nil {
		return errors.New("DynamicAddTableReq.ValueFieldNum unpack error\n" + err.Error())
	}

	if this.ValueFieldNum < 0 {
		return errors.New("DynamicAddTableReq.ValueFields's refer ValueFieldNum should >= 0")
	}
	if this.ValueFieldNum > 256 {
		return errors.New("DynamicAddTableReq.ValueFields's refer ValueFieldNum should <= count 256")
	}

	if this.ValueFields == nil {
		this.ValueFields = make([]*ValueFieldItem, int(this.ValueFieldNum))
		for i := 0; i < int(this.ValueFieldNum); i++ {
			this.ValueFields[i] = NewValueFieldItem()
		}
	}

	for i := 0; i < int(this.ValueFieldNum); i++ {
		err = this.ValueFields[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("DynamicAddTableReq.ValueFields unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	DynamicAddTableResBaseVersion    uint32 = 4
	DynamicAddTableResCurrentVersion uint32 = 4
)

// DynamicAddTableRes
type DynamicAddTableRes struct {
	TableName string `tdr_field:"TableName"`

	TaskID int32 `tdr_field:"TaskID"`

	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	Result int32 `tdr_field:"Result"`

	Errmsg string `tdr_field:"Errmsg"`
}

func NewDynamicAddTableRes() *DynamicAddTableRes {
	obj := new(DynamicAddTableRes)
	obj.Init()
	return obj
}

func (this *DynamicAddTableRes) GetBaseVersion() uint32 {
	return DynamicAddTableResBaseVersion
}

func (this *DynamicAddTableRes) GetCurrentVersion() uint32 {
	return DynamicAddTableResCurrentVersion
}

func (this *DynamicAddTableRes) Init() {

}

func (this *DynamicAddTableRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DynamicAddTableRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DynamicAddTableRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DynamicAddTableResCurrentVersion {
		cutVer = DynamicAddTableResCurrentVersion
	}
	// check cut version
	if cutVer < DynamicAddTableResBaseVersion {
		return errors.New("DynamicAddTableRes cut version must large than DynamicAddTableResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("DynamicAddTableRes.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("DynamicAddTableRes.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TaskID)
	if err != nil {
		return errors.New("DynamicAddTableRes.TaskID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("DynamicAddTableRes.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("DynamicAddTableRes.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("DynamicAddTableRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Errmsg))+1)
	if err != nil {
		return errors.New("DynamicAddTableRes.Errmsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Errmsg), 0))
	if err != nil {
		return errors.New("DynamicAddTableRes.Errmsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *DynamicAddTableRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DynamicAddTableRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DynamicAddTableRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DynamicAddTableResCurrentVersion {
		cutVer = DynamicAddTableResCurrentVersion
	}
	// check version
	if cutVer < DynamicAddTableResBaseVersion {
		errors.New("DynamicAddTableRes cut version must large than DynamicAddTableResBaseVersion\n")
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("DynamicAddTableRes.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("DynamicAddTableRes.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.TaskID)
	if err != nil {
		return errors.New("DynamicAddTableRes.TaskID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("DynamicAddTableRes.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("DynamicAddTableRes.ZoneID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("DynamicAddTableRes.Result unpack error\n" + err.Error())
	}

	var ErrmsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrmsgSize)
	if err != nil {
		return errors.New("DynamicAddTableRes.Errmsg string size unpack error\n" + err.Error())
	}

	ErrmsgBytes := make([]byte, ErrmsgSize)
	err = binary.Read(r, binary.BigEndian, ErrmsgBytes)
	if err != nil {
		return errors.New("DynamicAddTableRes.Errmsg string content unpack error\n" + err.Error())
	}
	this.Errmsg = string(ErrmsgBytes[:len(ErrmsgBytes)-1])

	return err
}

const (
	DynamicDeleteTableReqBaseVersion    uint32 = 4
	DynamicDeleteTableReqCurrentVersion uint32 = 4
)

// DynamicDeleteTableReq
type DynamicDeleteTableReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`
}

func NewDynamicDeleteTableReq() *DynamicDeleteTableReq {
	obj := new(DynamicDeleteTableReq)
	obj.Init()
	return obj
}

func (this *DynamicDeleteTableReq) GetBaseVersion() uint32 {
	return DynamicDeleteTableReqBaseVersion
}

func (this *DynamicDeleteTableReq) GetCurrentVersion() uint32 {
	return DynamicDeleteTableReqCurrentVersion
}

func (this *DynamicDeleteTableReq) Init() {

}

func (this *DynamicDeleteTableReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DynamicDeleteTableReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DynamicDeleteTableReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DynamicDeleteTableReqCurrentVersion {
		cutVer = DynamicDeleteTableReqCurrentVersion
	}
	// check cut version
	if cutVer < DynamicDeleteTableReqBaseVersion {
		return errors.New("DynamicDeleteTableReq cut version must large than DynamicDeleteTableReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("DynamicDeleteTableReq.TableName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *DynamicDeleteTableReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DynamicDeleteTableReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DynamicDeleteTableReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DynamicDeleteTableReqCurrentVersion {
		cutVer = DynamicDeleteTableReqCurrentVersion
	}
	// check version
	if cutVer < DynamicDeleteTableReqBaseVersion {
		errors.New("DynamicDeleteTableReq cut version must large than DynamicDeleteTableReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("DynamicDeleteTableReq.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	return err
}

const (
	DynamicDeleteTableResBaseVersion    uint32 = 4
	DynamicDeleteTableResCurrentVersion uint32 = 4
)

// DynamicDeleteTableRes
type DynamicDeleteTableRes struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`

	Result int32 `tdr_field:"Result"`

	Errmsg string `tdr_field:"Errmsg"`
}

func NewDynamicDeleteTableRes() *DynamicDeleteTableRes {
	obj := new(DynamicDeleteTableRes)
	obj.Init()
	return obj
}

func (this *DynamicDeleteTableRes) GetBaseVersion() uint32 {
	return DynamicDeleteTableResBaseVersion
}

func (this *DynamicDeleteTableRes) GetCurrentVersion() uint32 {
	return DynamicDeleteTableResCurrentVersion
}

func (this *DynamicDeleteTableRes) Init() {

}

func (this *DynamicDeleteTableRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DynamicDeleteTableRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DynamicDeleteTableRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DynamicDeleteTableResCurrentVersion {
		cutVer = DynamicDeleteTableResCurrentVersion
	}
	// check cut version
	if cutVer < DynamicDeleteTableResBaseVersion {
		return errors.New("DynamicDeleteTableRes cut version must large than DynamicDeleteTableResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("DynamicDeleteTableRes.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Errmsg))+1)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.Errmsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Errmsg), 0))
	if err != nil {
		return errors.New("DynamicDeleteTableRes.Errmsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *DynamicDeleteTableRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DynamicDeleteTableRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DynamicDeleteTableRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DynamicDeleteTableResCurrentVersion {
		cutVer = DynamicDeleteTableResCurrentVersion
	}
	// check version
	if cutVer < DynamicDeleteTableResBaseVersion {
		errors.New("DynamicDeleteTableRes cut version must large than DynamicDeleteTableResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.Result unpack error\n" + err.Error())
	}

	var ErrmsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrmsgSize)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.Errmsg string size unpack error\n" + err.Error())
	}

	ErrmsgBytes := make([]byte, ErrmsgSize)
	err = binary.Read(r, binary.BigEndian, ErrmsgBytes)
	if err != nil {
		return errors.New("DynamicDeleteTableRes.Errmsg string content unpack error\n" + err.Error())
	}
	this.Errmsg = string(ErrmsgBytes[:len(ErrmsgBytes)-1])

	return err
}

const (
	GetConfDataReqBaseVersion    uint32 = 5
	GetConfDataReqCurrentVersion uint32 = 5
)

// GetConfDataReq
type GetConfDataReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`
}

func NewGetConfDataReq() *GetConfDataReq {
	obj := new(GetConfDataReq)
	obj.Init()
	return obj
}

func (this *GetConfDataReq) GetBaseVersion() uint32 {
	return GetConfDataReqBaseVersion
}

func (this *GetConfDataReq) GetCurrentVersion() uint32 {
	return GetConfDataReqCurrentVersion
}

func (this *GetConfDataReq) Init() {

}

func (this *GetConfDataReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("GetConfDataReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *GetConfDataReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > GetConfDataReqCurrentVersion {
		cutVer = GetConfDataReqCurrentVersion
	}
	// check cut version
	if cutVer < GetConfDataReqBaseVersion {
		return errors.New("GetConfDataReq cut version must large than GetConfDataReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("GetConfDataReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("GetConfDataReq.ZoneID pack error\n" + err.Error())
	}

	return nil
}

func (this *GetConfDataReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("GetConfDataReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *GetConfDataReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > GetConfDataReqCurrentVersion {
		cutVer = GetConfDataReqCurrentVersion
	}
	// check version
	if cutVer < GetConfDataReqBaseVersion {
		errors.New("GetConfDataReq cut version must large than GetConfDataReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("GetConfDataReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("GetConfDataReq.ZoneID unpack error\n" + err.Error())
	}

	return err
}

const (
	GetConfDataResBaseVersion    uint32 = 5
	GetConfDataResCurrentVersion uint32 = 103
)

// GetConfDataRes
type GetConfDataRes struct {
	Result int32 `tdr_field:"Result"`

	Errmsg string `tdr_field:"Errmsg"`

	ConfData *ConfData `tdr_field:"ConfData"`
}

func NewGetConfDataRes() *GetConfDataRes {
	obj := new(GetConfDataRes)
	obj.Init()
	return obj
}

func (this *GetConfDataRes) GetBaseVersion() uint32 {
	return GetConfDataResBaseVersion
}

func (this *GetConfDataRes) GetCurrentVersion() uint32 {
	return GetConfDataResCurrentVersion
}

func (this *GetConfDataRes) Init() {

	this.ConfData = NewConfData()

}

func (this *GetConfDataRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("GetConfDataRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *GetConfDataRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > GetConfDataResCurrentVersion {
		cutVer = GetConfDataResCurrentVersion
	}
	// check cut version
	if cutVer < GetConfDataResBaseVersion {
		return errors.New("GetConfDataRes cut version must large than GetConfDataResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("GetConfDataRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Errmsg))+1)
	if err != nil {
		return errors.New("GetConfDataRes.Errmsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Errmsg), 0))
	if err != nil {
		return errors.New("GetConfDataRes.Errmsg string content pack error\n" + err.Error())
	}

	err = this.ConfData.PackTo(cutVer, w)
	if err != nil {
		return errors.New("GetConfDataRes.ConfData pack error\n" + err.Error())
	}

	return nil
}

func (this *GetConfDataRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("GetConfDataRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *GetConfDataRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > GetConfDataResCurrentVersion {
		cutVer = GetConfDataResCurrentVersion
	}
	// check version
	if cutVer < GetConfDataResBaseVersion {
		errors.New("GetConfDataRes cut version must large than GetConfDataResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("GetConfDataRes.Result unpack error\n" + err.Error())
	}

	var ErrmsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrmsgSize)
	if err != nil {
		return errors.New("GetConfDataRes.Errmsg string size unpack error\n" + err.Error())
	}

	ErrmsgBytes := make([]byte, ErrmsgSize)
	err = binary.Read(r, binary.BigEndian, ErrmsgBytes)
	if err != nil {
		return errors.New("GetConfDataRes.Errmsg string content unpack error\n" + err.Error())
	}
	this.Errmsg = string(ErrmsgBytes[:len(ErrmsgBytes)-1])

	err = this.ConfData.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("GetConfDataRes.ConfData unpack error\n" + err.Error())
	}

	return err
}

const (
	DynamicCleanTableReqBaseVersion    uint32 = 52
	DynamicCleanTableReqCurrentVersion uint32 = 52
)

// DynamicCleanTableReq
type DynamicCleanTableReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`
}

func NewDynamicCleanTableReq() *DynamicCleanTableReq {
	obj := new(DynamicCleanTableReq)
	obj.Init()
	return obj
}

func (this *DynamicCleanTableReq) GetBaseVersion() uint32 {
	return DynamicCleanTableReqBaseVersion
}

func (this *DynamicCleanTableReq) GetCurrentVersion() uint32 {
	return DynamicCleanTableReqCurrentVersion
}

func (this *DynamicCleanTableReq) Init() {

}

func (this *DynamicCleanTableReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DynamicCleanTableReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DynamicCleanTableReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DynamicCleanTableReqCurrentVersion {
		cutVer = DynamicCleanTableReqCurrentVersion
	}
	// check cut version
	if cutVer < DynamicCleanTableReqBaseVersion {
		return errors.New("DynamicCleanTableReq cut version must large than DynamicCleanTableReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("DynamicCleanTableReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("DynamicCleanTableReq.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("DynamicCleanTableReq.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("DynamicCleanTableReq.TableName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *DynamicCleanTableReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DynamicCleanTableReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DynamicCleanTableReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DynamicCleanTableReqCurrentVersion {
		cutVer = DynamicCleanTableReqCurrentVersion
	}
	// check version
	if cutVer < DynamicCleanTableReqBaseVersion {
		errors.New("DynamicCleanTableReq cut version must large than DynamicCleanTableReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("DynamicCleanTableReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("DynamicCleanTableReq.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("DynamicCleanTableReq.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("DynamicCleanTableReq.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	return err
}

const (
	DynamicCleanTableResBaseVersion    uint32 = 52
	DynamicCleanTableResCurrentVersion uint32 = 52
)

// DynamicCleanTableRes
type DynamicCleanTableRes struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`

	Result int32 `tdr_field:"Result"`

	Errmsg string `tdr_field:"Errmsg"`
}

func NewDynamicCleanTableRes() *DynamicCleanTableRes {
	obj := new(DynamicCleanTableRes)
	obj.Init()
	return obj
}

func (this *DynamicCleanTableRes) GetBaseVersion() uint32 {
	return DynamicCleanTableResBaseVersion
}

func (this *DynamicCleanTableRes) GetCurrentVersion() uint32 {
	return DynamicCleanTableResCurrentVersion
}

func (this *DynamicCleanTableRes) Init() {

}

func (this *DynamicCleanTableRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DynamicCleanTableRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DynamicCleanTableRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DynamicCleanTableResCurrentVersion {
		cutVer = DynamicCleanTableResCurrentVersion
	}
	// check cut version
	if cutVer < DynamicCleanTableResBaseVersion {
		return errors.New("DynamicCleanTableRes cut version must large than DynamicCleanTableResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("DynamicCleanTableRes.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("DynamicCleanTableRes.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("DynamicCleanTableRes.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("DynamicCleanTableRes.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("DynamicCleanTableRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Errmsg))+1)
	if err != nil {
		return errors.New("DynamicCleanTableRes.Errmsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Errmsg), 0))
	if err != nil {
		return errors.New("DynamicCleanTableRes.Errmsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *DynamicCleanTableRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DynamicCleanTableRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DynamicCleanTableRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DynamicCleanTableResCurrentVersion {
		cutVer = DynamicCleanTableResCurrentVersion
	}
	// check version
	if cutVer < DynamicCleanTableResBaseVersion {
		errors.New("DynamicCleanTableRes cut version must large than DynamicCleanTableResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("DynamicCleanTableRes.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("DynamicCleanTableRes.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("DynamicCleanTableRes.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("DynamicCleanTableRes.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("DynamicCleanTableRes.Result unpack error\n" + err.Error())
	}

	var ErrmsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrmsgSize)
	if err != nil {
		return errors.New("DynamicCleanTableRes.Errmsg string size unpack error\n" + err.Error())
	}

	ErrmsgBytes := make([]byte, ErrmsgSize)
	err = binary.Read(r, binary.BigEndian, ErrmsgBytes)
	if err != nil {
		return errors.New("DynamicCleanTableRes.Errmsg string content unpack error\n" + err.Error())
	}
	this.Errmsg = string(ErrmsgBytes[:len(ErrmsgBytes)-1])

	return err
}

const (
	GetDistributeIndexInfoReqBaseVersion    uint32 = 117
	GetDistributeIndexInfoReqCurrentVersion uint32 = 117
)

// GetDistributeIndexInfoReq
type GetDistributeIndexInfoReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`
}

func NewGetDistributeIndexInfoReq() *GetDistributeIndexInfoReq {
	obj := new(GetDistributeIndexInfoReq)
	obj.Init()
	return obj
}

func (this *GetDistributeIndexInfoReq) GetBaseVersion() uint32 {
	return GetDistributeIndexInfoReqBaseVersion
}

func (this *GetDistributeIndexInfoReq) GetCurrentVersion() uint32 {
	return GetDistributeIndexInfoReqCurrentVersion
}

func (this *GetDistributeIndexInfoReq) Init() {

}

func (this *GetDistributeIndexInfoReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("GetDistributeIndexInfoReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *GetDistributeIndexInfoReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > GetDistributeIndexInfoReqCurrentVersion {
		cutVer = GetDistributeIndexInfoReqCurrentVersion
	}
	// check cut version
	if cutVer < GetDistributeIndexInfoReqBaseVersion {
		return errors.New("GetDistributeIndexInfoReq cut version must large than GetDistributeIndexInfoReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.TableName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *GetDistributeIndexInfoReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("GetDistributeIndexInfoReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *GetDistributeIndexInfoReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > GetDistributeIndexInfoReqCurrentVersion {
		cutVer = GetDistributeIndexInfoReqCurrentVersion
	}
	// check version
	if cutVer < GetDistributeIndexInfoReqBaseVersion {
		errors.New("GetDistributeIndexInfoReq cut version must large than GetDistributeIndexInfoReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("GetDistributeIndexInfoReq.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	return err
}

const (
	GetDistributeIndexInfoResBaseVersion    uint32 = 117
	GetDistributeIndexInfoResCurrentVersion uint32 = 117
)

// GetDistributeIndexInfoRes
type GetDistributeIndexInfoRes struct {
	Result int32 `tdr_field:"Result"`

	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`

	DistributeIndexFieldList string `tdr_field:"DistributeIndexFieldList"`
}

func NewGetDistributeIndexInfoRes() *GetDistributeIndexInfoRes {
	obj := new(GetDistributeIndexInfoRes)
	obj.Init()
	return obj
}

func (this *GetDistributeIndexInfoRes) GetBaseVersion() uint32 {
	return GetDistributeIndexInfoResBaseVersion
}

func (this *GetDistributeIndexInfoRes) GetCurrentVersion() uint32 {
	return GetDistributeIndexInfoResCurrentVersion
}

func (this *GetDistributeIndexInfoRes) Init() {

}

func (this *GetDistributeIndexInfoRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("GetDistributeIndexInfoRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *GetDistributeIndexInfoRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > GetDistributeIndexInfoResCurrentVersion {
		cutVer = GetDistributeIndexInfoResCurrentVersion
	}
	// check cut version
	if cutVer < GetDistributeIndexInfoResBaseVersion {
		return errors.New("GetDistributeIndexInfoRes cut version must large than GetDistributeIndexInfoResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.DistributeIndexFieldList))+1)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.DistributeIndexFieldList string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.DistributeIndexFieldList), 0))
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.DistributeIndexFieldList string content pack error\n" + err.Error())
	}

	return nil
}

func (this *GetDistributeIndexInfoRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("GetDistributeIndexInfoRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *GetDistributeIndexInfoRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > GetDistributeIndexInfoResCurrentVersion {
		cutVer = GetDistributeIndexInfoResCurrentVersion
	}
	// check version
	if cutVer < GetDistributeIndexInfoResBaseVersion {
		errors.New("GetDistributeIndexInfoRes cut version must large than GetDistributeIndexInfoResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	var DistributeIndexFieldListSize uint32
	err = binary.Read(r, binary.BigEndian, &DistributeIndexFieldListSize)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.DistributeIndexFieldList string size unpack error\n" + err.Error())
	}

	DistributeIndexFieldListBytes := make([]byte, DistributeIndexFieldListSize)
	err = binary.Read(r, binary.BigEndian, DistributeIndexFieldListBytes)
	if err != nil {
		return errors.New("GetDistributeIndexInfoRes.DistributeIndexFieldList string content unpack error\n" + err.Error())
	}
	this.DistributeIndexFieldList = string(DistributeIndexFieldListBytes[:len(DistributeIndexFieldListBytes)-1])

	return err
}

const (
	TcapdirCSHeadBaseVersion    uint32 = 1
	TcapdirCSHeadCurrentVersion uint32 = 1
)

// TcapdirCSHead
type TcapdirCSHead struct {
	Magic uint16 `tdr_field:"Magic"`

	Cmd uint16 `tdr_field:"Cmd"`

	Version int16 `tdr_field:"Version"`

	HeadLen int16 `tdr_field:"HeadLen"`

	BodyLen int32 `tdr_field:"BodyLen"`

	AppID uint64 `tdr_field:"AppID"`
}

func NewTcapdirCSHead() *TcapdirCSHead {
	obj := new(TcapdirCSHead)
	obj.Init()
	return obj
}

func (this *TcapdirCSHead) GetBaseVersion() uint32 {
	return TcapdirCSHeadBaseVersion
}

func (this *TcapdirCSHead) GetCurrentVersion() uint32 {
	return TcapdirCSHeadCurrentVersion
}

func (this *TcapdirCSHead) Init() {
	this.Magic = 0x9575

}

func (this *TcapdirCSHead) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TcapdirCSHead Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapdirCSHead) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapdirCSHeadCurrentVersion {
		cutVer = TcapdirCSHeadCurrentVersion
	}
	// check cut version
	if cutVer < TcapdirCSHeadBaseVersion {
		return errors.New("TcapdirCSHead cut version must large than TcapdirCSHeadBaseVersion\n")
	}

	beginPos := w.Tell()

	var err error

	err = binary.Write(w, binary.BigEndian, this.Magic)
	if err != nil {
		return errors.New("TcapdirCSHead.Magic pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Cmd)
	if err != nil {
		return errors.New("TcapdirCSHead.Cmd pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TcapdirCSHead.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.HeadLen)
	if err != nil {
		return errors.New("TcapdirCSHead.HeadLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BodyLen)
	if err != nil {
		return errors.New("TcapdirCSHead.BodyLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("TcapdirCSHead.AppID pack error\n" + err.Error())
	}

	// sizeinfo
	endPos := w.Tell()
	w.Seek(beginPos+6, io.SeekStart)
	err = binary.Write(w, binary.BigEndian, int16(endPos-beginPos))
	if err != nil {
		return errors.New("TcapdirCSHead's sizeinfo HeadLen pack error\n" + err.Error())
	}
	w.Seek(endPos, io.SeekStart)

	return nil
}

func (this *TcapdirCSHead) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TcapdirCSHead data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TcapdirCSHead) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapdirCSHeadCurrentVersion {
		cutVer = TcapdirCSHeadCurrentVersion
	}
	// check version
	if cutVer < TcapdirCSHeadBaseVersion {
		errors.New("TcapdirCSHead cut version must large than TcapdirCSHeadBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Magic)
	if err != nil {
		return errors.New("TcapdirCSHead.Magic unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Cmd)
	if err != nil {
		return errors.New("TcapdirCSHead.Cmd unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TcapdirCSHead.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.HeadLen)
	if err != nil {
		return errors.New("TcapdirCSHead.HeadLen unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BodyLen)
	if err != nil {
		return errors.New("TcapdirCSHead.BodyLen unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("TcapdirCSHead.AppID unpack error\n" + err.Error())
	}

	return err
}

const (
	TcapdirCSBodyBaseVersion                      uint32 = 1
	TcapdirCSBodyCurrentVersion                   uint32 = 117
	TcapdirCSBodyResGetDirServerListVersion       uint32 = 3
	TcapdirCSBodyReqGetTablesAndAccessVersion     uint32 = 3
	TcapdirCSBodyResGetTablesAndAccessVersion     uint32 = 3
	TcapdirCSBodyDynamicAddTableReqVersion        uint32 = 4
	TcapdirCSBodyDynamicAddTableResVersion        uint32 = 4
	TcapdirCSBodyDynamicDeleteTableReqVersion     uint32 = 4
	TcapdirCSBodyDynamicDeleteTableResVersion     uint32 = 4
	TcapdirCSBodyGetConfDataReqVersion            uint32 = 5
	TcapdirCSBodyGetConfDataResVersion            uint32 = 5
	TcapdirCSBodyDynamicCleanTableReqVersion      uint32 = 52
	TcapdirCSBodyDynamicCleanTableResVersion      uint32 = 52
	TcapdirCSBodyApiReportAccessQosReqVersion     uint32 = 110
	TcapdirCSBodyApiReportAccessQosResVersion     uint32 = 110
	TcapdirCSBodyGetDistributeIndexInfoReqVersion uint32 = 117
	TcapdirCSBodyGetDistributeIndexInfoResVersion uint32 = 117
)

// TcapdirCSBody
type TcapdirCSBody struct {
	ReqSignUpApp *ReqSignUpApp `tdr_field:"ReqSignUpApp"`

	ResSignUpApp *ResSignUpApp `tdr_field:"ResSignUpApp"`

	ReqHeartBeat *ReqHeartBeat `tdr_field:"ReqHeartBeat"`

	ResHeartBeat *ResHeartBeat `tdr_field:"ResHeartBeat"`

	ResGetDirServerList *ResGetDirServerList `tdr_field:"ResGetDirServerList"`

	ReqGetTablesAndAccess *ReqGetTablesAndAccess `tdr_field:"ReqGetTablesAndAccess"`

	ResGetTablesAndAccess *ResGetTablesAndAccess `tdr_field:"ResGetTablesAndAccess"`

	DynamicAddTableReq *DynamicAddTableReq `tdr_field:"DynamicAddTableReq"`

	DynamicAddTableRes *DynamicAddTableRes `tdr_field:"DynamicAddTableRes"`

	DynamicDeleteTableReq *DynamicDeleteTableReq `tdr_field:"DynamicDeleteTableReq"`

	DynamicDeleteTableRes *DynamicDeleteTableRes `tdr_field:"DynamicDeleteTableRes"`

	GetConfDataReq *GetConfDataReq `tdr_field:"GetConfDataReq"`

	GetConfDataRes *GetConfDataRes `tdr_field:"GetConfDataRes"`

	DynamicCleanTableReq *DynamicCleanTableReq `tdr_field:"DynamicCleanTableReq"`

	DynamicCleanTableRes *DynamicCleanTableRes `tdr_field:"DynamicCleanTableRes"`

	ApiReportAccessQosReq *ApiReportAccessQosReq `tdr_field:"ApiReportAccessQosReq"`

	ApiReportAccessQosRes *ApiReportAccessQosRes `tdr_field:"ApiReportAccessQosRes"`

	GetDistributeIndexInfoReq *GetDistributeIndexInfoReq `tdr_field:"GetDistributeIndexInfoReq"`

	GetDistributeIndexInfoRes *GetDistributeIndexInfoRes `tdr_field:"GetDistributeIndexInfoRes"`
}

func NewTcapdirCSBody(selector int64) *TcapdirCSBody {
	obj := new(TcapdirCSBody)
	obj.Init(selector)
	return obj
}

func (this *TcapdirCSBody) GetBaseVersion() uint32 {
	return TcapdirCSBodyBaseVersion
}

func (this *TcapdirCSBody) GetCurrentVersion() uint32 {
	return TcapdirCSBodyCurrentVersion
}

func (this *TcapdirCSBody) Init(selector int64) {
	switch selector {
	case TCAPDIR_CS_CMD_SIGNUP_REQ:
		this.ReqSignUpApp = NewReqSignUpApp()

	case TCAPDIR_CS_CMD_SIGNUP_RES:
		this.ResSignUpApp = NewResSignUpApp()

	case TCAPDIR_CS_CMD_HEARTBEAT_REQ:
		this.ReqHeartBeat = NewReqHeartBeat()

	case TCAPDIR_CS_CMD_HEARTBEAT_RES:
		this.ResHeartBeat = NewResHeartBeat()

	case TCAPDIR_CS_CMD_GET_DIR_SERVER_LIST_RES:
		this.ResGetDirServerList = NewResGetDirServerList()

	case TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_REQ:
		this.ReqGetTablesAndAccess = NewReqGetTablesAndAccess()

	case TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_RES:
		this.ResGetTablesAndAccess = NewResGetTablesAndAccess()

	case TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_REQ:
		this.DynamicAddTableReq = NewDynamicAddTableReq()

	case TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_RES:
		this.DynamicAddTableRes = NewDynamicAddTableRes()

	case TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_REQ:
		this.DynamicDeleteTableReq = NewDynamicDeleteTableReq()

	case TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_RES:
		this.DynamicDeleteTableRes = NewDynamicDeleteTableRes()

	case TCAPDIR_CS_CMD_GET_CONF_DATA_REQ:
		this.GetConfDataReq = NewGetConfDataReq()

	case TCAPDIR_CS_CMD_GET_CONF_DATA_RES:
		this.GetConfDataRes = NewGetConfDataRes()

	case TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_REQ:
		this.DynamicCleanTableReq = NewDynamicCleanTableReq()

	case TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_RES:
		this.DynamicCleanTableRes = NewDynamicCleanTableRes()

	case TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_REQ:
		this.ApiReportAccessQosReq = NewApiReportAccessQosReq()

	case TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_RES:
		this.ApiReportAccessQosRes = NewApiReportAccessQosRes()

	case TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_REQ:
		this.GetDistributeIndexInfoReq = NewGetDistributeIndexInfoReq()

	case TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_RES:
		this.GetDistributeIndexInfoRes = NewGetDistributeIndexInfoRes()

	}
}

func (this *TcapdirCSBody) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapdirCSBody) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapdirCSBodyCurrentVersion {
		cutVer = TcapdirCSBodyCurrentVersion
	}
	// check cut version
	if cutVer < TcapdirCSBodyBaseVersion {
		return errors.New("TcapdirCSBody cut version must large than TcapdirCSBodyBaseVersion\n")
	}

	var err error = nil
	switch selector {
	case TCAPDIR_CS_CMD_SIGNUP_REQ:
		if this.ReqSignUpApp == nil {
			return errors.New("TcapdirCSBody.ReqSignUpApp is nil")
		}

		err = this.ReqSignUpApp.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TcapdirCSBody.ReqSignUpApp pack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_SIGNUP_RES:
		if this.ResSignUpApp == nil {
			return errors.New("TcapdirCSBody.ResSignUpApp is nil")
		}

		err = this.ResSignUpApp.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TcapdirCSBody.ResSignUpApp pack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_HEARTBEAT_REQ:
		if this.ReqHeartBeat == nil {
			return errors.New("TcapdirCSBody.ReqHeartBeat is nil")
		}

		err = this.ReqHeartBeat.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TcapdirCSBody.ReqHeartBeat pack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_HEARTBEAT_RES:
		if this.ResHeartBeat == nil {
			return errors.New("TcapdirCSBody.ResHeartBeat is nil")
		}

		err = this.ResHeartBeat.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TcapdirCSBody.ResHeartBeat pack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_GET_DIR_SERVER_LIST_RES:
		if this.ResGetDirServerList == nil {
			return errors.New("TcapdirCSBody.ResGetDirServerList is nil")
		}
		if cutVer >= TcapdirCSBodyResGetDirServerListVersion {

			err = this.ResGetDirServerList.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.ResGetDirServerList pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_REQ:
		if this.ReqGetTablesAndAccess == nil {
			return errors.New("TcapdirCSBody.ReqGetTablesAndAccess is nil")
		}
		if cutVer >= TcapdirCSBodyReqGetTablesAndAccessVersion {

			err = this.ReqGetTablesAndAccess.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.ReqGetTablesAndAccess pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_RES:
		if this.ResGetTablesAndAccess == nil {
			return errors.New("TcapdirCSBody.ResGetTablesAndAccess is nil")
		}
		if cutVer >= TcapdirCSBodyResGetTablesAndAccessVersion {

			err = this.ResGetTablesAndAccess.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.ResGetTablesAndAccess pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_REQ:
		if this.DynamicAddTableReq == nil {
			return errors.New("TcapdirCSBody.DynamicAddTableReq is nil")
		}
		if cutVer >= TcapdirCSBodyDynamicAddTableReqVersion {

			err = this.DynamicAddTableReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicAddTableReq pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_RES:
		if this.DynamicAddTableRes == nil {
			return errors.New("TcapdirCSBody.DynamicAddTableRes is nil")
		}
		if cutVer >= TcapdirCSBodyDynamicAddTableResVersion {

			err = this.DynamicAddTableRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicAddTableRes pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_REQ:
		if this.DynamicDeleteTableReq == nil {
			return errors.New("TcapdirCSBody.DynamicDeleteTableReq is nil")
		}
		if cutVer >= TcapdirCSBodyDynamicDeleteTableReqVersion {

			err = this.DynamicDeleteTableReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicDeleteTableReq pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_RES:
		if this.DynamicDeleteTableRes == nil {
			return errors.New("TcapdirCSBody.DynamicDeleteTableRes is nil")
		}
		if cutVer >= TcapdirCSBodyDynamicDeleteTableResVersion {

			err = this.DynamicDeleteTableRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicDeleteTableRes pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_GET_CONF_DATA_REQ:
		if this.GetConfDataReq == nil {
			return errors.New("TcapdirCSBody.GetConfDataReq is nil")
		}
		if cutVer >= TcapdirCSBodyGetConfDataReqVersion {

			err = this.GetConfDataReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.GetConfDataReq pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_GET_CONF_DATA_RES:
		if this.GetConfDataRes == nil {
			return errors.New("TcapdirCSBody.GetConfDataRes is nil")
		}
		if cutVer >= TcapdirCSBodyGetConfDataResVersion {

			err = this.GetConfDataRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.GetConfDataRes pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_REQ:
		if this.DynamicCleanTableReq == nil {
			return errors.New("TcapdirCSBody.DynamicCleanTableReq is nil")
		}
		if cutVer >= TcapdirCSBodyDynamicCleanTableReqVersion {

			err = this.DynamicCleanTableReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicCleanTableReq pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_RES:
		if this.DynamicCleanTableRes == nil {
			return errors.New("TcapdirCSBody.DynamicCleanTableRes is nil")
		}
		if cutVer >= TcapdirCSBodyDynamicCleanTableResVersion {

			err = this.DynamicCleanTableRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicCleanTableRes pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_REQ:
		if this.ApiReportAccessQosReq == nil {
			return errors.New("TcapdirCSBody.ApiReportAccessQosReq is nil")
		}
		if cutVer >= TcapdirCSBodyApiReportAccessQosReqVersion {

			err = this.ApiReportAccessQosReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.ApiReportAccessQosReq pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_RES:
		if this.ApiReportAccessQosRes == nil {
			return errors.New("TcapdirCSBody.ApiReportAccessQosRes is nil")
		}
		if cutVer >= TcapdirCSBodyApiReportAccessQosResVersion {

			err = this.ApiReportAccessQosRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.ApiReportAccessQosRes pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_REQ:
		if this.GetDistributeIndexInfoReq == nil {
			return errors.New("TcapdirCSBody.GetDistributeIndexInfoReq is nil")
		}
		if cutVer >= TcapdirCSBodyGetDistributeIndexInfoReqVersion {

			err = this.GetDistributeIndexInfoReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.GetDistributeIndexInfoReq pack error\n" + err.Error())
			}

		}
	case TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_RES:
		if this.GetDistributeIndexInfoRes == nil {
			return errors.New("TcapdirCSBody.GetDistributeIndexInfoRes is nil")
		}
		if cutVer >= TcapdirCSBodyGetDistributeIndexInfoResVersion {

			err = this.GetDistributeIndexInfoRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdirCSBody.GetDistributeIndexInfoRes pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TcapdirCSBody) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("TcapdirCSBody data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *TcapdirCSBody) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapdirCSBodyCurrentVersion {
		cutVer = TcapdirCSBodyCurrentVersion
	}
	// check version
	if cutVer < TcapdirCSBodyBaseVersion {
		errors.New("TcapdirCSBody cut version must large than TcapdirCSBodyBaseVersion\n")
	}

	switch selector {
	case TCAPDIR_CS_CMD_SIGNUP_REQ:
		if this.ReqSignUpApp == nil {
			this.ReqSignUpApp = NewReqSignUpApp()
		}

		err = this.ReqSignUpApp.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TcapdirCSBody.ReqSignUpApp unpack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_SIGNUP_RES:
		if this.ResSignUpApp == nil {
			this.ResSignUpApp = NewResSignUpApp()
		}

		err = this.ResSignUpApp.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TcapdirCSBody.ResSignUpApp unpack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_HEARTBEAT_REQ:
		if this.ReqHeartBeat == nil {
			this.ReqHeartBeat = NewReqHeartBeat()
		}

		err = this.ReqHeartBeat.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TcapdirCSBody.ReqHeartBeat unpack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_HEARTBEAT_RES:
		if this.ResHeartBeat == nil {
			this.ResHeartBeat = NewResHeartBeat()
		}

		err = this.ResHeartBeat.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TcapdirCSBody.ResHeartBeat unpack error\n" + err.Error())
		}

	case TCAPDIR_CS_CMD_GET_DIR_SERVER_LIST_RES:
		if this.ResGetDirServerList == nil {
			this.ResGetDirServerList = NewResGetDirServerList()
		}
		if cutVer >= TcapdirCSBodyResGetDirServerListVersion {

			err = this.ResGetDirServerList.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.ResGetDirServerList unpack error\n" + err.Error())
			}

		} else {
			this.ResGetDirServerList.Init()

		}
	case TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_REQ:
		if this.ReqGetTablesAndAccess == nil {
			this.ReqGetTablesAndAccess = NewReqGetTablesAndAccess()
		}
		if cutVer >= TcapdirCSBodyReqGetTablesAndAccessVersion {

			err = this.ReqGetTablesAndAccess.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.ReqGetTablesAndAccess unpack error\n" + err.Error())
			}

		} else {
			this.ReqGetTablesAndAccess.Init()

		}
	case TCAPDIR_CS_CMD_GET_TABLES_AND_ACCESS_RES:
		if this.ResGetTablesAndAccess == nil {
			this.ResGetTablesAndAccess = NewResGetTablesAndAccess()
		}
		if cutVer >= TcapdirCSBodyResGetTablesAndAccessVersion {

			err = this.ResGetTablesAndAccess.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.ResGetTablesAndAccess unpack error\n" + err.Error())
			}

		} else {
			this.ResGetTablesAndAccess.Init()

		}
	case TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_REQ:
		if this.DynamicAddTableReq == nil {
			this.DynamicAddTableReq = NewDynamicAddTableReq()
		}
		if cutVer >= TcapdirCSBodyDynamicAddTableReqVersion {

			err = this.DynamicAddTableReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicAddTableReq unpack error\n" + err.Error())
			}

		} else {
			this.DynamicAddTableReq.Init()

		}
	case TCAPDIR_CS_CMD_DYNAMIC_ADD_TABLE_RES:
		if this.DynamicAddTableRes == nil {
			this.DynamicAddTableRes = NewDynamicAddTableRes()
		}
		if cutVer >= TcapdirCSBodyDynamicAddTableResVersion {

			err = this.DynamicAddTableRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicAddTableRes unpack error\n" + err.Error())
			}

		} else {
			this.DynamicAddTableRes.Init()

		}
	case TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_REQ:
		if this.DynamicDeleteTableReq == nil {
			this.DynamicDeleteTableReq = NewDynamicDeleteTableReq()
		}
		if cutVer >= TcapdirCSBodyDynamicDeleteTableReqVersion {

			err = this.DynamicDeleteTableReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicDeleteTableReq unpack error\n" + err.Error())
			}

		} else {
			this.DynamicDeleteTableReq.Init()

		}
	case TCAPDIR_CS_CMD_DYNAMIC_DELETE_TABLE_RES:
		if this.DynamicDeleteTableRes == nil {
			this.DynamicDeleteTableRes = NewDynamicDeleteTableRes()
		}
		if cutVer >= TcapdirCSBodyDynamicDeleteTableResVersion {

			err = this.DynamicDeleteTableRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicDeleteTableRes unpack error\n" + err.Error())
			}

		} else {
			this.DynamicDeleteTableRes.Init()

		}
	case TCAPDIR_CS_CMD_GET_CONF_DATA_REQ:
		if this.GetConfDataReq == nil {
			this.GetConfDataReq = NewGetConfDataReq()
		}
		if cutVer >= TcapdirCSBodyGetConfDataReqVersion {

			err = this.GetConfDataReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.GetConfDataReq unpack error\n" + err.Error())
			}

		} else {
			this.GetConfDataReq.Init()

		}
	case TCAPDIR_CS_CMD_GET_CONF_DATA_RES:
		if this.GetConfDataRes == nil {
			this.GetConfDataRes = NewGetConfDataRes()
		}
		if cutVer >= TcapdirCSBodyGetConfDataResVersion {

			err = this.GetConfDataRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.GetConfDataRes unpack error\n" + err.Error())
			}

		} else {
			this.GetConfDataRes.Init()

		}
	case TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_REQ:
		if this.DynamicCleanTableReq == nil {
			this.DynamicCleanTableReq = NewDynamicCleanTableReq()
		}
		if cutVer >= TcapdirCSBodyDynamicCleanTableReqVersion {

			err = this.DynamicCleanTableReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicCleanTableReq unpack error\n" + err.Error())
			}

		} else {
			this.DynamicCleanTableReq.Init()

		}
	case TCAPDIR_CS_CMD_DYNAMIC_CLEAN_TABLE_RES:
		if this.DynamicCleanTableRes == nil {
			this.DynamicCleanTableRes = NewDynamicCleanTableRes()
		}
		if cutVer >= TcapdirCSBodyDynamicCleanTableResVersion {

			err = this.DynamicCleanTableRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.DynamicCleanTableRes unpack error\n" + err.Error())
			}

		} else {
			this.DynamicCleanTableRes.Init()

		}
	case TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_REQ:
		if this.ApiReportAccessQosReq == nil {
			this.ApiReportAccessQosReq = NewApiReportAccessQosReq()
		}
		if cutVer >= TcapdirCSBodyApiReportAccessQosReqVersion {

			err = this.ApiReportAccessQosReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.ApiReportAccessQosReq unpack error\n" + err.Error())
			}

		} else {
			this.ApiReportAccessQosReq.Init()

		}
	case TCAPDIR_CS_CMD_REPORT_ACCESS_QOS_RES:
		if this.ApiReportAccessQosRes == nil {
			this.ApiReportAccessQosRes = NewApiReportAccessQosRes()
		}
		if cutVer >= TcapdirCSBodyApiReportAccessQosResVersion {

			err = this.ApiReportAccessQosRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.ApiReportAccessQosRes unpack error\n" + err.Error())
			}

		} else {
			this.ApiReportAccessQosRes.Init()

		}
	case TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_REQ:
		if this.GetDistributeIndexInfoReq == nil {
			this.GetDistributeIndexInfoReq = NewGetDistributeIndexInfoReq()
		}
		if cutVer >= TcapdirCSBodyGetDistributeIndexInfoReqVersion {

			err = this.GetDistributeIndexInfoReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.GetDistributeIndexInfoReq unpack error\n" + err.Error())
			}

		} else {
			this.GetDistributeIndexInfoReq.Init()

		}
	case TCAPDIR_CS_CMD_GET_DISTRIBUTE_INDEX_INFO_RES:
		if this.GetDistributeIndexInfoRes == nil {
			this.GetDistributeIndexInfoRes = NewGetDistributeIndexInfoRes()
		}
		if cutVer >= TcapdirCSBodyGetDistributeIndexInfoResVersion {

			err = this.GetDistributeIndexInfoRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapdirCSBody.GetDistributeIndexInfoRes unpack error\n" + err.Error())
			}

		} else {
			this.GetDistributeIndexInfoRes.Init()

		}
	}

	return err
}

const (
	TCapdirCSPkgBaseVersion    uint32 = 1
	TCapdirCSPkgCurrentVersion uint32 = 117
)

// TCapdirCSPkg
type TCapdirCSPkg struct {
	Head *TcapdirCSHead `tdr_field:"Head"`

	Body *TcapdirCSBody `tdr_field:"Body" tdr_select:"Head.Cmd"`
}

func NewTCapdirCSPkg() *TCapdirCSPkg {
	obj := new(TCapdirCSPkg)
	obj.Init()
	return obj
}

func (this *TCapdirCSPkg) GetBaseVersion() uint32 {
	return TCapdirCSPkgBaseVersion
}

func (this *TCapdirCSPkg) GetCurrentVersion() uint32 {
	return TCapdirCSPkgCurrentVersion
}

func (this *TCapdirCSPkg) Init() {
	this.Head = NewTcapdirCSHead()

	this.Body = NewTcapdirCSBody(int64(this.Head.Cmd))

}

func (this *TCapdirCSPkg) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCapdirCSPkg Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCapdirCSPkg) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCapdirCSPkgCurrentVersion {
		cutVer = TCapdirCSPkgCurrentVersion
	}
	// check cut version
	if cutVer < TCapdirCSPkgBaseVersion {
		return errors.New("TCapdirCSPkg cut version must large than TCapdirCSPkgBaseVersion\n")
	}
	// versionindicator
	this.Head.Version = int16(cutVer)

	beginPos := w.Tell()

	var err error

	err = this.Head.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCapdirCSPkg.Head pack error\n" + err.Error())
	}

	BodyBeginPos := w.Tell()

	err = this.Body.PackTo(cutVer, w, int64(this.Head.Cmd))
	if err != nil {
		return errors.New("TCapdirCSPkg.Body pack error\n" + err.Error())
	}

	BodyEndPos := w.Tell()
	w.Seek(beginPos+8, io.SeekStart)
	err = binary.Write(w, binary.BigEndian, int32(BodyEndPos-BodyBeginPos))
	if err != nil {
		return errors.New("Body's sizeinfo Head.BodyLen pack error\n" + err.Error())
	}
	w.Seek(BodyEndPos, io.SeekStart)

	return nil
}

func (this *TCapdirCSPkg) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCapdirCSPkg data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCapdirCSPkg) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// get net version
	var netVer int16
	oriPos := r.Tell()
	r.Seek(oriPos+4, io.SeekStart)
	err = binary.Read(r, binary.BigEndian, &netVer)
	if err != nil {
		return errors.New("TCapdirCSPkg get net version error\n" + err.Error())
	}
	r.Seek(oriPos, io.SeekStart)
	cutVer = uint32(netVer)
	// check version
	if cutVer < TCapdirCSPkgBaseVersion || cutVer > TCapdirCSPkgCurrentVersion {
		return errors.New("TCapdirCSPkg wrong cut version")
	}

	err = this.Head.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCapdirCSPkg.Head unpack error\n" + err.Error())
	}

	err = this.Body.UnpackFrom(cutVer, r, int64(this.Head.Cmd))
	if err != nil {
		return errors.New("TCapdirCSPkg.Body unpack error\n" + err.Error())
	}

	return err
}
