// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2020-04-29 10:52:08
package service_info

import (
	"encoding/binary"
	"errors"

	"github.com/tencentyun/tsf4g/tdrcom"
)

const (
	Service_InfoBaseVersion    uint32 = 1
	Service_InfoCurrentVersion uint32 = 1
)

var Service_InfoDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Gameid",
	PrimaryKey:    "Gameid,Envdata,Name,Expansion",
	Index2Column: map[string]string{
		"Index_Gameid_Envdata_Name": "Gameid,Envdata,Name",
		"Index_Gameid":              "Gameid",
		"Index_Gameid_Envdata":      "Gameid,Envdata",
		"Index_Gameid_Name":         "Gameid,Name",
	},
}

// Service_Info
type Service_Info struct {
	Gameid string `tdr_field:"gameid"`

	Envdata string `tdr_field:"envdata"`

	Name string `tdr_field:"name"`

	Expansion string `tdr_field:"expansion"`

	Filterdata string `tdr_field:"filterdata"`

	Updatetime uint64 `tdr_field:"updatetime"`

	Inst_Max_Num uint64 `tdr_field:"inst_max_num"`

	Inst_Min_Num uint64 `tdr_field:"inst_min_num"`

	Routeinfo_Len uint32 `tdr_field:"routeinfo_len"`

	Routeinfo []byte `tdr_field:"routeinfo" tdr_count:"1024" tdr_refer:"Routeinfo_Len"`
}

func NewService_Info() *Service_Info {
	obj := new(Service_Info)
	obj.Init()
	return obj
}

func (this *Service_Info) GetBaseVersion() uint32 {
	return Service_InfoBaseVersion
}

func (this *Service_Info) GetCurrentVersion() uint32 {
	return Service_InfoCurrentVersion
}

func (this *Service_Info) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Service_InfoDBFeilds
}

func (this *Service_Info) Init() {

	this.Routeinfo_Len = 0

}

func (this *Service_Info) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Service_Info Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Service_Info) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Service_InfoCurrentVersion {
		cutVer = Service_InfoCurrentVersion
	}
	// check cut version
	if cutVer < Service_InfoBaseVersion {
		return errors.New("Service_Info cut version must large than Service_InfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Gameid))+1)
	if err != nil {
		return errors.New("Service_Info.Gameid string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Gameid), 0))
	if err != nil {
		return errors.New("Service_Info.Gameid string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Envdata))+1)
	if err != nil {
		return errors.New("Service_Info.Envdata string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Envdata), 0))
	if err != nil {
		return errors.New("Service_Info.Envdata string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Service_Info.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Service_Info.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Expansion))+1)
	if err != nil {
		return errors.New("Service_Info.Expansion string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Expansion), 0))
	if err != nil {
		return errors.New("Service_Info.Expansion string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Filterdata))+1)
	if err != nil {
		return errors.New("Service_Info.Filterdata string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Filterdata), 0))
	if err != nil {
		return errors.New("Service_Info.Filterdata string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Updatetime)
	if err != nil {
		return errors.New("Service_Info.Updatetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Inst_Max_Num)
	if err != nil {
		return errors.New("Service_Info.Inst_Max_Num pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Inst_Min_Num)
	if err != nil {
		return errors.New("Service_Info.Inst_Min_Num pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Routeinfo_Len)
	if err != nil {
		return errors.New("Service_Info.Routeinfo_Len pack error\n" + err.Error())
	}

	if this.Routeinfo_Len < 0 {
		return errors.New("Service_Info.Routeinfo's refer Routeinfo_Len should >= 0")
	}
	if this.Routeinfo_Len > 1024 {
		return errors.New("Service_Info.Routeinfo's refer Routeinfo_Len should <= count 1024")
	}
	if len(this.Routeinfo) < int(this.Routeinfo_Len) {
		return errors.New("Service_Info.Routeinfo's length should > Routeinfo_Len")
	}
	if this.Routeinfo_Len > 0 {
		referRouteinfo := this.Routeinfo[:this.Routeinfo_Len]
		err = binary.Write(w, binary.BigEndian, referRouteinfo)
		if err != nil {
			return errors.New("Service_Info.Routeinfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Service_Info) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Service_Info data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Service_Info) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Service_InfoCurrentVersion {
		cutVer = Service_InfoCurrentVersion
	}
	// check version
	if cutVer < Service_InfoBaseVersion {
		errors.New("Service_Info cut version must large than Service_InfoBaseVersion\n")
	}

	var gameidSize uint32
	err = binary.Read(r, binary.BigEndian, &gameidSize)
	if err != nil {
		return errors.New("Service_Info.Gameid string size unpack error\n" + err.Error())
	}

	gameidBytes := make([]byte, gameidSize)
	err = binary.Read(r, binary.BigEndian, gameidBytes)
	if err != nil {
		return errors.New("Service_Info.Gameid string content unpack error\n" + err.Error())
	}
	this.Gameid = string(gameidBytes[:len(gameidBytes)-1])

	var envdataSize uint32
	err = binary.Read(r, binary.BigEndian, &envdataSize)
	if err != nil {
		return errors.New("Service_Info.Envdata string size unpack error\n" + err.Error())
	}

	envdataBytes := make([]byte, envdataSize)
	err = binary.Read(r, binary.BigEndian, envdataBytes)
	if err != nil {
		return errors.New("Service_Info.Envdata string content unpack error\n" + err.Error())
	}
	this.Envdata = string(envdataBytes[:len(envdataBytes)-1])

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Service_Info.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Service_Info.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	var expansionSize uint32
	err = binary.Read(r, binary.BigEndian, &expansionSize)
	if err != nil {
		return errors.New("Service_Info.Expansion string size unpack error\n" + err.Error())
	}

	expansionBytes := make([]byte, expansionSize)
	err = binary.Read(r, binary.BigEndian, expansionBytes)
	if err != nil {
		return errors.New("Service_Info.Expansion string content unpack error\n" + err.Error())
	}
	this.Expansion = string(expansionBytes[:len(expansionBytes)-1])

	var filterdataSize uint32
	err = binary.Read(r, binary.BigEndian, &filterdataSize)
	if err != nil {
		return errors.New("Service_Info.Filterdata string size unpack error\n" + err.Error())
	}

	filterdataBytes := make([]byte, filterdataSize)
	err = binary.Read(r, binary.BigEndian, filterdataBytes)
	if err != nil {
		return errors.New("Service_Info.Filterdata string content unpack error\n" + err.Error())
	}
	this.Filterdata = string(filterdataBytes[:len(filterdataBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Updatetime)
	if err != nil {
		return errors.New("Service_Info.Updatetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Inst_Max_Num)
	if err != nil {
		return errors.New("Service_Info.Inst_Max_Num unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Inst_Min_Num)
	if err != nil {
		return errors.New("Service_Info.Inst_Min_Num unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Routeinfo_Len)
	if err != nil {
		return errors.New("Service_Info.Routeinfo_Len unpack error\n" + err.Error())
	}

	if this.Routeinfo_Len < 0 {
		return errors.New("Service_Info.Routeinfo's refer Routeinfo_Len should >= 0")
	}
	if this.Routeinfo_Len > 1024 {
		return errors.New("Service_Info.Routeinfo's refer Routeinfo_Len should <= count 1024")
	}

	if this.Routeinfo == nil {
		this.Routeinfo = make([]byte, int(this.Routeinfo_Len))
	}

	referRouteinfo := this.Routeinfo[:this.Routeinfo_Len]
	err = binary.Read(r, binary.BigEndian, referRouteinfo)
	if err != nil {
		return errors.New("Service_Info.Routeinfo pack error\n" + err.Error())
	}

	return err
}
