// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2020-04-29 10:52:48
package tcaplus_tb

import (
	"encoding/binary"
	"errors"

	"git.code.oa.com/tsf4g/tdrcom"
)

const VALUE_1KB_SIZE int64 = 1024
const VALUE_256KB_SIZE int64 = 262144
const VALUE_1M_SIZE int64 = 1048576
const VALUE_10M_SIZE int64 = 10000000
const (
	Union_TypeBaseVersion    uint32 = 1
	Union_TypeCurrentVersion uint32 = 1
)

// Union_Type
type Union_Type struct {
	Id int32 `tdr_field:"Id"`

	Name string `tdr_field:"Name"`
}

func NewUnion_Type(selector int64) *Union_Type {
	obj := new(Union_Type)
	obj.Init(selector)
	return obj
}

func (this *Union_Type) GetBaseVersion() uint32 {
	return Union_TypeBaseVersion
}

func (this *Union_Type) GetCurrentVersion() uint32 {
	return Union_TypeCurrentVersion
}

func (this *Union_Type) Init(selector int64) {
	switch selector {
	case 0:
		this.Id = 0

	case 1:
		this.Name = "hello"

	}
}

func (this *Union_Type) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *Union_Type) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Union_TypeCurrentVersion {
		cutVer = Union_TypeCurrentVersion
	}
	// check cut version
	if cutVer < Union_TypeBaseVersion {
		return errors.New("Union_Type cut version must large than Union_TypeBaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 0:

		err = binary.Write(w, binary.BigEndian, this.Id)
		if err != nil {
			return errors.New("Union_Type.Id pack error\n" + err.Error())
		}

	case 1:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
		if err != nil {
			return errors.New("Union_Type.Name string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
		if err != nil {
			return errors.New("Union_Type.Name string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *Union_Type) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("Union_Type data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *Union_Type) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Union_TypeCurrentVersion {
		cutVer = Union_TypeCurrentVersion
	}
	// check version
	if cutVer < Union_TypeBaseVersion {
		errors.New("Union_Type cut version must large than Union_TypeBaseVersion\n")
	}

	switch selector {
	case 0:

		err = binary.Read(r, binary.BigEndian, &this.Id)
		if err != nil {
			return errors.New("Union_Type.Id unpack error\n" + err.Error())
		}

	case 1:

		var NameSize uint32
		err = binary.Read(r, binary.BigEndian, &NameSize)
		if err != nil {
			return errors.New("Union_Type.Name string size unpack error\n" + err.Error())
		}

		NameBytes := make([]byte, NameSize)
		err = binary.Read(r, binary.BigEndian, NameBytes)
		if err != nil {
			return errors.New("Union_Type.Name string content unpack error\n" + err.Error())
		}
		this.Name = string(NameBytes[:len(NameBytes)-1])

	}

	return err
}

const (
	Struct_NestedBaseVersion    uint32 = 2
	Struct_NestedCurrentVersion uint32 = 2
)

// Struct_Nested
type Struct_Nested struct {
	Uin int32 `tdr_field:"uin"`

	Name string `tdr_field:"name"`
}

func NewStruct_Nested() *Struct_Nested {
	obj := new(Struct_Nested)
	obj.Init()
	return obj
}

func (this *Struct_Nested) GetBaseVersion() uint32 {
	return Struct_NestedBaseVersion
}

func (this *Struct_Nested) GetCurrentVersion() uint32 {
	return Struct_NestedCurrentVersion
}

func (this *Struct_Nested) Init() {
	this.Uin = 0

}

func (this *Struct_Nested) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Struct_Nested Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Struct_Nested) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Struct_NestedCurrentVersion {
		cutVer = Struct_NestedCurrentVersion
	}
	// check cut version
	if cutVer < Struct_NestedBaseVersion {
		return errors.New("Struct_Nested cut version must large than Struct_NestedBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Struct_Nested.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Struct_Nested.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Struct_Nested.Name string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Struct_Nested) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Struct_Nested data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Struct_Nested) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Struct_NestedCurrentVersion {
		cutVer = Struct_NestedCurrentVersion
	}
	// check version
	if cutVer < Struct_NestedBaseVersion {
		errors.New("Struct_Nested cut version must large than Struct_NestedBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Struct_Nested.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Struct_Nested.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Struct_Nested.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	return err
}

const (
	Struct_TypeBaseVersion          uint32 = 1
	Struct_TypeCurrentVersion       uint32 = 3
	Struct_TypeScoreVersion         uint32 = 2
	Struct_TypeRankVersion          uint32 = 3
	Struct_TypeLevel2_StructVersion uint32 = 2
)

// Struct_Type
type Struct_Type struct {
	X int32 `tdr_field:"x"`

	Y int32 `tdr_field:"y"`

	Score float64 `tdr_field:"score"`

	Rank byte `tdr_field:"rank"`

	Title string `tdr_field:"title"`

	Level2_Struct *Struct_Nested `tdr_field:"level2_struct"`
}

func NewStruct_Type() *Struct_Type {
	obj := new(Struct_Type)
	obj.Init()
	return obj
}

func (this *Struct_Type) GetBaseVersion() uint32 {
	return Struct_TypeBaseVersion
}

func (this *Struct_Type) GetCurrentVersion() uint32 {
	return Struct_TypeCurrentVersion
}

func (this *Struct_Type) Init() {
	this.X = 0

	this.Y = 0

	this.Score = 1.11

	this.Rank = 1

	this.Level2_Struct = NewStruct_Nested()

}

func (this *Struct_Type) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Struct_Type Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Struct_Type) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Struct_TypeCurrentVersion {
		cutVer = Struct_TypeCurrentVersion
	}
	// check cut version
	if cutVer < Struct_TypeBaseVersion {
		return errors.New("Struct_Type cut version must large than Struct_TypeBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.X)
	if err != nil {
		return errors.New("Struct_Type.X pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Y)
	if err != nil {
		return errors.New("Struct_Type.Y pack error\n" + err.Error())
	}

	if cutVer >= Struct_TypeScoreVersion {

		err = binary.Write(w, binary.BigEndian, this.Score)
		if err != nil {
			return errors.New("Struct_Type.Score pack error\n" + err.Error())
		}

	}
	if cutVer >= Struct_TypeRankVersion {

		err = binary.Write(w, binary.BigEndian, this.Rank)
		if err != nil {
			return errors.New("Struct_Type.Rank pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Title))+1)
	if err != nil {
		return errors.New("Struct_Type.Title string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Title), 0))
	if err != nil {
		return errors.New("Struct_Type.Title string content pack error\n" + err.Error())
	}

	if cutVer >= Struct_TypeLevel2_StructVersion {

		err = this.Level2_Struct.PackTo(cutVer, w)
		if err != nil {
			return errors.New("Struct_Type.Level2_Struct pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *Struct_Type) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Struct_Type data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Struct_Type) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Struct_TypeCurrentVersion {
		cutVer = Struct_TypeCurrentVersion
	}
	// check version
	if cutVer < Struct_TypeBaseVersion {
		errors.New("Struct_Type cut version must large than Struct_TypeBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.X)
	if err != nil {
		return errors.New("Struct_Type.X unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Y)
	if err != nil {
		return errors.New("Struct_Type.Y unpack error\n" + err.Error())
	}

	if cutVer >= Struct_TypeScoreVersion {

		err = binary.Read(r, binary.BigEndian, &this.Score)
		if err != nil {
			return errors.New("Struct_Type.Score unpack error\n" + err.Error())
		}

	} else {
		this.Score = 1.11

	}
	if cutVer >= Struct_TypeRankVersion {

		err = binary.Read(r, binary.BigEndian, &this.Rank)
		if err != nil {
			return errors.New("Struct_Type.Rank unpack error\n" + err.Error())
		}

	} else {
		this.Rank = 1

	}

	var titleSize uint32
	err = binary.Read(r, binary.BigEndian, &titleSize)
	if err != nil {
		return errors.New("Struct_Type.Title string size unpack error\n" + err.Error())
	}

	titleBytes := make([]byte, titleSize)
	err = binary.Read(r, binary.BigEndian, titleBytes)
	if err != nil {
		return errors.New("Struct_Type.Title string content unpack error\n" + err.Error())
	}
	this.Title = string(titleBytes[:len(titleBytes)-1])

	if cutVer >= Struct_TypeLevel2_StructVersion {

		err = this.Level2_Struct.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Struct_Type.Level2_Struct unpack error\n" + err.Error())
		}

	} else {
		this.Level2_Struct.Init()

	}
	return err
}

const (
	TestInfoBaseVersion    uint32 = 1
	TestInfoCurrentVersion uint32 = 1
)

// TestInfo
type TestInfo struct {
	D uint64 `tdr_field:"d"`

	Test uint64 `tdr_field:"test"`
}

func NewTestInfo() *TestInfo {
	obj := new(TestInfo)
	obj.Init()
	return obj
}

func (this *TestInfo) GetBaseVersion() uint32 {
	return TestInfoBaseVersion
}

func (this *TestInfo) GetCurrentVersion() uint32 {
	return TestInfoCurrentVersion
}

func (this *TestInfo) Init() {

}

func (this *TestInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TestInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TestInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TestInfoCurrentVersion {
		cutVer = TestInfoCurrentVersion
	}
	// check cut version
	if cutVer < TestInfoBaseVersion {
		return errors.New("TestInfo cut version must large than TestInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.D)
	if err != nil {
		return errors.New("TestInfo.D pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Test)
	if err != nil {
		return errors.New("TestInfo.Test pack error\n" + err.Error())
	}

	return nil
}

func (this *TestInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TestInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TestInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TestInfoCurrentVersion {
		cutVer = TestInfoCurrentVersion
	}
	// check version
	if cutVer < TestInfoBaseVersion {
		errors.New("TestInfo cut version must large than TestInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.D)
	if err != nil {
		return errors.New("TestInfo.D unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Test)
	if err != nil {
		return errors.New("TestInfo.Test unpack error\n" + err.Error())
	}

	return err
}

const (
	TableInfoBaseVersion    uint32 = 1
	TableInfoCurrentVersion uint32 = 1
)

var TableInfoDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Test",
}

// TableInfo
type TableInfo struct {
	C *TestInfo `tdr_field:"c"`

	Test uint64 `tdr_field:"test"`

	String_Array string `tdr_field:"string_array"`

	Count byte `tdr_field:"count"`

	Binary []int8 `tdr_field:"binary" tdr_count:"5" tdr_refer:"Count"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`
}

func NewTableInfo() *TableInfo {
	obj := new(TableInfo)
	obj.Init()
	return obj
}

func (this *TableInfo) GetBaseVersion() uint32 {
	return TableInfoBaseVersion
}

func (this *TableInfo) GetCurrentVersion() uint32 {
	return TableInfoCurrentVersion
}

func (this *TableInfo) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return TableInfoDBFeilds
}

func (this *TableInfo) Init() {
	this.C = NewTestInfo()

	this.Count = 0

}

func (this *TableInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TableInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TableInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TableInfoCurrentVersion {
		cutVer = TableInfoCurrentVersion
	}
	// check cut version
	if cutVer < TableInfoBaseVersion {
		return errors.New("TableInfo cut version must large than TableInfoBaseVersion\n")
	}

	var err error

	err = this.C.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TableInfo.C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Test)
	if err != nil {
		return errors.New("TableInfo.Test pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.String_Array))+1)
	if err != nil {
		return errors.New("TableInfo.String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.String_Array), 0))
	if err != nil {
		return errors.New("TableInfo.String_Array string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("TableInfo.Count pack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("TableInfo.Binary's refer Count should >= 0")
	}
	if this.Count > 5 {
		return errors.New("TableInfo.Binary's refer Count should <= count 5")
	}
	if len(this.Binary) < int(this.Count) {
		return errors.New("TableInfo.Binary's length should > Count")
	}
	if this.Count > 0 {
		referBinary := this.Binary[:this.Count]
		err = binary.Write(w, binary.BigEndian, referBinary)
		if err != nil {
			return errors.New("TableInfo.Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("TableInfo.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	return nil
}

func (this *TableInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TableInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TableInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TableInfoCurrentVersion {
		cutVer = TableInfoCurrentVersion
	}
	// check version
	if cutVer < TableInfoBaseVersion {
		errors.New("TableInfo cut version must large than TableInfoBaseVersion\n")
	}

	err = this.C.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TableInfo.C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Test)
	if err != nil {
		return errors.New("TableInfo.Test unpack error\n" + err.Error())
	}

	var string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &string_arraySize)
	if err != nil {
		return errors.New("TableInfo.String_Array string size unpack error\n" + err.Error())
	}

	string_arrayBytes := make([]byte, string_arraySize)
	err = binary.Read(r, binary.BigEndian, string_arrayBytes)
	if err != nil {
		return errors.New("TableInfo.String_Array string content unpack error\n" + err.Error())
	}
	this.String_Array = string(string_arrayBytes[:len(string_arrayBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("TableInfo.Count unpack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("TableInfo.Binary's refer Count should >= 0")
	}
	if this.Count > 5 {
		return errors.New("TableInfo.Binary's refer Count should <= count 5")
	}

	if this.Binary == nil {
		this.Binary = make([]int8, int(this.Count))
	}

	referBinary := this.Binary[:this.Count]
	err = binary.Read(r, binary.BigEndian, referBinary)
	if err != nil {
		return errors.New("TableInfo.Binary pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("TableInfo.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	return err
}

const (
	Simple_StructBaseVersion    uint32 = 4
	Simple_StructCurrentVersion uint32 = 4
)

// Simple_Struct
type Simple_Struct struct {
	C_Int8 int8 `tdr_field:"c_int8"`

	C_Uint8 byte `tdr_field:"c_uint8"`

	C_Int16 int16 `tdr_field:"c_int16"`

	C_Uint16 uint16 `tdr_field:"c_uint16"`

	C_Int32 int32 `tdr_field:"c_int32"`

	C_Uint32 uint32 `tdr_field:"c_uint32"`

	C_Int64 int64 `tdr_field:"c_int64"`

	C_Uint64 uint64 `tdr_field:"c_uint64"`
}

func NewSimple_Struct() *Simple_Struct {
	obj := new(Simple_Struct)
	obj.Init()
	return obj
}

func (this *Simple_Struct) GetBaseVersion() uint32 {
	return Simple_StructBaseVersion
}

func (this *Simple_Struct) GetCurrentVersion() uint32 {
	return Simple_StructCurrentVersion
}

func (this *Simple_Struct) Init() {
	this.C_Int8 = -1

	this.C_Uint8 = 2

	this.C_Int16 = -3

	this.C_Uint16 = 4

	this.C_Int32 = -5

	this.C_Uint32 = 6

	this.C_Int64 = -7

	this.C_Uint64 = 8

}

func (this *Simple_Struct) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Simple_Struct Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Simple_Struct) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Simple_StructCurrentVersion {
		cutVer = Simple_StructCurrentVersion
	}
	// check cut version
	if cutVer < Simple_StructBaseVersion {
		return errors.New("Simple_Struct cut version must large than Simple_StructBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.C_Int8)
	if err != nil {
		return errors.New("Simple_Struct.C_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint8)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int16)
	if err != nil {
		return errors.New("Simple_Struct.C_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint16)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int32)
	if err != nil {
		return errors.New("Simple_Struct.C_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint32)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int64)
	if err != nil {
		return errors.New("Simple_Struct.C_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint64)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint64 pack error\n" + err.Error())
	}

	return nil
}

func (this *Simple_Struct) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Simple_Struct data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Simple_Struct) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Simple_StructCurrentVersion {
		cutVer = Simple_StructCurrentVersion
	}
	// check version
	if cutVer < Simple_StructBaseVersion {
		errors.New("Simple_Struct cut version must large than Simple_StructBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int8)
	if err != nil {
		return errors.New("Simple_Struct.C_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint8)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int16)
	if err != nil {
		return errors.New("Simple_Struct.C_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint16)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int32)
	if err != nil {
		return errors.New("Simple_Struct.C_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint32)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int64)
	if err != nil {
		return errors.New("Simple_Struct.C_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint64)
	if err != nil {
		return errors.New("Simple_Struct.C_Uint64 unpack error\n" + err.Error())
	}

	return err
}

const (
	Table_GenericBaseVersion          uint32 = 1
	Table_GenericCurrentVersion       uint32 = 4
	Table_GenericC_FloatVersion       uint32 = 2
	Table_GenericC_DoubleVersion      uint32 = 3
	Table_GenericSimple_StructVersion uint32 = 4
)

var Table_GenericDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin,Name,Key3,Key4",
	Index2Column: map[string]string{
		"Index2": "Uin,Name",
		"Index3": "Uin,Name,Key3",
		"Index1": "Uin",
		"Index4": "Uin,Key4",
	},
}

// Table_Generic
type Table_Generic struct {
	Uin uint64 `tdr_field:"uin"`

	Name string `tdr_field:"name"`

	Key3 string `tdr_field:"key3"`

	Key4 string `tdr_field:"key4"`

	Level int32 `tdr_field:"level"`

	Count byte `tdr_field:"count"`

	Info string `tdr_field:"info"`

	Float_Score float32 `tdr_field:"float_score"`

	Double_Score float64 `tdr_field:"double_score"`

	Items []uint64 `tdr_field:"items" tdr_count:"10" tdr_refer:"Count"`

	Big_Record_1 string `tdr_field:"big_record_1"`

	Big_Record_2 string `tdr_field:"big_record_2"`

	Big_Record_3 string `tdr_field:"big_record_3"`

	Big_Record_4 string `tdr_field:"big_record_4"`

	Big_Record_5 string `tdr_field:"big_record_5"`

	C_Int8 int8 `tdr_field:"c_int8"`

	C_Uint8 byte `tdr_field:"c_uint8"`

	C_Int16 int16 `tdr_field:"c_int16"`

	C_Uint16 uint16 `tdr_field:"c_uint16"`

	C_Int32 int32 `tdr_field:"c_int32"`

	C_Uint32 uint32 `tdr_field:"c_uint32"`

	C_Int64 int64 `tdr_field:"c_int64"`

	C_Uint64 uint64 `tdr_field:"c_uint64"`

	C_Float float32 `tdr_field:"c_float"`

	C_Double float64 `tdr_field:"c_double"`

	C_String string `tdr_field:"c_string"`

	C_Binary []int8 `tdr_field:"c_binary" tdr_count:"100" tdr_refer:"C_Uint32"`

	Max_String string `tdr_field:"max_string"`

	Binary_Count uint32 `tdr_field:"binary_count"`

	Max_Binary []int8 `tdr_field:"max_binary" tdr_count:"131070" tdr_refer:"Binary_Count"`

	Selector int16 `tdr_field:"selector"`

	Single_Struct *Struct_Type `tdr_field:"single_struct"`

	Simple_Struct *Simple_Struct `tdr_field:"simple_struct"`

	Single_Union_Selector int8 `tdr_field:"single_union_selector"`

	Single_Union *Union_Type `tdr_field:"single_union" tdr_select:"Single_Union_Selector"`

	Array_Count uint32 `tdr_field:"array_count"`

	Array []*TableInfo `tdr_field:"array" tdr_count:"3" tdr_refer:"Array_Count"`

	C_Union *Union_Type `tdr_field:"c_union" tdr_select:"Selector"`

	Union_Array []*Union_Type `tdr_field:"union_array" tdr_count:"3" tdr_refer:"Array_Count" tdr_select:"Selector"`

	C_Struct *Struct_Type `tdr_field:"c_struct"`

	Struct_Array []*Struct_Type `tdr_field:"struct_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Simple_Array_Count int32 `tdr_field:"simple_array_count"`

	Int_Array []int32 `tdr_field:"int_array" tdr_count:"5" tdr_refer:"Simple_Array_Count"`

	Double_Array []float64 `tdr_field:"double_array" tdr_count:"3" tdr_refer:"Simple_Array_Count"`
}

func NewTable_Generic() *Table_Generic {
	obj := new(Table_Generic)
	obj.Init()
	return obj
}

func (this *Table_Generic) GetBaseVersion() uint32 {
	return Table_GenericBaseVersion
}

func (this *Table_Generic) GetCurrentVersion() uint32 {
	return Table_GenericCurrentVersion
}

func (this *Table_Generic) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_GenericDBFeilds
}

func (this *Table_Generic) Init() {

	this.Level = 1

	this.Count = 0

	this.Float_Score = 0

	this.Double_Score = 0

	this.C_Int8 = -1

	this.C_Uint8 = 2

	this.C_Int16 = -3

	this.C_Uint16 = 4

	this.C_Int32 = -5

	this.C_Uint32 = 6

	this.C_Int64 = -7

	this.C_Float = 1.23456789

	this.C_Double = 9.87654321

	this.C_String = "123456789"

	this.Max_String = "123456789"

	this.Binary_Count = 10

	this.Single_Struct = NewStruct_Type()

	this.Simple_Struct = NewSimple_Struct()

	this.Single_Union_Selector = 0

	this.Single_Union = NewUnion_Type(int64(this.Single_Union_Selector))

	this.C_Union = NewUnion_Type(int64(this.Selector))

	this.C_Struct = NewStruct_Type()

}

func (this *Table_Generic) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Generic Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Generic) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_GenericCurrentVersion {
		cutVer = Table_GenericCurrentVersion
	}
	// check cut version
	if cutVer < Table_GenericBaseVersion {
		return errors.New("Table_Generic cut version must large than Table_GenericBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_Generic.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_Generic.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_Generic.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key3))+1)
	if err != nil {
		return errors.New("Table_Generic.Key3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key3), 0))
	if err != nil {
		return errors.New("Table_Generic.Key3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key4))+1)
	if err != nil {
		return errors.New("Table_Generic.Key4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key4), 0))
	if err != nil {
		return errors.New("Table_Generic.Key4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Generic.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("Table_Generic.Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Info))+1)
	if err != nil {
		return errors.New("Table_Generic.Info string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Info), 0))
	if err != nil {
		return errors.New("Table_Generic.Info string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Float_Score)
	if err != nil {
		return errors.New("Table_Generic.Float_Score pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Double_Score)
	if err != nil {
		return errors.New("Table_Generic.Double_Score pack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_Generic.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_Generic.Items's refer Count should <= count 10")
	}
	if len(this.Items) < int(this.Count) {
		return errors.New("Table_Generic.Items's length should > Count")
	}
	if this.Count > 0 {
		referItems := this.Items[:this.Count]
		err = binary.Write(w, binary.BigEndian, referItems)
		if err != nil {
			return errors.New("Table_Generic.Items pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_1))+1)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_1), 0))
	if err != nil {
		return errors.New("Table_Generic.Big_Record_1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_2))+1)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_2), 0))
	if err != nil {
		return errors.New("Table_Generic.Big_Record_2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_3))+1)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_3), 0))
	if err != nil {
		return errors.New("Table_Generic.Big_Record_3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_4))+1)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_4), 0))
	if err != nil {
		return errors.New("Table_Generic.Big_Record_4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_5))+1)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_5 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_5), 0))
	if err != nil {
		return errors.New("Table_Generic.Big_Record_5 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int8)
	if err != nil {
		return errors.New("Table_Generic.C_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint8)
	if err != nil {
		return errors.New("Table_Generic.C_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int16)
	if err != nil {
		return errors.New("Table_Generic.C_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint16)
	if err != nil {
		return errors.New("Table_Generic.C_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int32)
	if err != nil {
		return errors.New("Table_Generic.C_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint32)
	if err != nil {
		return errors.New("Table_Generic.C_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int64)
	if err != nil {
		return errors.New("Table_Generic.C_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint64)
	if err != nil {
		return errors.New("Table_Generic.C_Uint64 pack error\n" + err.Error())
	}

	if cutVer >= Table_GenericC_FloatVersion {

		err = binary.Write(w, binary.BigEndian, this.C_Float)
		if err != nil {
			return errors.New("Table_Generic.C_Float pack error\n" + err.Error())
		}

	}
	if cutVer >= Table_GenericC_DoubleVersion {

		err = binary.Write(w, binary.BigEndian, this.C_Double)
		if err != nil {
			return errors.New("Table_Generic.C_Double pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.C_String))+1)
	if err != nil {
		return errors.New("Table_Generic.C_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.C_String), 0))
	if err != nil {
		return errors.New("Table_Generic.C_String string content pack error\n" + err.Error())
	}

	if this.C_Uint32 < 0 {
		return errors.New("Table_Generic.C_Binary's refer C_Uint32 should >= 0")
	}
	if this.C_Uint32 > 100 {
		return errors.New("Table_Generic.C_Binary's refer C_Uint32 should <= count 100")
	}
	if len(this.C_Binary) < int(this.C_Uint32) {
		return errors.New("Table_Generic.C_Binary's length should > C_Uint32")
	}
	if this.C_Uint32 > 0 {
		referC_Binary := this.C_Binary[:this.C_Uint32]
		err = binary.Write(w, binary.BigEndian, referC_Binary)
		if err != nil {
			return errors.New("Table_Generic.C_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Max_String))+1)
	if err != nil {
		return errors.New("Table_Generic.Max_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Max_String), 0))
	if err != nil {
		return errors.New("Table_Generic.Max_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Binary_Count)
	if err != nil {
		return errors.New("Table_Generic.Binary_Count pack error\n" + err.Error())
	}

	if this.Binary_Count < 0 {
		return errors.New("Table_Generic.Max_Binary's refer Binary_Count should >= 0")
	}
	if this.Binary_Count > 131070 {
		return errors.New("Table_Generic.Max_Binary's refer Binary_Count should <= count 131070")
	}
	if len(this.Max_Binary) < int(this.Binary_Count) {
		return errors.New("Table_Generic.Max_Binary's length should > Binary_Count")
	}
	if this.Binary_Count > 0 {
		referMax_Binary := this.Max_Binary[:this.Binary_Count]
		err = binary.Write(w, binary.BigEndian, referMax_Binary)
		if err != nil {
			return errors.New("Table_Generic.Max_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Selector)
	if err != nil {
		return errors.New("Table_Generic.Selector pack error\n" + err.Error())
	}

	err = this.Single_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_Generic.Single_Struct pack error\n" + err.Error())
	}

	if cutVer >= Table_GenericSimple_StructVersion {

		err = this.Simple_Struct.PackTo(cutVer, w)
		if err != nil {
			return errors.New("Table_Generic.Simple_Struct pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.Single_Union_Selector)
	if err != nil {
		return errors.New("Table_Generic.Single_Union_Selector pack error\n" + err.Error())
	}

	err = this.Single_Union.PackTo(cutVer, w, int64(this.Single_Union_Selector))
	if err != nil {
		return errors.New("Table_Generic.Single_Union pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("Table_Generic.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic.Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic.Array's refer Array_Count should <= count 3")
	}
	if len(this.Array) < int(this.Array_Count) {
		return errors.New("Table_Generic.Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_Generic.Array pack error\n" + err.Error())
			}

		}
	}

	err = this.C_Union.PackTo(cutVer, w, int64(this.Selector))
	if err != nil {
		return errors.New("Table_Generic.C_Union pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic.Union_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic.Union_Array's refer Array_Count should <= count 3")
	}
	if len(this.Union_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic.Union_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Union_Array[i].PackTo(cutVer, w, int64(this.Selector))
			if err != nil {
				return errors.New("Table_Generic.Union_Array pack error\n" + err.Error())
			}

		}
	}

	err = this.C_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_Generic.C_Struct pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic.Struct_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic.Struct_Array's refer Array_Count should <= count 3")
	}
	if len(this.Struct_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic.Struct_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Struct_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_Generic.Struct_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Simple_Array_Count)
	if err != nil {
		return errors.New("Table_Generic.Simple_Array_Count pack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_Generic.Int_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 5 {
		return errors.New("Table_Generic.Int_Array's refer Simple_Array_Count should <= count 5")
	}
	if len(this.Int_Array) < int(this.Simple_Array_Count) {
		return errors.New("Table_Generic.Int_Array's length should > Simple_Array_Count")
	}
	if this.Simple_Array_Count > 0 {
		referInt_Array := this.Int_Array[:this.Simple_Array_Count]
		err = binary.Write(w, binary.BigEndian, referInt_Array)
		if err != nil {
			return errors.New("Table_Generic.Int_Array pack error\n" + err.Error())
		}
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_Generic.Double_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 3 {
		return errors.New("Table_Generic.Double_Array's refer Simple_Array_Count should <= count 3")
	}
	if len(this.Double_Array) < int(this.Simple_Array_Count) {
		return errors.New("Table_Generic.Double_Array's length should > Simple_Array_Count")
	}
	if this.Simple_Array_Count > 0 {
		referDouble_Array := this.Double_Array[:this.Simple_Array_Count]
		err = binary.Write(w, binary.BigEndian, referDouble_Array)
		if err != nil {
			return errors.New("Table_Generic.Double_Array pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_Generic) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Generic data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Generic) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_GenericCurrentVersion {
		cutVer = Table_GenericCurrentVersion
	}
	// check version
	if cutVer < Table_GenericBaseVersion {
		errors.New("Table_Generic cut version must large than Table_GenericBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_Generic.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_Generic.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_Generic.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	var key3Size uint32
	err = binary.Read(r, binary.BigEndian, &key3Size)
	if err != nil {
		return errors.New("Table_Generic.Key3 string size unpack error\n" + err.Error())
	}

	key3Bytes := make([]byte, key3Size)
	err = binary.Read(r, binary.BigEndian, key3Bytes)
	if err != nil {
		return errors.New("Table_Generic.Key3 string content unpack error\n" + err.Error())
	}
	this.Key3 = string(key3Bytes[:len(key3Bytes)-1])

	var key4Size uint32
	err = binary.Read(r, binary.BigEndian, &key4Size)
	if err != nil {
		return errors.New("Table_Generic.Key4 string size unpack error\n" + err.Error())
	}

	key4Bytes := make([]byte, key4Size)
	err = binary.Read(r, binary.BigEndian, key4Bytes)
	if err != nil {
		return errors.New("Table_Generic.Key4 string content unpack error\n" + err.Error())
	}
	this.Key4 = string(key4Bytes[:len(key4Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Generic.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("Table_Generic.Count unpack error\n" + err.Error())
	}

	var infoSize uint32
	err = binary.Read(r, binary.BigEndian, &infoSize)
	if err != nil {
		return errors.New("Table_Generic.Info string size unpack error\n" + err.Error())
	}

	infoBytes := make([]byte, infoSize)
	err = binary.Read(r, binary.BigEndian, infoBytes)
	if err != nil {
		return errors.New("Table_Generic.Info string content unpack error\n" + err.Error())
	}
	this.Info = string(infoBytes[:len(infoBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Float_Score)
	if err != nil {
		return errors.New("Table_Generic.Float_Score unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Double_Score)
	if err != nil {
		return errors.New("Table_Generic.Double_Score unpack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_Generic.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_Generic.Items's refer Count should <= count 10")
	}

	if this.Items == nil {
		this.Items = make([]uint64, int(this.Count))
	}

	referItems := this.Items[:this.Count]
	err = binary.Read(r, binary.BigEndian, referItems)
	if err != nil {
		return errors.New("Table_Generic.Items pack error\n" + err.Error())
	}

	var big_record_1Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_1Size)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_1 string size unpack error\n" + err.Error())
	}

	big_record_1Bytes := make([]byte, big_record_1Size)
	err = binary.Read(r, binary.BigEndian, big_record_1Bytes)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_1 string content unpack error\n" + err.Error())
	}
	this.Big_Record_1 = string(big_record_1Bytes[:len(big_record_1Bytes)-1])

	var big_record_2Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_2Size)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_2 string size unpack error\n" + err.Error())
	}

	big_record_2Bytes := make([]byte, big_record_2Size)
	err = binary.Read(r, binary.BigEndian, big_record_2Bytes)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_2 string content unpack error\n" + err.Error())
	}
	this.Big_Record_2 = string(big_record_2Bytes[:len(big_record_2Bytes)-1])

	var big_record_3Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_3Size)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_3 string size unpack error\n" + err.Error())
	}

	big_record_3Bytes := make([]byte, big_record_3Size)
	err = binary.Read(r, binary.BigEndian, big_record_3Bytes)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_3 string content unpack error\n" + err.Error())
	}
	this.Big_Record_3 = string(big_record_3Bytes[:len(big_record_3Bytes)-1])

	var big_record_4Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_4Size)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_4 string size unpack error\n" + err.Error())
	}

	big_record_4Bytes := make([]byte, big_record_4Size)
	err = binary.Read(r, binary.BigEndian, big_record_4Bytes)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_4 string content unpack error\n" + err.Error())
	}
	this.Big_Record_4 = string(big_record_4Bytes[:len(big_record_4Bytes)-1])

	var big_record_5Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_5Size)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_5 string size unpack error\n" + err.Error())
	}

	big_record_5Bytes := make([]byte, big_record_5Size)
	err = binary.Read(r, binary.BigEndian, big_record_5Bytes)
	if err != nil {
		return errors.New("Table_Generic.Big_Record_5 string content unpack error\n" + err.Error())
	}
	this.Big_Record_5 = string(big_record_5Bytes[:len(big_record_5Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.C_Int8)
	if err != nil {
		return errors.New("Table_Generic.C_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint8)
	if err != nil {
		return errors.New("Table_Generic.C_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int16)
	if err != nil {
		return errors.New("Table_Generic.C_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint16)
	if err != nil {
		return errors.New("Table_Generic.C_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int32)
	if err != nil {
		return errors.New("Table_Generic.C_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint32)
	if err != nil {
		return errors.New("Table_Generic.C_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int64)
	if err != nil {
		return errors.New("Table_Generic.C_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint64)
	if err != nil {
		return errors.New("Table_Generic.C_Uint64 unpack error\n" + err.Error())
	}

	if cutVer >= Table_GenericC_FloatVersion {

		err = binary.Read(r, binary.BigEndian, &this.C_Float)
		if err != nil {
			return errors.New("Table_Generic.C_Float unpack error\n" + err.Error())
		}

	} else {
		this.C_Float = 1.23456789

	}
	if cutVer >= Table_GenericC_DoubleVersion {

		err = binary.Read(r, binary.BigEndian, &this.C_Double)
		if err != nil {
			return errors.New("Table_Generic.C_Double unpack error\n" + err.Error())
		}

	} else {
		this.C_Double = 9.87654321

	}

	var c_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &c_stringSize)
	if err != nil {
		return errors.New("Table_Generic.C_String string size unpack error\n" + err.Error())
	}

	c_stringBytes := make([]byte, c_stringSize)
	err = binary.Read(r, binary.BigEndian, c_stringBytes)
	if err != nil {
		return errors.New("Table_Generic.C_String string content unpack error\n" + err.Error())
	}
	this.C_String = string(c_stringBytes[:len(c_stringBytes)-1])

	if this.C_Uint32 < 0 {
		return errors.New("Table_Generic.C_Binary's refer C_Uint32 should >= 0")
	}
	if this.C_Uint32 > 100 {
		return errors.New("Table_Generic.C_Binary's refer C_Uint32 should <= count 100")
	}

	if this.C_Binary == nil {
		this.C_Binary = make([]int8, int(this.C_Uint32))
	}

	referC_Binary := this.C_Binary[:this.C_Uint32]
	err = binary.Read(r, binary.BigEndian, referC_Binary)
	if err != nil {
		return errors.New("Table_Generic.C_Binary pack error\n" + err.Error())
	}

	var max_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &max_stringSize)
	if err != nil {
		return errors.New("Table_Generic.Max_String string size unpack error\n" + err.Error())
	}

	max_stringBytes := make([]byte, max_stringSize)
	err = binary.Read(r, binary.BigEndian, max_stringBytes)
	if err != nil {
		return errors.New("Table_Generic.Max_String string content unpack error\n" + err.Error())
	}
	this.Max_String = string(max_stringBytes[:len(max_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Binary_Count)
	if err != nil {
		return errors.New("Table_Generic.Binary_Count unpack error\n" + err.Error())
	}

	if this.Binary_Count < 0 {
		return errors.New("Table_Generic.Max_Binary's refer Binary_Count should >= 0")
	}
	if this.Binary_Count > 131070 {
		return errors.New("Table_Generic.Max_Binary's refer Binary_Count should <= count 131070")
	}

	if this.Max_Binary == nil {
		this.Max_Binary = make([]int8, int(this.Binary_Count))
	}

	referMax_Binary := this.Max_Binary[:this.Binary_Count]
	err = binary.Read(r, binary.BigEndian, referMax_Binary)
	if err != nil {
		return errors.New("Table_Generic.Max_Binary pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Selector)
	if err != nil {
		return errors.New("Table_Generic.Selector unpack error\n" + err.Error())
	}

	err = this.Single_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_Generic.Single_Struct unpack error\n" + err.Error())
	}

	if cutVer >= Table_GenericSimple_StructVersion {

		err = this.Simple_Struct.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_Generic.Simple_Struct unpack error\n" + err.Error())
		}

	} else {
		this.Simple_Struct.Init()

	}

	err = binary.Read(r, binary.BigEndian, &this.Single_Union_Selector)
	if err != nil {
		return errors.New("Table_Generic.Single_Union_Selector unpack error\n" + err.Error())
	}

	err = this.Single_Union.UnpackFrom(cutVer, r, int64(this.Single_Union_Selector))
	if err != nil {
		return errors.New("Table_Generic.Single_Union unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("Table_Generic.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic.Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic.Array's refer Array_Count should <= count 3")
	}

	if this.Array == nil {
		this.Array = make([]*TableInfo, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Array[i] = NewTableInfo()
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_Generic.Array unpack error\n" + err.Error())
		}

	}

	err = this.C_Union.UnpackFrom(cutVer, r, int64(this.Selector))
	if err != nil {
		return errors.New("Table_Generic.C_Union unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic.Union_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic.Union_Array's refer Array_Count should <= count 3")
	}

	if this.Union_Array == nil {
		this.Union_Array = make([]*Union_Type, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Union_Array[i] = NewUnion_Type(int64(this.Selector))
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Union_Array[i].UnpackFrom(cutVer, r, int64(this.Selector))
		if err != nil {
			return errors.New("Table_Generic.Union_Array unpack error\n" + err.Error())
		}

	}

	err = this.C_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_Generic.C_Struct unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic.Struct_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic.Struct_Array's refer Array_Count should <= count 3")
	}

	if this.Struct_Array == nil {
		this.Struct_Array = make([]*Struct_Type, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Struct_Array[i] = NewStruct_Type()
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Struct_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_Generic.Struct_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Simple_Array_Count)
	if err != nil {
		return errors.New("Table_Generic.Simple_Array_Count unpack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_Generic.Int_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 5 {
		return errors.New("Table_Generic.Int_Array's refer Simple_Array_Count should <= count 5")
	}

	if this.Int_Array == nil {
		this.Int_Array = make([]int32, int(this.Simple_Array_Count))
	}

	referInt_Array := this.Int_Array[:this.Simple_Array_Count]
	err = binary.Read(r, binary.BigEndian, referInt_Array)
	if err != nil {
		return errors.New("Table_Generic.Int_Array pack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_Generic.Double_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 3 {
		return errors.New("Table_Generic.Double_Array's refer Simple_Array_Count should <= count 3")
	}

	if this.Double_Array == nil {
		this.Double_Array = make([]float64, int(this.Simple_Array_Count))
	}

	referDouble_Array := this.Double_Array[:this.Simple_Array_Count]
	err = binary.Read(r, binary.BigEndian, referDouble_Array)
	if err != nil {
		return errors.New("Table_Generic.Double_Array pack error\n" + err.Error())
	}

	return err
}

const (
	Table_Generic_SimpleBaseVersion    uint32 = 1
	Table_Generic_SimpleCurrentVersion uint32 = 1
)

var Table_Generic_SimpleDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin,Name",
	Index2Column: map[string]string{
		"Test_Index1": "Uin",
	},
}

// Table_Generic_Simple
type Table_Generic_Simple struct {
	Uin int32 `tdr_field:"uin"`

	Name string `tdr_field:"name"`

	Level int32 `tdr_field:"level"`

	Count byte `tdr_field:"count"`

	Float_Score float32 `tdr_field:"float_score"`

	Double_Score float64 `tdr_field:"double_score"`

	Items []uint64 `tdr_field:"items" tdr_count:"10" tdr_refer:"Count"`

	Info string `tdr_field:"info"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Big_Record_1 string `tdr_field:"big_record_1"`

	Big_Record_2 string `tdr_field:"big_record_2"`

	Big_Record_3 string `tdr_field:"big_record_3"`

	Big_Record_4 string `tdr_field:"big_record_4"`

	Big_Record_5 string `tdr_field:"big_record_5"`
}

func NewTable_Generic_Simple() *Table_Generic_Simple {
	obj := new(Table_Generic_Simple)
	obj.Init()
	return obj
}

func (this *Table_Generic_Simple) GetBaseVersion() uint32 {
	return Table_Generic_SimpleBaseVersion
}

func (this *Table_Generic_Simple) GetCurrentVersion() uint32 {
	return Table_Generic_SimpleCurrentVersion
}

func (this *Table_Generic_Simple) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Generic_SimpleDBFeilds
}

func (this *Table_Generic_Simple) Init() {

	this.Level = 1

	this.Count = 0

	this.Float_Score = 0

	this.Double_Score = 0

}

func (this *Table_Generic_Simple) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Generic_Simple Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Generic_Simple) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Generic_SimpleCurrentVersion {
		cutVer = Table_Generic_SimpleCurrentVersion
	}
	// check cut version
	if cutVer < Table_Generic_SimpleBaseVersion {
		return errors.New("Table_Generic_Simple cut version must large than Table_Generic_SimpleBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_Generic_Simple.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Generic_Simple.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("Table_Generic_Simple.Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Float_Score)
	if err != nil {
		return errors.New("Table_Generic_Simple.Float_Score pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Double_Score)
	if err != nil {
		return errors.New("Table_Generic_Simple.Double_Score pack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_Generic_Simple.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_Generic_Simple.Items's refer Count should <= count 10")
	}
	if len(this.Items) < int(this.Count) {
		return errors.New("Table_Generic_Simple.Items's length should > Count")
	}
	if this.Count > 0 {
		referItems := this.Items[:this.Count]
		err = binary.Write(w, binary.BigEndian, referItems)
		if err != nil {
			return errors.New("Table_Generic_Simple.Items pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Info))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Info string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Info), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Info string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_Simple.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_1))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_1), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_2))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_2), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_3))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_3), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_4))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_4), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_5))+1)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_5 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_5), 0))
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_5 string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Generic_Simple) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Generic_Simple data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Generic_Simple) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Generic_SimpleCurrentVersion {
		cutVer = Table_Generic_SimpleCurrentVersion
	}
	// check version
	if cutVer < Table_Generic_SimpleBaseVersion {
		errors.New("Table_Generic_Simple cut version must large than Table_Generic_SimpleBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_Generic_Simple.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_Generic_Simple.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Generic_Simple.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("Table_Generic_Simple.Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Float_Score)
	if err != nil {
		return errors.New("Table_Generic_Simple.Float_Score unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Double_Score)
	if err != nil {
		return errors.New("Table_Generic_Simple.Double_Score unpack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_Generic_Simple.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_Generic_Simple.Items's refer Count should <= count 10")
	}

	if this.Items == nil {
		this.Items = make([]uint64, int(this.Count))
	}

	referItems := this.Items[:this.Count]
	err = binary.Read(r, binary.BigEndian, referItems)
	if err != nil {
		return errors.New("Table_Generic_Simple.Items pack error\n" + err.Error())
	}

	var infoSize uint32
	err = binary.Read(r, binary.BigEndian, &infoSize)
	if err != nil {
		return errors.New("Table_Generic_Simple.Info string size unpack error\n" + err.Error())
	}

	infoBytes := make([]byte, infoSize)
	err = binary.Read(r, binary.BigEndian, infoBytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Info string content unpack error\n" + err.Error())
	}
	this.Info = string(infoBytes[:len(infoBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_Simple.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	var big_record_1Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_1Size)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_1 string size unpack error\n" + err.Error())
	}

	big_record_1Bytes := make([]byte, big_record_1Size)
	err = binary.Read(r, binary.BigEndian, big_record_1Bytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_1 string content unpack error\n" + err.Error())
	}
	this.Big_Record_1 = string(big_record_1Bytes[:len(big_record_1Bytes)-1])

	var big_record_2Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_2Size)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_2 string size unpack error\n" + err.Error())
	}

	big_record_2Bytes := make([]byte, big_record_2Size)
	err = binary.Read(r, binary.BigEndian, big_record_2Bytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_2 string content unpack error\n" + err.Error())
	}
	this.Big_Record_2 = string(big_record_2Bytes[:len(big_record_2Bytes)-1])

	var big_record_3Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_3Size)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_3 string size unpack error\n" + err.Error())
	}

	big_record_3Bytes := make([]byte, big_record_3Size)
	err = binary.Read(r, binary.BigEndian, big_record_3Bytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_3 string content unpack error\n" + err.Error())
	}
	this.Big_Record_3 = string(big_record_3Bytes[:len(big_record_3Bytes)-1])

	var big_record_4Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_4Size)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_4 string size unpack error\n" + err.Error())
	}

	big_record_4Bytes := make([]byte, big_record_4Size)
	err = binary.Read(r, binary.BigEndian, big_record_4Bytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_4 string content unpack error\n" + err.Error())
	}
	this.Big_Record_4 = string(big_record_4Bytes[:len(big_record_4Bytes)-1])

	var big_record_5Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_5Size)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_5 string size unpack error\n" + err.Error())
	}

	big_record_5Bytes := make([]byte, big_record_5Size)
	err = binary.Read(r, binary.BigEndian, big_record_5Bytes)
	if err != nil {
		return errors.New("Table_Generic_Simple.Big_Record_5 string content unpack error\n" + err.Error())
	}
	this.Big_Record_5 = string(big_record_5Bytes[:len(big_record_5Bytes)-1])

	return err
}

const (
	Table_Generic_For256KBaseVersion    uint32 = 1
	Table_Generic_For256KCurrentVersion uint32 = 1
)

var Table_Generic_For256KDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin,Name",
	Index2Column: map[string]string{
		"Test_Index1": "Uin",
	},
}

// Table_Generic_For256K
type Table_Generic_For256K struct {
	Uin int32 `tdr_field:"uin"`

	Name string `tdr_field:"name"`

	Level int32 `tdr_field:"level"`

	Count byte `tdr_field:"count"`

	Float_Score float32 `tdr_field:"float_score"`

	Double_Score float64 `tdr_field:"double_score"`

	Items []uint64 `tdr_field:"items" tdr_count:"10" tdr_refer:"Count"`

	Info string `tdr_field:"info"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Big_Record_1 string `tdr_field:"big_record_1"`

	Big_Record_2 string `tdr_field:"big_record_2"`

	Big_Record_3 string `tdr_field:"big_record_3"`

	Big_Record_4 string `tdr_field:"big_record_4"`
}

func NewTable_Generic_For256K() *Table_Generic_For256K {
	obj := new(Table_Generic_For256K)
	obj.Init()
	return obj
}

func (this *Table_Generic_For256K) GetBaseVersion() uint32 {
	return Table_Generic_For256KBaseVersion
}

func (this *Table_Generic_For256K) GetCurrentVersion() uint32 {
	return Table_Generic_For256KCurrentVersion
}

func (this *Table_Generic_For256K) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Generic_For256KDBFeilds
}

func (this *Table_Generic_For256K) Init() {

	this.Level = 1

	this.Count = 0

	this.Float_Score = 0

	this.Double_Score = 0

}

func (this *Table_Generic_For256K) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Generic_For256K Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Generic_For256K) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Generic_For256KCurrentVersion {
		cutVer = Table_Generic_For256KCurrentVersion
	}
	// check cut version
	if cutVer < Table_Generic_For256KBaseVersion {
		return errors.New("Table_Generic_For256K cut version must large than Table_Generic_For256KBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_Generic_For256K.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_Generic_For256K.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_Generic_For256K.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Generic_For256K.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("Table_Generic_For256K.Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Float_Score)
	if err != nil {
		return errors.New("Table_Generic_For256K.Float_Score pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Double_Score)
	if err != nil {
		return errors.New("Table_Generic_For256K.Double_Score pack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_Generic_For256K.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_Generic_For256K.Items's refer Count should <= count 10")
	}
	if len(this.Items) < int(this.Count) {
		return errors.New("Table_Generic_For256K.Items's length should > Count")
	}
	if this.Count > 0 {
		referItems := this.Items[:this.Count]
		err = binary.Write(w, binary.BigEndian, referItems)
		if err != nil {
			return errors.New("Table_Generic_For256K.Items pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Info))+1)
	if err != nil {
		return errors.New("Table_Generic_For256K.Info string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Info), 0))
	if err != nil {
		return errors.New("Table_Generic_For256K.Info string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_For256K.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_1))+1)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_1), 0))
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_2))+1)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_2), 0))
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_3))+1)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_3), 0))
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_4))+1)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_4), 0))
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_4 string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Generic_For256K) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Generic_For256K data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Generic_For256K) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Generic_For256KCurrentVersion {
		cutVer = Table_Generic_For256KCurrentVersion
	}
	// check version
	if cutVer < Table_Generic_For256KBaseVersion {
		errors.New("Table_Generic_For256K cut version must large than Table_Generic_For256KBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_Generic_For256K.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_Generic_For256K.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_Generic_For256K.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Generic_For256K.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("Table_Generic_For256K.Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Float_Score)
	if err != nil {
		return errors.New("Table_Generic_For256K.Float_Score unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Double_Score)
	if err != nil {
		return errors.New("Table_Generic_For256K.Double_Score unpack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_Generic_For256K.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_Generic_For256K.Items's refer Count should <= count 10")
	}

	if this.Items == nil {
		this.Items = make([]uint64, int(this.Count))
	}

	referItems := this.Items[:this.Count]
	err = binary.Read(r, binary.BigEndian, referItems)
	if err != nil {
		return errors.New("Table_Generic_For256K.Items pack error\n" + err.Error())
	}

	var infoSize uint32
	err = binary.Read(r, binary.BigEndian, &infoSize)
	if err != nil {
		return errors.New("Table_Generic_For256K.Info string size unpack error\n" + err.Error())
	}

	infoBytes := make([]byte, infoSize)
	err = binary.Read(r, binary.BigEndian, infoBytes)
	if err != nil {
		return errors.New("Table_Generic_For256K.Info string content unpack error\n" + err.Error())
	}
	this.Info = string(infoBytes[:len(infoBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_For256K.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	var big_record_1Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_1Size)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_1 string size unpack error\n" + err.Error())
	}

	big_record_1Bytes := make([]byte, big_record_1Size)
	err = binary.Read(r, binary.BigEndian, big_record_1Bytes)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_1 string content unpack error\n" + err.Error())
	}
	this.Big_Record_1 = string(big_record_1Bytes[:len(big_record_1Bytes)-1])

	var big_record_2Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_2Size)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_2 string size unpack error\n" + err.Error())
	}

	big_record_2Bytes := make([]byte, big_record_2Size)
	err = binary.Read(r, binary.BigEndian, big_record_2Bytes)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_2 string content unpack error\n" + err.Error())
	}
	this.Big_Record_2 = string(big_record_2Bytes[:len(big_record_2Bytes)-1])

	var big_record_3Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_3Size)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_3 string size unpack error\n" + err.Error())
	}

	big_record_3Bytes := make([]byte, big_record_3Size)
	err = binary.Read(r, binary.BigEndian, big_record_3Bytes)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_3 string content unpack error\n" + err.Error())
	}
	this.Big_Record_3 = string(big_record_3Bytes[:len(big_record_3Bytes)-1])

	var big_record_4Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_4Size)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_4 string size unpack error\n" + err.Error())
	}

	big_record_4Bytes := make([]byte, big_record_4Size)
	err = binary.Read(r, binary.BigEndian, big_record_4Bytes)
	if err != nil {
		return errors.New("Table_Generic_For256K.Big_Record_4 string content unpack error\n" + err.Error())
	}
	this.Big_Record_4 = string(big_record_4Bytes[:len(big_record_4Bytes)-1])

	return err
}

const (
	Test_Key_For_IntBaseVersion    uint32 = 1
	Test_Key_For_IntCurrentVersion uint32 = 1
)

var Test_Key_For_IntDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Int8,Int16,Int32,Int64",
}

// Test_Key_For_Int
type Test_Key_For_Int struct {
	Int8 int8 `tdr_field:"int8"`

	Int16 int16 `tdr_field:"int16"`

	Int32 int32 `tdr_field:"int32"`

	Int64 int64 `tdr_field:"int64"`

	Level int32 `tdr_field:"level"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`
}

func NewTest_Key_For_Int() *Test_Key_For_Int {
	obj := new(Test_Key_For_Int)
	obj.Init()
	return obj
}

func (this *Test_Key_For_Int) GetBaseVersion() uint32 {
	return Test_Key_For_IntBaseVersion
}

func (this *Test_Key_For_Int) GetCurrentVersion() uint32 {
	return Test_Key_For_IntCurrentVersion
}

func (this *Test_Key_For_Int) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Test_Key_For_IntDBFeilds
}

func (this *Test_Key_For_Int) Init() {

	this.Level = 1

}

func (this *Test_Key_For_Int) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Test_Key_For_Int Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Test_Key_For_Int) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Test_Key_For_IntCurrentVersion {
		cutVer = Test_Key_For_IntCurrentVersion
	}
	// check cut version
	if cutVer < Test_Key_For_IntBaseVersion {
		return errors.New("Test_Key_For_Int cut version must large than Test_Key_For_IntBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Int8)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Int16)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Int32)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Int64)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Test_Key_For_Int.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Test_Key_For_Int.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	return nil
}

func (this *Test_Key_For_Int) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Test_Key_For_Int data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Test_Key_For_Int) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Test_Key_For_IntCurrentVersion {
		cutVer = Test_Key_For_IntCurrentVersion
	}
	// check version
	if cutVer < Test_Key_For_IntBaseVersion {
		errors.New("Test_Key_For_Int cut version must large than Test_Key_For_IntBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Int8)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Int16)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Int32)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Int64)
	if err != nil {
		return errors.New("Test_Key_For_Int.Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Test_Key_For_Int.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Test_Key_For_Int.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	return err
}

const (
	Test_Key_For_UintBaseVersion    uint32 = 1
	Test_Key_For_UintCurrentVersion uint32 = 1
)

var Test_Key_For_UintDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Uint8,Uint16,Uint32,Uint64",
}

// Test_Key_For_Uint
type Test_Key_For_Uint struct {
	Uint8 byte `tdr_field:"uint8"`

	Uint16 uint16 `tdr_field:"uint16"`

	Uint32 uint32 `tdr_field:"uint32"`

	Uint64 uint64 `tdr_field:"uint64"`

	Level int32 `tdr_field:"level"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`
}

func NewTest_Key_For_Uint() *Test_Key_For_Uint {
	obj := new(Test_Key_For_Uint)
	obj.Init()
	return obj
}

func (this *Test_Key_For_Uint) GetBaseVersion() uint32 {
	return Test_Key_For_UintBaseVersion
}

func (this *Test_Key_For_Uint) GetCurrentVersion() uint32 {
	return Test_Key_For_UintCurrentVersion
}

func (this *Test_Key_For_Uint) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Test_Key_For_UintDBFeilds
}

func (this *Test_Key_For_Uint) Init() {

	this.Level = 1

}

func (this *Test_Key_For_Uint) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Test_Key_For_Uint Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Test_Key_For_Uint) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Test_Key_For_UintCurrentVersion {
		cutVer = Test_Key_For_UintCurrentVersion
	}
	// check cut version
	if cutVer < Test_Key_For_UintBaseVersion {
		return errors.New("Test_Key_For_Uint cut version must large than Test_Key_For_UintBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uint8)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Uint16)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Uint32)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Uint64)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	return nil
}

func (this *Test_Key_For_Uint) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Test_Key_For_Uint data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Test_Key_For_Uint) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Test_Key_For_UintCurrentVersion {
		cutVer = Test_Key_For_UintCurrentVersion
	}
	// check version
	if cutVer < Test_Key_For_UintBaseVersion {
		errors.New("Test_Key_For_Uint cut version must large than Test_Key_For_UintBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uint8)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Uint16)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Uint32)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Uint64)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Test_Key_For_Uint.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	return err
}

const MAX_ATTR_SIZE int64 = 33
const MAX_NAME_LEN int64 = 33
const INIT_VERSION int64 = 33
const (
	S4BaseVersion    uint32 = 1
	S4CurrentVersion uint32 = 1
)

// S4
type S4 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count uint32 `tdr_field:"array_count"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`
}

func NewS4() *S4 {
	obj := new(S4)
	obj.Init()
	return obj
}

func (this *S4) GetBaseVersion() uint32 {
	return S4BaseVersion
}

func (this *S4) GetCurrentVersion() uint32 {
	return S4CurrentVersion
}

func (this *S4) Init() {

}

func (this *S4) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("S4 Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *S4) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > S4CurrentVersion {
		cutVer = S4CurrentVersion
	}
	// check cut version
	if cutVer < S4BaseVersion {
		return errors.New("S4 cut version must large than S4BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("S4.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("S4.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("S4.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("S4.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("S4.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("S4.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("S4.Array_Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("S4.Struct_Array_Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("S4.Union_Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S4.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S4.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("S4.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("S4.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("S4.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("S4.Type_String_Array string content pack error\n" + err.Error())
	}

	return nil
}

func (this *S4) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("S4 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *S4) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > S4CurrentVersion {
		cutVer = S4CurrentVersion
	}
	// check version
	if cutVer < S4BaseVersion {
		errors.New("S4 cut version must large than S4BaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("S4.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("S4.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("S4.Type_Float unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("S4.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("S4.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("S4.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("S4.Array_Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("S4.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("S4.Union_Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S4.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S4.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("S4.Type_Int32_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("S4.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("S4.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	return err
}

const (
	U4BaseVersion    uint32 = 1
	U4CurrentVersion uint32 = 1
)

// U4
type U4 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Type_Int32_Array int32 `tdr_field:"type_int32_array"`

	Type_String_Array string `tdr_field:"type_string_array"`
}

func NewU4(selector int64) *U4 {
	obj := new(U4)
	obj.Init(selector)
	return obj
}

func (this *U4) GetBaseVersion() uint32 {
	return U4BaseVersion
}

func (this *U4) GetCurrentVersion() uint32 {
	return U4CurrentVersion
}

func (this *U4) Init(selector int64) {
	switch selector {
	case 1:

	case 5:

	case 9:

	case 12:

	case 14:

	case 17:

	case 19:

	}
}

func (this *U4) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *U4) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > U4CurrentVersion {
		cutVer = U4CurrentVersion
	}
	// check cut version
	if cutVer < U4BaseVersion {
		return errors.New("U4 cut version must large than U4BaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 1:

		err = binary.Write(w, binary.BigEndian, this.Type_Int8)
		if err != nil {
			return errors.New("U4.Type_Int8 pack error\n" + err.Error())
		}

	case 5:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32)
		if err != nil {
			return errors.New("U4.Type_Int32 pack error\n" + err.Error())
		}

	case 9:

		err = binary.Write(w, binary.BigEndian, this.Type_Float)
		if err != nil {
			return errors.New("U4.Type_Float pack error\n" + err.Error())
		}

	case 12:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
		if err != nil {
			return errors.New("U4.Type_String string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
		if err != nil {
			return errors.New("U4.Type_String string content pack error\n" + err.Error())
		}

	case 14:

		err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
		if err != nil {
			return errors.New("U4.Type_Datetime pack error\n" + err.Error())
		}

	case 17:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32_Array)
		if err != nil {
			return errors.New("U4.Type_Int32_Array pack error\n" + err.Error())
		}

	case 19:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
		if err != nil {
			return errors.New("U4.Type_String_Array string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
		if err != nil {
			return errors.New("U4.Type_String_Array string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *U4) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("U4 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *U4) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > U4CurrentVersion {
		cutVer = U4CurrentVersion
	}
	// check version
	if cutVer < U4BaseVersion {
		errors.New("U4 cut version must large than U4BaseVersion\n")
	}

	switch selector {
	case 1:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
		if err != nil {
			return errors.New("U4.Type_Int8 unpack error\n" + err.Error())
		}

	case 5:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
		if err != nil {
			return errors.New("U4.Type_Int32 unpack error\n" + err.Error())
		}

	case 9:

		err = binary.Read(r, binary.BigEndian, &this.Type_Float)
		if err != nil {
			return errors.New("U4.Type_Float unpack error\n" + err.Error())
		}

	case 12:

		var type_stringSize uint32
		err = binary.Read(r, binary.BigEndian, &type_stringSize)
		if err != nil {
			return errors.New("U4.Type_String string size unpack error\n" + err.Error())
		}

		type_stringBytes := make([]byte, type_stringSize)
		err = binary.Read(r, binary.BigEndian, type_stringBytes)
		if err != nil {
			return errors.New("U4.Type_String string content unpack error\n" + err.Error())
		}
		this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	case 14:

		err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
		if err != nil {
			return errors.New("U4.Type_Datetime unpack error\n" + err.Error())
		}

	case 17:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32_Array)
		if err != nil {
			return errors.New("U4.Type_Int32_Array unpack error\n" + err.Error())
		}

	case 19:

		var type_string_arraySize uint32
		err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
		if err != nil {
			return errors.New("U4.Type_String_Array string size unpack error\n" + err.Error())
		}

		type_string_arrayBytes := make([]byte, type_string_arraySize)
		err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
		if err != nil {
			return errors.New("U4.Type_String_Array string content unpack error\n" + err.Error())
		}
		this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	}

	return err
}

const (
	U3BaseVersion    uint32 = 1
	U3CurrentVersion uint32 = 1
)

// U3
type U3 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Type_Int32_Array int32 `tdr_field:"type_int32_array"`

	Type_String_Array string `tdr_field:"type_string_array"`

	S4 *S4 `tdr_field:"S4"`

	S4_Array *S4 `tdr_field:"S4_array"`
}

func NewU3(selector int64) *U3 {
	obj := new(U3)
	obj.Init(selector)
	return obj
}

func (this *U3) GetBaseVersion() uint32 {
	return U3BaseVersion
}

func (this *U3) GetCurrentVersion() uint32 {
	return U3CurrentVersion
}

func (this *U3) Init(selector int64) {
	switch selector {
	case 1:

	case 5:

	case 9:

	case 12:

	case 14:

	case 17:

	case 19:

	case 24:
		this.S4 = NewS4()

	case 25:
		this.S4_Array = NewS4()

	}
}

func (this *U3) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *U3) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > U3CurrentVersion {
		cutVer = U3CurrentVersion
	}
	// check cut version
	if cutVer < U3BaseVersion {
		return errors.New("U3 cut version must large than U3BaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 1:

		err = binary.Write(w, binary.BigEndian, this.Type_Int8)
		if err != nil {
			return errors.New("U3.Type_Int8 pack error\n" + err.Error())
		}

	case 5:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32)
		if err != nil {
			return errors.New("U3.Type_Int32 pack error\n" + err.Error())
		}

	case 9:

		err = binary.Write(w, binary.BigEndian, this.Type_Float)
		if err != nil {
			return errors.New("U3.Type_Float pack error\n" + err.Error())
		}

	case 12:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
		if err != nil {
			return errors.New("U3.Type_String string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
		if err != nil {
			return errors.New("U3.Type_String string content pack error\n" + err.Error())
		}

	case 14:

		err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
		if err != nil {
			return errors.New("U3.Type_Datetime pack error\n" + err.Error())
		}

	case 17:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32_Array)
		if err != nil {
			return errors.New("U3.Type_Int32_Array pack error\n" + err.Error())
		}

	case 19:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
		if err != nil {
			return errors.New("U3.Type_String_Array string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
		if err != nil {
			return errors.New("U3.Type_String_Array string content pack error\n" + err.Error())
		}

	case 24:
		if this.S4 == nil {
			return errors.New("U3.S4 is nil")
		}

		err = this.S4.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U3.S4 pack error\n" + err.Error())
		}

	case 25:
		if this.S4_Array == nil {
			return errors.New("U3.S4_Array is nil")
		}

		err = this.S4_Array.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U3.S4_Array pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *U3) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("U3 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *U3) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > U3CurrentVersion {
		cutVer = U3CurrentVersion
	}
	// check version
	if cutVer < U3BaseVersion {
		errors.New("U3 cut version must large than U3BaseVersion\n")
	}

	switch selector {
	case 1:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
		if err != nil {
			return errors.New("U3.Type_Int8 unpack error\n" + err.Error())
		}

	case 5:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
		if err != nil {
			return errors.New("U3.Type_Int32 unpack error\n" + err.Error())
		}

	case 9:

		err = binary.Read(r, binary.BigEndian, &this.Type_Float)
		if err != nil {
			return errors.New("U3.Type_Float unpack error\n" + err.Error())
		}

	case 12:

		var type_stringSize uint32
		err = binary.Read(r, binary.BigEndian, &type_stringSize)
		if err != nil {
			return errors.New("U3.Type_String string size unpack error\n" + err.Error())
		}

		type_stringBytes := make([]byte, type_stringSize)
		err = binary.Read(r, binary.BigEndian, type_stringBytes)
		if err != nil {
			return errors.New("U3.Type_String string content unpack error\n" + err.Error())
		}
		this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	case 14:

		err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
		if err != nil {
			return errors.New("U3.Type_Datetime unpack error\n" + err.Error())
		}

	case 17:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32_Array)
		if err != nil {
			return errors.New("U3.Type_Int32_Array unpack error\n" + err.Error())
		}

	case 19:

		var type_string_arraySize uint32
		err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
		if err != nil {
			return errors.New("U3.Type_String_Array string size unpack error\n" + err.Error())
		}

		type_string_arrayBytes := make([]byte, type_string_arraySize)
		err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
		if err != nil {
			return errors.New("U3.Type_String_Array string content unpack error\n" + err.Error())
		}
		this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	case 24:
		if this.S4 == nil {
			this.S4 = NewS4()
		}

		err = this.S4.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U3.S4 unpack error\n" + err.Error())
		}

	case 25:
		if this.S4_Array == nil {
			this.S4_Array = NewS4()
		}

		err = this.S4_Array.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U3.S4_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	S3BaseVersion    uint32 = 1
	S3CurrentVersion uint32 = 1
)

// S3
type S3 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count uint32 `tdr_field:"array_count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	S4 *S4 `tdr_field:"S4"`

	S4_Array []*S4 `tdr_field:"S4_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	Union_Selector byte `tdr_field:"union_selector"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	U4 *U4 `tdr_field:"U4" tdr_select:"Union_Selector"`

	U4_Array []*U4 `tdr_field:"U4_array" tdr_count:"2" tdr_refer:"Union_Array_Count" tdr_select:"Union_Selector"`
}

func NewS3() *S3 {
	obj := new(S3)
	obj.Init()
	return obj
}

func (this *S3) GetBaseVersion() uint32 {
	return S3BaseVersion
}

func (this *S3) GetCurrentVersion() uint32 {
	return S3CurrentVersion
}

func (this *S3) Init() {

	this.S4 = NewS4()

	this.Union_Selector = 0

	this.U4 = NewU4(int64(this.Union_Selector))

}

func (this *S3) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("S3 Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *S3) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > S3CurrentVersion {
		cutVer = S3CurrentVersion
	}
	// check cut version
	if cutVer < S3BaseVersion {
		return errors.New("S3 cut version must large than S3BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("S3.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("S3.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("S3.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("S3.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("S3.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("S3.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("S3.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S3.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S3.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("S3.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("S3.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("S3.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("S3.Type_String_Array string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("S3.Struct_Array_Count pack error\n" + err.Error())
	}

	err = this.S4.PackTo(cutVer, w)
	if err != nil {
		return errors.New("S3.S4 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S3.S4_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S3.S4_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S4_Array) < int(this.Struct_Array_Count) {
		return errors.New("S3.S4_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S4_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("S3.S4_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("S3.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("S3.Union_Array_Count pack error\n" + err.Error())
	}

	err = this.U4.PackTo(cutVer, w, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S3.U4 pack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S3.U4_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S3.U4_Array's refer Union_Array_Count should <= count 2")
	}
	if len(this.U4_Array) < int(this.Union_Array_Count) {
		return errors.New("S3.U4_Array's length should > Union_Array_Count")
	}
	if this.Union_Array_Count > 0 {
		for i := 0; i < int(this.Union_Array_Count); i++ {
			err = this.U4_Array[i].PackTo(cutVer, w, int64(this.Union_Selector))
			if err != nil {
				return errors.New("S3.U4_Array pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *S3) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("S3 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *S3) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > S3CurrentVersion {
		cutVer = S3CurrentVersion
	}
	// check version
	if cutVer < S3BaseVersion {
		errors.New("S3 cut version must large than S3BaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("S3.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("S3.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("S3.Type_Float unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("S3.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("S3.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("S3.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("S3.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S3.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S3.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("S3.Type_Int32_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("S3.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("S3.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("S3.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = this.S4.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("S3.S4 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S3.S4_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S3.S4_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S4_Array == nil {
		this.S4_Array = make([]*S4, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S4_Array[i] = NewS4()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S4_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("S3.S4_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("S3.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("S3.Union_Array_Count unpack error\n" + err.Error())
	}

	err = this.U4.UnpackFrom(cutVer, r, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S3.U4 unpack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S3.U4_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S3.U4_Array's refer Union_Array_Count should <= count 2")
	}

	if this.U4_Array == nil {
		this.U4_Array = make([]*U4, int(this.Union_Array_Count))
		for i := 0; i < int(this.Union_Array_Count); i++ {
			this.U4_Array[i] = NewU4(int64(this.Union_Selector))
		}
	}

	for i := 0; i < int(this.Union_Array_Count); i++ {
		err = this.U4_Array[i].UnpackFrom(cutVer, r, int64(this.Union_Selector))
		if err != nil {
			return errors.New("S3.U4_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	U2BaseVersion    uint32 = 1
	U2CurrentVersion uint32 = 1
)

// U2
type U2 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Type_Int32_Array int32 `tdr_field:"type_int32_array"`

	Type_String_Array string `tdr_field:"type_string_array"`

	S3 *S3 `tdr_field:"S3"`

	S3_Array *S3 `tdr_field:"S3_array"`
}

func NewU2(selector int64) *U2 {
	obj := new(U2)
	obj.Init(selector)
	return obj
}

func (this *U2) GetBaseVersion() uint32 {
	return U2BaseVersion
}

func (this *U2) GetCurrentVersion() uint32 {
	return U2CurrentVersion
}

func (this *U2) Init(selector int64) {
	switch selector {
	case 1:

	case 5:

	case 9:

	case 12:

	case 14:

	case 17:

	case 19:

	case 24:
		this.S3 = NewS3()

	case 25:
		this.S3_Array = NewS3()

	}
}

func (this *U2) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *U2) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > U2CurrentVersion {
		cutVer = U2CurrentVersion
	}
	// check cut version
	if cutVer < U2BaseVersion {
		return errors.New("U2 cut version must large than U2BaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 1:

		err = binary.Write(w, binary.BigEndian, this.Type_Int8)
		if err != nil {
			return errors.New("U2.Type_Int8 pack error\n" + err.Error())
		}

	case 5:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32)
		if err != nil {
			return errors.New("U2.Type_Int32 pack error\n" + err.Error())
		}

	case 9:

		err = binary.Write(w, binary.BigEndian, this.Type_Float)
		if err != nil {
			return errors.New("U2.Type_Float pack error\n" + err.Error())
		}

	case 12:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
		if err != nil {
			return errors.New("U2.Type_String string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
		if err != nil {
			return errors.New("U2.Type_String string content pack error\n" + err.Error())
		}

	case 14:

		err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
		if err != nil {
			return errors.New("U2.Type_Datetime pack error\n" + err.Error())
		}

	case 17:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32_Array)
		if err != nil {
			return errors.New("U2.Type_Int32_Array pack error\n" + err.Error())
		}

	case 19:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
		if err != nil {
			return errors.New("U2.Type_String_Array string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
		if err != nil {
			return errors.New("U2.Type_String_Array string content pack error\n" + err.Error())
		}

	case 24:
		if this.S3 == nil {
			return errors.New("U2.S3 is nil")
		}

		err = this.S3.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U2.S3 pack error\n" + err.Error())
		}

	case 25:
		if this.S3_Array == nil {
			return errors.New("U2.S3_Array is nil")
		}

		err = this.S3_Array.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U2.S3_Array pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *U2) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("U2 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *U2) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > U2CurrentVersion {
		cutVer = U2CurrentVersion
	}
	// check version
	if cutVer < U2BaseVersion {
		errors.New("U2 cut version must large than U2BaseVersion\n")
	}

	switch selector {
	case 1:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
		if err != nil {
			return errors.New("U2.Type_Int8 unpack error\n" + err.Error())
		}

	case 5:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
		if err != nil {
			return errors.New("U2.Type_Int32 unpack error\n" + err.Error())
		}

	case 9:

		err = binary.Read(r, binary.BigEndian, &this.Type_Float)
		if err != nil {
			return errors.New("U2.Type_Float unpack error\n" + err.Error())
		}

	case 12:

		var type_stringSize uint32
		err = binary.Read(r, binary.BigEndian, &type_stringSize)
		if err != nil {
			return errors.New("U2.Type_String string size unpack error\n" + err.Error())
		}

		type_stringBytes := make([]byte, type_stringSize)
		err = binary.Read(r, binary.BigEndian, type_stringBytes)
		if err != nil {
			return errors.New("U2.Type_String string content unpack error\n" + err.Error())
		}
		this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	case 14:

		err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
		if err != nil {
			return errors.New("U2.Type_Datetime unpack error\n" + err.Error())
		}

	case 17:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32_Array)
		if err != nil {
			return errors.New("U2.Type_Int32_Array unpack error\n" + err.Error())
		}

	case 19:

		var type_string_arraySize uint32
		err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
		if err != nil {
			return errors.New("U2.Type_String_Array string size unpack error\n" + err.Error())
		}

		type_string_arrayBytes := make([]byte, type_string_arraySize)
		err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
		if err != nil {
			return errors.New("U2.Type_String_Array string content unpack error\n" + err.Error())
		}
		this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	case 24:
		if this.S3 == nil {
			this.S3 = NewS3()
		}

		err = this.S3.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U2.S3 unpack error\n" + err.Error())
		}

	case 25:
		if this.S3_Array == nil {
			this.S3_Array = NewS3()
		}

		err = this.S3_Array.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U2.S3_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	S2BaseVersion    uint32 = 1
	S2CurrentVersion uint32 = 1
)

// S2
type S2 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count uint32 `tdr_field:"array_count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	S3 *S3 `tdr_field:"S3"`

	S3_Array []*S3 `tdr_field:"S3_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	Union_Selector byte `tdr_field:"union_selector"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	U3 *U3 `tdr_field:"U3" tdr_select:"Union_Selector"`

	U3_Array []*U3 `tdr_field:"U3_array" tdr_count:"2" tdr_refer:"Union_Array_Count" tdr_select:"Union_Selector"`
}

func NewS2() *S2 {
	obj := new(S2)
	obj.Init()
	return obj
}

func (this *S2) GetBaseVersion() uint32 {
	return S2BaseVersion
}

func (this *S2) GetCurrentVersion() uint32 {
	return S2CurrentVersion
}

func (this *S2) Init() {

	this.S3 = NewS3()

	this.Union_Selector = 0

	this.U3 = NewU3(int64(this.Union_Selector))

}

func (this *S2) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("S2 Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *S2) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > S2CurrentVersion {
		cutVer = S2CurrentVersion
	}
	// check cut version
	if cutVer < S2BaseVersion {
		return errors.New("S2 cut version must large than S2BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("S2.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("S2.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("S2.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("S2.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("S2.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("S2.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("S2.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S2.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S2.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("S2.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("S2.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("S2.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("S2.Type_String_Array string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("S2.Struct_Array_Count pack error\n" + err.Error())
	}

	err = this.S3.PackTo(cutVer, w)
	if err != nil {
		return errors.New("S2.S3 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S2.S3_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S2.S3_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S3_Array) < int(this.Struct_Array_Count) {
		return errors.New("S2.S3_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S3_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("S2.S3_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("S2.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("S2.Union_Array_Count pack error\n" + err.Error())
	}

	err = this.U3.PackTo(cutVer, w, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S2.U3 pack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S2.U3_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S2.U3_Array's refer Union_Array_Count should <= count 2")
	}
	if len(this.U3_Array) < int(this.Union_Array_Count) {
		return errors.New("S2.U3_Array's length should > Union_Array_Count")
	}
	if this.Union_Array_Count > 0 {
		for i := 0; i < int(this.Union_Array_Count); i++ {
			err = this.U3_Array[i].PackTo(cutVer, w, int64(this.Union_Selector))
			if err != nil {
				return errors.New("S2.U3_Array pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *S2) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("S2 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *S2) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > S2CurrentVersion {
		cutVer = S2CurrentVersion
	}
	// check version
	if cutVer < S2BaseVersion {
		errors.New("S2 cut version must large than S2BaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("S2.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("S2.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("S2.Type_Float unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("S2.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("S2.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("S2.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("S2.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S2.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S2.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("S2.Type_Int32_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("S2.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("S2.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("S2.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = this.S3.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("S2.S3 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S2.S3_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S2.S3_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S3_Array == nil {
		this.S3_Array = make([]*S3, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S3_Array[i] = NewS3()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S3_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("S2.S3_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("S2.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("S2.Union_Array_Count unpack error\n" + err.Error())
	}

	err = this.U3.UnpackFrom(cutVer, r, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S2.U3 unpack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S2.U3_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S2.U3_Array's refer Union_Array_Count should <= count 2")
	}

	if this.U3_Array == nil {
		this.U3_Array = make([]*U3, int(this.Union_Array_Count))
		for i := 0; i < int(this.Union_Array_Count); i++ {
			this.U3_Array[i] = NewU3(int64(this.Union_Selector))
		}
	}

	for i := 0; i < int(this.Union_Array_Count); i++ {
		err = this.U3_Array[i].UnpackFrom(cutVer, r, int64(this.Union_Selector))
		if err != nil {
			return errors.New("S2.U3_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	S1BaseVersion    uint32 = 1
	S1CurrentVersion uint32 = 1
)

// S1
type S1 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count uint32 `tdr_field:"array_count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	S2 *S2 `tdr_field:"S2"`

	S2_Array []*S2 `tdr_field:"S2_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	Union_Selector byte `tdr_field:"union_selector"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	U2 *U2 `tdr_field:"U2" tdr_select:"Union_Selector"`

	U2_Array []*U2 `tdr_field:"U2_array" tdr_count:"2" tdr_refer:"Union_Array_Count" tdr_select:"Union_Selector"`
}

func NewS1() *S1 {
	obj := new(S1)
	obj.Init()
	return obj
}

func (this *S1) GetBaseVersion() uint32 {
	return S1BaseVersion
}

func (this *S1) GetCurrentVersion() uint32 {
	return S1CurrentVersion
}

func (this *S1) Init() {

	this.S2 = NewS2()

	this.Union_Selector = 0

	this.U2 = NewU2(int64(this.Union_Selector))

}

func (this *S1) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("S1 Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *S1) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > S1CurrentVersion {
		cutVer = S1CurrentVersion
	}
	// check cut version
	if cutVer < S1BaseVersion {
		return errors.New("S1 cut version must large than S1BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("S1.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("S1.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("S1.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("S1.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("S1.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("S1.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("S1.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S1.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S1.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("S1.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("S1.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("S1.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("S1.Type_String_Array string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("S1.Struct_Array_Count pack error\n" + err.Error())
	}

	err = this.S2.PackTo(cutVer, w)
	if err != nil {
		return errors.New("S1.S2 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S1.S2_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S1.S2_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S2_Array) < int(this.Struct_Array_Count) {
		return errors.New("S1.S2_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S2_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("S1.S2_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("S1.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("S1.Union_Array_Count pack error\n" + err.Error())
	}

	err = this.U2.PackTo(cutVer, w, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S1.U2 pack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S1.U2_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S1.U2_Array's refer Union_Array_Count should <= count 2")
	}
	if len(this.U2_Array) < int(this.Union_Array_Count) {
		return errors.New("S1.U2_Array's length should > Union_Array_Count")
	}
	if this.Union_Array_Count > 0 {
		for i := 0; i < int(this.Union_Array_Count); i++ {
			err = this.U2_Array[i].PackTo(cutVer, w, int64(this.Union_Selector))
			if err != nil {
				return errors.New("S1.U2_Array pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *S1) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("S1 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *S1) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > S1CurrentVersion {
		cutVer = S1CurrentVersion
	}
	// check version
	if cutVer < S1BaseVersion {
		errors.New("S1 cut version must large than S1BaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("S1.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("S1.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("S1.Type_Float unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("S1.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("S1.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("S1.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("S1.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S1.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S1.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("S1.Type_Int32_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("S1.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("S1.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("S1.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = this.S2.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("S1.S2 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S1.S2_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S1.S2_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S2_Array == nil {
		this.S2_Array = make([]*S2, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S2_Array[i] = NewS2()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S2_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("S1.S2_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("S1.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("S1.Union_Array_Count unpack error\n" + err.Error())
	}

	err = this.U2.UnpackFrom(cutVer, r, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S1.U2 unpack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S1.U2_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S1.U2_Array's refer Union_Array_Count should <= count 2")
	}

	if this.U2_Array == nil {
		this.U2_Array = make([]*U2, int(this.Union_Array_Count))
		for i := 0; i < int(this.Union_Array_Count); i++ {
			this.U2_Array[i] = NewU2(int64(this.Union_Selector))
		}
	}

	for i := 0; i < int(this.Union_Array_Count); i++ {
		err = this.U2_Array[i].UnpackFrom(cutVer, r, int64(this.Union_Selector))
		if err != nil {
			return errors.New("S1.U2_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	U1BaseVersion    uint32 = 1
	U1CurrentVersion uint32 = 1
)

// U1
type U1 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Type_Int32_Array int32 `tdr_field:"type_int32_array"`

	Type_String_Array string `tdr_field:"type_string_array"`

	S2 *S2 `tdr_field:"S2"`

	S2_Array *S2 `tdr_field:"S2_array"`
}

func NewU1(selector int64) *U1 {
	obj := new(U1)
	obj.Init(selector)
	return obj
}

func (this *U1) GetBaseVersion() uint32 {
	return U1BaseVersion
}

func (this *U1) GetCurrentVersion() uint32 {
	return U1CurrentVersion
}

func (this *U1) Init(selector int64) {
	switch selector {
	case 1:

	case 5:

	case 9:

	case 12:

	case 14:

	case 17:

	case 19:

	case 24:
		this.S2 = NewS2()

	case 115:
		this.S2_Array = NewS2()

	}
}

func (this *U1) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *U1) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > U1CurrentVersion {
		cutVer = U1CurrentVersion
	}
	// check cut version
	if cutVer < U1BaseVersion {
		return errors.New("U1 cut version must large than U1BaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 1:

		err = binary.Write(w, binary.BigEndian, this.Type_Int8)
		if err != nil {
			return errors.New("U1.Type_Int8 pack error\n" + err.Error())
		}

	case 5:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32)
		if err != nil {
			return errors.New("U1.Type_Int32 pack error\n" + err.Error())
		}

	case 9:

		err = binary.Write(w, binary.BigEndian, this.Type_Float)
		if err != nil {
			return errors.New("U1.Type_Float pack error\n" + err.Error())
		}

	case 12:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
		if err != nil {
			return errors.New("U1.Type_String string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
		if err != nil {
			return errors.New("U1.Type_String string content pack error\n" + err.Error())
		}

	case 14:

		err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
		if err != nil {
			return errors.New("U1.Type_Datetime pack error\n" + err.Error())
		}

	case 17:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32_Array)
		if err != nil {
			return errors.New("U1.Type_Int32_Array pack error\n" + err.Error())
		}

	case 19:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
		if err != nil {
			return errors.New("U1.Type_String_Array string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
		if err != nil {
			return errors.New("U1.Type_String_Array string content pack error\n" + err.Error())
		}

	case 24:
		if this.S2 == nil {
			return errors.New("U1.S2 is nil")
		}

		err = this.S2.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U1.S2 pack error\n" + err.Error())
		}

	case 115:
		if this.S2_Array == nil {
			return errors.New("U1.S2_Array is nil")
		}

		err = this.S2_Array.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U1.S2_Array pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *U1) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("U1 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *U1) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > U1CurrentVersion {
		cutVer = U1CurrentVersion
	}
	// check version
	if cutVer < U1BaseVersion {
		errors.New("U1 cut version must large than U1BaseVersion\n")
	}

	switch selector {
	case 1:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
		if err != nil {
			return errors.New("U1.Type_Int8 unpack error\n" + err.Error())
		}

	case 5:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
		if err != nil {
			return errors.New("U1.Type_Int32 unpack error\n" + err.Error())
		}

	case 9:

		err = binary.Read(r, binary.BigEndian, &this.Type_Float)
		if err != nil {
			return errors.New("U1.Type_Float unpack error\n" + err.Error())
		}

	case 12:

		var type_stringSize uint32
		err = binary.Read(r, binary.BigEndian, &type_stringSize)
		if err != nil {
			return errors.New("U1.Type_String string size unpack error\n" + err.Error())
		}

		type_stringBytes := make([]byte, type_stringSize)
		err = binary.Read(r, binary.BigEndian, type_stringBytes)
		if err != nil {
			return errors.New("U1.Type_String string content unpack error\n" + err.Error())
		}
		this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	case 14:

		err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
		if err != nil {
			return errors.New("U1.Type_Datetime unpack error\n" + err.Error())
		}

	case 17:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32_Array)
		if err != nil {
			return errors.New("U1.Type_Int32_Array unpack error\n" + err.Error())
		}

	case 19:

		var type_string_arraySize uint32
		err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
		if err != nil {
			return errors.New("U1.Type_String_Array string size unpack error\n" + err.Error())
		}

		type_string_arrayBytes := make([]byte, type_string_arraySize)
		err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
		if err != nil {
			return errors.New("U1.Type_String_Array string content unpack error\n" + err.Error())
		}
		this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	case 24:
		if this.S2 == nil {
			this.S2 = NewS2()
		}

		err = this.S2.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U1.S2 unpack error\n" + err.Error())
		}

	case 115:
		if this.S2_Array == nil {
			this.S2_Array = NewS2()
		}

		err = this.S2_Array.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U1.S2_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	S0BaseVersion    uint32 = 1
	S0CurrentVersion uint32 = 1
)

// S0
type S0 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Union_Selector byte `tdr_field:"union_selector"`

	Array_Count uint32 `tdr_field:"array_count"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	S1 *S1 `tdr_field:"S1"`

	S1_Array []*S1 `tdr_field:"S1_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	U1 *U1 `tdr_field:"U1" tdr_select:"Union_Selector"`

	U1_Array []*U1 `tdr_field:"U1_array" tdr_count:"2" tdr_refer:"Union_Array_Count" tdr_select:"Union_Selector"`
}

func NewS0() *S0 {
	obj := new(S0)
	obj.Init()
	return obj
}

func (this *S0) GetBaseVersion() uint32 {
	return S0BaseVersion
}

func (this *S0) GetCurrentVersion() uint32 {
	return S0CurrentVersion
}

func (this *S0) Init() {

	this.Union_Selector = 0

	this.S1 = NewS1()

	this.U1 = NewU1(int64(this.Union_Selector))

}

func (this *S0) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("S0 Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *S0) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > S0CurrentVersion {
		cutVer = S0CurrentVersion
	}
	// check cut version
	if cutVer < S0BaseVersion {
		return errors.New("S0 cut version must large than S0BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("S0.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("S0.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("S0.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("S0.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("S0.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("S0.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("S0.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("S0.Array_Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("S0.Struct_Array_Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("S0.Union_Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S0.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S0.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("S0.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("S0.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("S0.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("S0.Type_String_Array string content pack error\n" + err.Error())
	}

	err = this.S1.PackTo(cutVer, w)
	if err != nil {
		return errors.New("S0.S1 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S0.S1_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S0.S1_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S1_Array) < int(this.Struct_Array_Count) {
		return errors.New("S0.S1_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S1_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("S0.S1_Array pack error\n" + err.Error())
			}

		}
	}

	err = this.U1.PackTo(cutVer, w, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S0.U1 pack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S0.U1_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S0.U1_Array's refer Union_Array_Count should <= count 2")
	}
	if len(this.U1_Array) < int(this.Union_Array_Count) {
		return errors.New("S0.U1_Array's length should > Union_Array_Count")
	}
	if this.Union_Array_Count > 0 {
		for i := 0; i < int(this.Union_Array_Count); i++ {
			err = this.U1_Array[i].PackTo(cutVer, w, int64(this.Union_Selector))
			if err != nil {
				return errors.New("S0.U1_Array pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *S0) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("S0 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *S0) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > S0CurrentVersion {
		cutVer = S0CurrentVersion
	}
	// check version
	if cutVer < S0BaseVersion {
		errors.New("S0 cut version must large than S0BaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("S0.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("S0.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("S0.Type_Float unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("S0.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("S0.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("S0.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("S0.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("S0.Array_Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("S0.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("S0.Union_Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("S0.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("S0.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("S0.Type_Int32_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("S0.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("S0.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	err = this.S1.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("S0.S1 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("S0.S1_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("S0.S1_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S1_Array == nil {
		this.S1_Array = make([]*S1, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S1_Array[i] = NewS1()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S1_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("S0.S1_Array unpack error\n" + err.Error())
		}

	}

	err = this.U1.UnpackFrom(cutVer, r, int64(this.Union_Selector))
	if err != nil {
		return errors.New("S0.U1 unpack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("S0.U1_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("S0.U1_Array's refer Union_Array_Count should <= count 2")
	}

	if this.U1_Array == nil {
		this.U1_Array = make([]*U1, int(this.Union_Array_Count))
		for i := 0; i < int(this.Union_Array_Count); i++ {
			this.U1_Array[i] = NewU1(int64(this.Union_Selector))
		}
	}

	for i := 0; i < int(this.Union_Array_Count); i++ {
		err = this.U1_Array[i].UnpackFrom(cutVer, r, int64(this.Union_Selector))
		if err != nil {
			return errors.New("S0.U1_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	U0BaseVersion    uint32 = 1
	U0CurrentVersion uint32 = 1
)

// U0
type U0 struct {
	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_String string `tdr_field:"type_string"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Type_Int32_Array int32 `tdr_field:"type_int32_array"`

	Type_String_Array string `tdr_field:"type_string_array"`

	S1 *S1 `tdr_field:"S1"`

	S1_Array *S1 `tdr_field:"S1_array"`
}

func NewU0(selector int64) *U0 {
	obj := new(U0)
	obj.Init(selector)
	return obj
}

func (this *U0) GetBaseVersion() uint32 {
	return U0BaseVersion
}

func (this *U0) GetCurrentVersion() uint32 {
	return U0CurrentVersion
}

func (this *U0) Init(selector int64) {
	switch selector {
	case 1:

	case 5:

	case 9:

	case 12:

	case 14:

	case 17:

	case 19:

	case 24:
		this.S1 = NewS1()

	case 25:
		this.S1_Array = NewS1()

	}
}

func (this *U0) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *U0) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > U0CurrentVersion {
		cutVer = U0CurrentVersion
	}
	// check cut version
	if cutVer < U0BaseVersion {
		return errors.New("U0 cut version must large than U0BaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 1:

		err = binary.Write(w, binary.BigEndian, this.Type_Int8)
		if err != nil {
			return errors.New("U0.Type_Int8 pack error\n" + err.Error())
		}

	case 5:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32)
		if err != nil {
			return errors.New("U0.Type_Int32 pack error\n" + err.Error())
		}

	case 9:

		err = binary.Write(w, binary.BigEndian, this.Type_Float)
		if err != nil {
			return errors.New("U0.Type_Float pack error\n" + err.Error())
		}

	case 12:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
		if err != nil {
			return errors.New("U0.Type_String string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
		if err != nil {
			return errors.New("U0.Type_String string content pack error\n" + err.Error())
		}

	case 14:

		err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
		if err != nil {
			return errors.New("U0.Type_Datetime pack error\n" + err.Error())
		}

	case 17:

		err = binary.Write(w, binary.BigEndian, this.Type_Int32_Array)
		if err != nil {
			return errors.New("U0.Type_Int32_Array pack error\n" + err.Error())
		}

	case 19:

		err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
		if err != nil {
			return errors.New("U0.Type_String_Array string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
		if err != nil {
			return errors.New("U0.Type_String_Array string content pack error\n" + err.Error())
		}

	case 24:
		if this.S1 == nil {
			return errors.New("U0.S1 is nil")
		}

		err = this.S1.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U0.S1 pack error\n" + err.Error())
		}

	case 25:
		if this.S1_Array == nil {
			return errors.New("U0.S1_Array is nil")
		}

		err = this.S1_Array.PackTo(cutVer, w)
		if err != nil {
			return errors.New("U0.S1_Array pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *U0) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("U0 data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *U0) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > U0CurrentVersion {
		cutVer = U0CurrentVersion
	}
	// check version
	if cutVer < U0BaseVersion {
		errors.New("U0 cut version must large than U0BaseVersion\n")
	}

	switch selector {
	case 1:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
		if err != nil {
			return errors.New("U0.Type_Int8 unpack error\n" + err.Error())
		}

	case 5:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
		if err != nil {
			return errors.New("U0.Type_Int32 unpack error\n" + err.Error())
		}

	case 9:

		err = binary.Read(r, binary.BigEndian, &this.Type_Float)
		if err != nil {
			return errors.New("U0.Type_Float unpack error\n" + err.Error())
		}

	case 12:

		var type_stringSize uint32
		err = binary.Read(r, binary.BigEndian, &type_stringSize)
		if err != nil {
			return errors.New("U0.Type_String string size unpack error\n" + err.Error())
		}

		type_stringBytes := make([]byte, type_stringSize)
		err = binary.Read(r, binary.BigEndian, type_stringBytes)
		if err != nil {
			return errors.New("U0.Type_String string content unpack error\n" + err.Error())
		}
		this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	case 14:

		err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
		if err != nil {
			return errors.New("U0.Type_Datetime unpack error\n" + err.Error())
		}

	case 17:

		err = binary.Read(r, binary.BigEndian, &this.Type_Int32_Array)
		if err != nil {
			return errors.New("U0.Type_Int32_Array unpack error\n" + err.Error())
		}

	case 19:

		var type_string_arraySize uint32
		err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
		if err != nil {
			return errors.New("U0.Type_String_Array string size unpack error\n" + err.Error())
		}

		type_string_arrayBytes := make([]byte, type_string_arraySize)
		err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
		if err != nil {
			return errors.New("U0.Type_String_Array string content unpack error\n" + err.Error())
		}
		this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	case 24:
		if this.S1 == nil {
			this.S1 = NewS1()
		}

		err = this.S1.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U0.S1 unpack error\n" + err.Error())
		}

	case 25:
		if this.S1_Array == nil {
			this.S1_Array = NewS1()
		}

		err = this.S1_Array.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("U0.S1_Array unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	Table_Generic_ComplexBaseVersion    uint32 = 1
	Table_Generic_ComplexCurrentVersion uint32 = 1
)

var Table_Generic_ComplexDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin,Name,Key3,Key4",
	Index2Column: map[string]string{
		"Index2": "Uin, Name",
		"Index1": "Uin",
	},
}

// Table_Generic_Complex
type Table_Generic_Complex struct {
	Uin uint64 `tdr_field:"uin"`

	Name string `tdr_field:"name"`

	Key3 string `tdr_field:"key3"`

	Key4 string `tdr_field:"key4"`

	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Uint8 byte `tdr_field:"type_uint8"`

	Type_Int16 int16 `tdr_field:"type_int16"`

	Type_Uint16 uint16 `tdr_field:"type_uint16"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Uint32 uint32 `tdr_field:"type_uint32"`

	Type_Int64 int64 `tdr_field:"type_int64"`

	Type_Uint64 uint64 `tdr_field:"type_uint64"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_Double float64 `tdr_field:"type_double"`

	Type_Short int16 `tdr_field:"type_short"`

	Type_String string `tdr_field:"type_string"`

	Type_Tinyint int8 `tdr_field:"type_tinyint"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count uint32 `tdr_field:"array_count"`

	Type_Int8_Array []int8 `tdr_field:"type_int8_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int16_Array []int16 `tdr_field:"type_int16_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int64_Array []int64 `tdr_field:"type_int64_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	Type_Uint8_Array []byte `tdr_field:"type_uint8_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint16_Array []uint16 `tdr_field:"type_uint16_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint32_Array []uint32 `tdr_field:"type_uint32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint64_Array []uint64 `tdr_field:"type_uint64_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	S0 *S0 `tdr_field:"S0"`

	S0_Array []*S0 `tdr_field:"S0_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	Union_Selector byte `tdr_field:"union_selector"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	U0 *U0 `tdr_field:"U0" tdr_select:"Union_Selector"`

	U0_Array []*U0 `tdr_field:"U0_array" tdr_count:"2" tdr_refer:"Union_Array_Count" tdr_select:"Union_Selector"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`
}

func NewTable_Generic_Complex() *Table_Generic_Complex {
	obj := new(Table_Generic_Complex)
	obj.Init()
	return obj
}

func (this *Table_Generic_Complex) GetBaseVersion() uint32 {
	return Table_Generic_ComplexBaseVersion
}

func (this *Table_Generic_Complex) GetCurrentVersion() uint32 {
	return Table_Generic_ComplexCurrentVersion
}

func (this *Table_Generic_Complex) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Generic_ComplexDBFeilds
}

func (this *Table_Generic_Complex) Init() {

	this.S0 = NewS0()

	this.Union_Selector = 0

	this.U0 = NewU0(int64(this.Union_Selector))

}

func (this *Table_Generic_Complex) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Generic_Complex Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Generic_Complex) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Generic_ComplexCurrentVersion {
		cutVer = Table_Generic_ComplexCurrentVersion
	}
	// check cut version
	if cutVer < Table_Generic_ComplexBaseVersion {
		return errors.New("Table_Generic_Complex cut version must large than Table_Generic_ComplexBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_Generic_Complex.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_Generic_Complex.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_Generic_Complex.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key3))+1)
	if err != nil {
		return errors.New("Table_Generic_Complex.Key3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key3), 0))
	if err != nil {
		return errors.New("Table_Generic_Complex.Key3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key4))+1)
	if err != nil {
		return errors.New("Table_Generic_Complex.Key4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key4), 0))
	if err != nil {
		return errors.New("Table_Generic_Complex.Key4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint8)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int16)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint16)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint32)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int64)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint64)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Double)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Short)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Short pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Tinyint pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("Table_Generic_Complex.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int8_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int8_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Int8_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int8_Array := this.Type_Int8_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int8_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Int8_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int16_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int16_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Int16_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int16_Array := this.Type_Int16_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int16_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Int16_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int64_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int64_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Int64_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int64_Array := this.Type_Int64_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int64_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Int64_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String_Array string content pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint8_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint8_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Uint8_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint8_Array := this.Type_Uint8_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint8_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Uint8_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint16_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint16_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Uint16_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint16_Array := this.Type_Uint16_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint16_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Uint16_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint32_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Uint32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint32_Array := this.Type_Uint32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint32_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Uint32_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint64_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint64_Array) < int(this.Array_Count) {
		return errors.New("Table_Generic_Complex.Type_Uint64_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint64_Array := this.Type_Uint64_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint64_Array)
		if err != nil {
			return errors.New("Table_Generic_Complex.Type_Uint64_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("Table_Generic_Complex.Struct_Array_Count pack error\n" + err.Error())
	}

	err = this.S0.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_Generic_Complex.S0 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("Table_Generic_Complex.S0_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("Table_Generic_Complex.S0_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S0_Array) < int(this.Struct_Array_Count) {
		return errors.New("Table_Generic_Complex.S0_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S0_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_Generic_Complex.S0_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("Table_Generic_Complex.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("Table_Generic_Complex.Union_Array_Count pack error\n" + err.Error())
	}

	err = this.U0.PackTo(cutVer, w, int64(this.Union_Selector))
	if err != nil {
		return errors.New("Table_Generic_Complex.U0 pack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("Table_Generic_Complex.U0_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("Table_Generic_Complex.U0_Array's refer Union_Array_Count should <= count 2")
	}
	if len(this.U0_Array) < int(this.Union_Array_Count) {
		return errors.New("Table_Generic_Complex.U0_Array's length should > Union_Array_Count")
	}
	if this.Union_Array_Count > 0 {
		for i := 0; i < int(this.Union_Array_Count); i++ {
			err = this.U0_Array[i].PackTo(cutVer, w, int64(this.Union_Selector))
			if err != nil {
				return errors.New("Table_Generic_Complex.U0_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_Complex.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Generic_Complex) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Generic_Complex data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Generic_Complex) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Generic_ComplexCurrentVersion {
		cutVer = Table_Generic_ComplexCurrentVersion
	}
	// check version
	if cutVer < Table_Generic_ComplexBaseVersion {
		errors.New("Table_Generic_Complex cut version must large than Table_Generic_ComplexBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_Generic_Complex.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_Generic_Complex.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_Generic_Complex.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	var key3Size uint32
	err = binary.Read(r, binary.BigEndian, &key3Size)
	if err != nil {
		return errors.New("Table_Generic_Complex.Key3 string size unpack error\n" + err.Error())
	}

	key3Bytes := make([]byte, key3Size)
	err = binary.Read(r, binary.BigEndian, key3Bytes)
	if err != nil {
		return errors.New("Table_Generic_Complex.Key3 string content unpack error\n" + err.Error())
	}
	this.Key3 = string(key3Bytes[:len(key3Bytes)-1])

	var key4Size uint32
	err = binary.Read(r, binary.BigEndian, &key4Size)
	if err != nil {
		return errors.New("Table_Generic_Complex.Key4 string size unpack error\n" + err.Error())
	}

	key4Bytes := make([]byte, key4Size)
	err = binary.Read(r, binary.BigEndian, key4Bytes)
	if err != nil {
		return errors.New("Table_Generic_Complex.Key4 string content unpack error\n" + err.Error())
	}
	this.Key4 = string(key4Bytes[:len(key4Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint8)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int16)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint16)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint32)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int64)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint64)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Double)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Double unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Short)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Short unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Tinyint unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("Table_Generic_Complex.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int8_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int8_Array == nil {
		this.Type_Int8_Array = make([]int8, int(this.Array_Count))
	}

	referType_Int8_Array := this.Type_Int8_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int8_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int8_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int16_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int16_Array == nil {
		this.Type_Int16_Array = make([]int16, int(this.Array_Count))
	}

	referType_Int16_Array := this.Type_Int16_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int16_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int16_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int32_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Int64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Int64_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int64_Array == nil {
		this.Type_Int64_Array = make([]int64, int(this.Array_Count))
	}

	referType_Int64_Array := this.Type_Int64_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int64_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Int64_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint8_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint8_Array == nil {
		this.Type_Uint8_Array = make([]byte, int(this.Array_Count))
	}

	referType_Uint8_Array := this.Type_Uint8_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint8_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint8_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint16_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint16_Array == nil {
		this.Type_Uint16_Array = make([]uint16, int(this.Array_Count))
	}

	referType_Uint16_Array := this.Type_Uint16_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint16_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint16_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint32_Array == nil {
		this.Type_Uint32_Array = make([]uint32, int(this.Array_Count))
	}

	referType_Uint32_Array := this.Type_Uint32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint32_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint32_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_Generic_Complex.Type_Uint64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_Generic_Complex.Type_Uint64_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint64_Array == nil {
		this.Type_Uint64_Array = make([]uint64, int(this.Array_Count))
	}

	referType_Uint64_Array := this.Type_Uint64_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint64_Array)
	if err != nil {
		return errors.New("Table_Generic_Complex.Type_Uint64_Array pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("Table_Generic_Complex.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = this.S0.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_Generic_Complex.S0 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("Table_Generic_Complex.S0_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("Table_Generic_Complex.S0_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S0_Array == nil {
		this.S0_Array = make([]*S0, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S0_Array[i] = NewS0()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S0_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_Generic_Complex.S0_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("Table_Generic_Complex.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("Table_Generic_Complex.Union_Array_Count unpack error\n" + err.Error())
	}

	err = this.U0.UnpackFrom(cutVer, r, int64(this.Union_Selector))
	if err != nil {
		return errors.New("Table_Generic_Complex.U0 unpack error\n" + err.Error())
	}

	if this.Union_Array_Count < 0 {
		return errors.New("Table_Generic_Complex.U0_Array's refer Union_Array_Count should >= 0")
	}
	if this.Union_Array_Count > 2 {
		return errors.New("Table_Generic_Complex.U0_Array's refer Union_Array_Count should <= count 2")
	}

	if this.U0_Array == nil {
		this.U0_Array = make([]*U0, int(this.Union_Array_Count))
		for i := 0; i < int(this.Union_Array_Count); i++ {
			this.U0_Array[i] = NewU0(int64(this.Union_Selector))
		}
	}

	for i := 0; i < int(this.Union_Array_Count); i++ {
		err = this.U0_Array[i].UnpackFrom(cutVer, r, int64(this.Union_Selector))
		if err != nil {
			return errors.New("Table_Generic_Complex.U0_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_Complex.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	return err
}

const (
	Table_Generic_CorouteBaseVersion    uint32 = 1
	Table_Generic_CorouteCurrentVersion uint32 = 1
)

var Table_Generic_CorouteDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin",
	Index2Column: map[string]string{
		"Index1": "Uin",
	},
}

// Table_Generic_Coroute
type Table_Generic_Coroute struct {
	Uin int32 `tdr_field:"uin"`

	Qq uint32 `tdr_field:"qq"`

	C_Int8 int8 `tdr_field:"c_int8"`

	C_Uint8 byte `tdr_field:"c_uint8"`

	C_Int16 int16 `tdr_field:"c_int16"`

	C_Uint16 uint16 `tdr_field:"c_uint16"`

	C_Int32 int32 `tdr_field:"c_int32"`

	C_Uint32 uint32 `tdr_field:"c_uint32"`

	C_Int64 int64 `tdr_field:"c_int64"`

	C_Uint64 uint64 `tdr_field:"c_uint64"`

	C_Float float32 `tdr_field:"c_float"`

	C_Double float64 `tdr_field:"c_double"`

	C_String string `tdr_field:"c_string"`

	C_Binary []int8 `tdr_field:"c_binary" tdr_count:"255" tdr_refer:"C_Uint8"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`
}

func NewTable_Generic_Coroute() *Table_Generic_Coroute {
	obj := new(Table_Generic_Coroute)
	obj.Init()
	return obj
}

func (this *Table_Generic_Coroute) GetBaseVersion() uint32 {
	return Table_Generic_CorouteBaseVersion
}

func (this *Table_Generic_Coroute) GetCurrentVersion() uint32 {
	return Table_Generic_CorouteCurrentVersion
}

func (this *Table_Generic_Coroute) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Generic_CorouteDBFeilds
}

func (this *Table_Generic_Coroute) Init() {

	this.C_Int8 = -1

	this.C_Uint8 = 2

	this.C_Int16 = -3

	this.C_Uint16 = 4

	this.C_Int32 = -5

	this.C_Uint32 = 6

	this.C_Int64 = -7

	this.C_Uint64 = 8

	this.C_Float = 9.9919999

	this.C_Double = 10.9991999

	this.C_String = "123456789"

}

func (this *Table_Generic_Coroute) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Generic_Coroute Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Generic_Coroute) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Generic_CorouteCurrentVersion {
		cutVer = Table_Generic_CorouteCurrentVersion
	}
	// check cut version
	if cutVer < Table_Generic_CorouteBaseVersion {
		return errors.New("Table_Generic_Coroute cut version must large than Table_Generic_CorouteBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_Generic_Coroute.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Qq)
	if err != nil {
		return errors.New("Table_Generic_Coroute.Qq pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int8)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint8)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int16)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint16)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int32)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint32)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int64)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint64)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Float)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Double)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.C_String))+1)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.C_String), 0))
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_String string content pack error\n" + err.Error())
	}

	if this.C_Uint8 < 0 {
		return errors.New("Table_Generic_Coroute.C_Binary's refer C_Uint8 should >= 0")
	}
	if this.C_Uint8 > 255 {
		return errors.New("Table_Generic_Coroute.C_Binary's refer C_Uint8 should <= count 255")
	}
	if len(this.C_Binary) < int(this.C_Uint8) {
		return errors.New("Table_Generic_Coroute.C_Binary's length should > C_Uint8")
	}
	if this.C_Uint8 > 0 {
		referC_Binary := this.C_Binary[:this.C_Uint8]
		err = binary.Write(w, binary.BigEndian, referC_Binary)
		if err != nil {
			return errors.New("Table_Generic_Coroute.C_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_Coroute.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Generic_Coroute) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Generic_Coroute data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Generic_Coroute) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Generic_CorouteCurrentVersion {
		cutVer = Table_Generic_CorouteCurrentVersion
	}
	// check version
	if cutVer < Table_Generic_CorouteBaseVersion {
		errors.New("Table_Generic_Coroute cut version must large than Table_Generic_CorouteBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_Generic_Coroute.Uin unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Qq)
	if err != nil {
		return errors.New("Table_Generic_Coroute.Qq unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int8)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint8)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int16)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint16)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int32)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint32)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int64)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint64)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Float)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Double)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Double unpack error\n" + err.Error())
	}

	var c_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &c_stringSize)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_String string size unpack error\n" + err.Error())
	}

	c_stringBytes := make([]byte, c_stringSize)
	err = binary.Read(r, binary.BigEndian, c_stringBytes)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_String string content unpack error\n" + err.Error())
	}
	this.C_String = string(c_stringBytes[:len(c_stringBytes)-1])

	if this.C_Uint8 < 0 {
		return errors.New("Table_Generic_Coroute.C_Binary's refer C_Uint8 should >= 0")
	}
	if this.C_Uint8 > 255 {
		return errors.New("Table_Generic_Coroute.C_Binary's refer C_Uint8 should <= count 255")
	}

	if this.C_Binary == nil {
		this.C_Binary = make([]int8, int(this.C_Uint8))
	}

	referC_Binary := this.C_Binary[:this.C_Uint8]
	err = binary.Read(r, binary.BigEndian, referC_Binary)
	if err != nil {
		return errors.New("Table_Generic_Coroute.C_Binary pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_Generic_Coroute.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	return err
}

const (
	Table_Traverser_GenericBaseVersion    uint32 = 5
	Table_Traverser_GenericCurrentVersion uint32 = 5
)

var Table_Traverser_GenericDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Key, Name",
}

// Table_Traverser_Generic
type Table_Traverser_Generic struct {
	Key uint32 `tdr_field:"key"`

	Name int16 `tdr_field:"name"`

	Level uint32 `tdr_field:"level"`

	Value1 string `tdr_field:"value1"`

	Value2 string `tdr_field:"value2"`
}

func NewTable_Traverser_Generic() *Table_Traverser_Generic {
	obj := new(Table_Traverser_Generic)
	obj.Init()
	return obj
}

func (this *Table_Traverser_Generic) GetBaseVersion() uint32 {
	return Table_Traverser_GenericBaseVersion
}

func (this *Table_Traverser_Generic) GetCurrentVersion() uint32 {
	return Table_Traverser_GenericCurrentVersion
}

func (this *Table_Traverser_Generic) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Traverser_GenericDBFeilds
}

func (this *Table_Traverser_Generic) Init() {

}

func (this *Table_Traverser_Generic) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Traverser_Generic Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Traverser_Generic) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Traverser_GenericCurrentVersion {
		cutVer = Table_Traverser_GenericCurrentVersion
	}
	// check cut version
	if cutVer < Table_Traverser_GenericBaseVersion {
		return errors.New("Table_Traverser_Generic cut version must large than Table_Traverser_GenericBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Key)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Key pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Name)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Name pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value1))+1)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value1), 0))
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value2))+1)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value2), 0))
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value2 string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Traverser_Generic) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Traverser_Generic data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Traverser_Generic) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Traverser_GenericCurrentVersion {
		cutVer = Table_Traverser_GenericCurrentVersion
	}
	// check version
	if cutVer < Table_Traverser_GenericBaseVersion {
		errors.New("Table_Traverser_Generic cut version must large than Table_Traverser_GenericBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Key)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Key unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Name)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Name unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Level unpack error\n" + err.Error())
	}

	var value1Size uint32
	err = binary.Read(r, binary.BigEndian, &value1Size)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value1 string size unpack error\n" + err.Error())
	}

	value1Bytes := make([]byte, value1Size)
	err = binary.Read(r, binary.BigEndian, value1Bytes)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value1 string content unpack error\n" + err.Error())
	}
	this.Value1 = string(value1Bytes[:len(value1Bytes)-1])

	var value2Size uint32
	err = binary.Read(r, binary.BigEndian, &value2Size)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value2 string size unpack error\n" + err.Error())
	}

	value2Bytes := make([]byte, value2Size)
	err = binary.Read(r, binary.BigEndian, value2Bytes)
	if err != nil {
		return errors.New("Table_Traverser_Generic.Value2 string content unpack error\n" + err.Error())
	}
	this.Value2 = string(value2Bytes[:len(value2Bytes)-1])

	return err
}

const (
	Table_Traverser_ListBaseVersion    uint32 = 5
	Table_Traverser_ListCurrentVersion uint32 = 5
)

var Table_Traverser_ListDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Key, Name",
}

// Table_Traverser_List
type Table_Traverser_List struct {
	Key uint32 `tdr_field:"key"`

	Name int16 `tdr_field:"name"`

	Level uint32 `tdr_field:"level"`

	Value1 string `tdr_field:"value1"`

	Value2 string `tdr_field:"value2"`
}

func NewTable_Traverser_List() *Table_Traverser_List {
	obj := new(Table_Traverser_List)
	obj.Init()
	return obj
}

func (this *Table_Traverser_List) GetBaseVersion() uint32 {
	return Table_Traverser_ListBaseVersion
}

func (this *Table_Traverser_List) GetCurrentVersion() uint32 {
	return Table_Traverser_ListCurrentVersion
}

func (this *Table_Traverser_List) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Traverser_ListDBFeilds
}

func (this *Table_Traverser_List) Init() {

}

func (this *Table_Traverser_List) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Traverser_List Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Traverser_List) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Traverser_ListCurrentVersion {
		cutVer = Table_Traverser_ListCurrentVersion
	}
	// check cut version
	if cutVer < Table_Traverser_ListBaseVersion {
		return errors.New("Table_Traverser_List cut version must large than Table_Traverser_ListBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Key)
	if err != nil {
		return errors.New("Table_Traverser_List.Key pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Name)
	if err != nil {
		return errors.New("Table_Traverser_List.Name pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Traverser_List.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value1))+1)
	if err != nil {
		return errors.New("Table_Traverser_List.Value1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value1), 0))
	if err != nil {
		return errors.New("Table_Traverser_List.Value1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value2))+1)
	if err != nil {
		return errors.New("Table_Traverser_List.Value2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value2), 0))
	if err != nil {
		return errors.New("Table_Traverser_List.Value2 string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Traverser_List) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Traverser_List data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Traverser_List) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Traverser_ListCurrentVersion {
		cutVer = Table_Traverser_ListCurrentVersion
	}
	// check version
	if cutVer < Table_Traverser_ListBaseVersion {
		errors.New("Table_Traverser_List cut version must large than Table_Traverser_ListBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Key)
	if err != nil {
		return errors.New("Table_Traverser_List.Key unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Name)
	if err != nil {
		return errors.New("Table_Traverser_List.Name unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Traverser_List.Level unpack error\n" + err.Error())
	}

	var value1Size uint32
	err = binary.Read(r, binary.BigEndian, &value1Size)
	if err != nil {
		return errors.New("Table_Traverser_List.Value1 string size unpack error\n" + err.Error())
	}

	value1Bytes := make([]byte, value1Size)
	err = binary.Read(r, binary.BigEndian, value1Bytes)
	if err != nil {
		return errors.New("Table_Traverser_List.Value1 string content unpack error\n" + err.Error())
	}
	this.Value1 = string(value1Bytes[:len(value1Bytes)-1])

	var value2Size uint32
	err = binary.Read(r, binary.BigEndian, &value2Size)
	if err != nil {
		return errors.New("Table_Traverser_List.Value2 string size unpack error\n" + err.Error())
	}

	value2Bytes := make([]byte, value2Size)
	err = binary.Read(r, binary.BigEndian, value2Bytes)
	if err != nil {
		return errors.New("Table_Traverser_List.Value2 string content unpack error\n" + err.Error())
	}
	this.Value2 = string(value2Bytes[:len(value2Bytes)-1])

	return err
}

const (
	Table_Sortlist_SingleBaseVersion    uint32 = 5
	Table_Sortlist_SingleCurrentVersion uint32 = 5
)

var Table_Sortlist_SingleDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Key, Name",
}

// Table_Sortlist_Single
type Table_Sortlist_Single struct {
	Key uint32 `tdr_field:"key"`

	Name int16 `tdr_field:"name"`

	Level uint32 `tdr_field:"level"`

	Value1 string `tdr_field:"value1"`

	Value2 string `tdr_field:"value2"`

	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Uint8 byte `tdr_field:"type_uint8"`

	Type_Int16 int16 `tdr_field:"type_int16"`

	Type_Uint16 uint16 `tdr_field:"type_uint16"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Uint32 uint32 `tdr_field:"type_uint32"`

	Type_Int64 int64 `tdr_field:"type_int64"`

	Type_Uint64 uint64 `tdr_field:"type_uint64"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_Double float64 `tdr_field:"type_double"`

	Type_Short int16 `tdr_field:"type_short"`

	Type_String string `tdr_field:"type_string"`

	Type_Tinyint int8 `tdr_field:"type_tinyint"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`
}

func NewTable_Sortlist_Single() *Table_Sortlist_Single {
	obj := new(Table_Sortlist_Single)
	obj.Init()
	return obj
}

func (this *Table_Sortlist_Single) GetBaseVersion() uint32 {
	return Table_Sortlist_SingleBaseVersion
}

func (this *Table_Sortlist_Single) GetCurrentVersion() uint32 {
	return Table_Sortlist_SingleCurrentVersion
}

func (this *Table_Sortlist_Single) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Sortlist_SingleDBFeilds
}

func (this *Table_Sortlist_Single) Init() {

}

func (this *Table_Sortlist_Single) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Sortlist_Single Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Sortlist_Single) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Sortlist_SingleCurrentVersion {
		cutVer = Table_Sortlist_SingleCurrentVersion
	}
	// check cut version
	if cutVer < Table_Sortlist_SingleBaseVersion {
		return errors.New("Table_Sortlist_Single cut version must large than Table_Sortlist_SingleBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Key)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Key pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Name)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Name pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value1))+1)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value1), 0))
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value2))+1)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value2), 0))
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint8)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int16)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint16)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint32)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int64)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint64)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Double)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Short)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Short pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Tinyint pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Datetime pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Sortlist_Single) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Sortlist_Single data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Sortlist_Single) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Sortlist_SingleCurrentVersion {
		cutVer = Table_Sortlist_SingleCurrentVersion
	}
	// check version
	if cutVer < Table_Sortlist_SingleBaseVersion {
		errors.New("Table_Sortlist_Single cut version must large than Table_Sortlist_SingleBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Key)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Key unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Name)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Name unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Level unpack error\n" + err.Error())
	}

	var value1Size uint32
	err = binary.Read(r, binary.BigEndian, &value1Size)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value1 string size unpack error\n" + err.Error())
	}

	value1Bytes := make([]byte, value1Size)
	err = binary.Read(r, binary.BigEndian, value1Bytes)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value1 string content unpack error\n" + err.Error())
	}
	this.Value1 = string(value1Bytes[:len(value1Bytes)-1])

	var value2Size uint32
	err = binary.Read(r, binary.BigEndian, &value2Size)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value2 string size unpack error\n" + err.Error())
	}

	value2Bytes := make([]byte, value2Size)
	err = binary.Read(r, binary.BigEndian, value2Bytes)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Value2 string content unpack error\n" + err.Error())
	}
	this.Value2 = string(value2Bytes[:len(value2Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint8)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int16)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint16)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint32)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int64)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint64)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Double)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Double unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Short)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Short unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Tinyint unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("Table_Sortlist_Single.Type_Datetime unpack error\n" + err.Error())
	}

	return err
}

const (
	Table_Sortlist_MutilBaseVersion    uint32 = 5
	Table_Sortlist_MutilCurrentVersion uint32 = 5
)

var Table_Sortlist_MutilDBFeilds = &tdrcom.TDRDBFeilds{
	PrimaryKey: "Key, Name",
}

// Table_Sortlist_Mutil
type Table_Sortlist_Mutil struct {
	Key uint32 `tdr_field:"key"`

	Name int16 `tdr_field:"name"`

	Level uint32 `tdr_field:"level"`

	Value1 string `tdr_field:"value1"`

	Value2 string `tdr_field:"value2"`

	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Uint8 byte `tdr_field:"type_uint8"`

	Type_Int16 int16 `tdr_field:"type_int16"`

	Type_Uint16 uint16 `tdr_field:"type_uint16"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Uint32 uint32 `tdr_field:"type_uint32"`

	Type_Int64 int64 `tdr_field:"type_int64"`

	Type_Uint64 uint64 `tdr_field:"type_uint64"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_Double float64 `tdr_field:"type_double"`

	Type_Short int16 `tdr_field:"type_short"`

	Type_String string `tdr_field:"type_string"`

	Type_Tinyint []int8 `tdr_field:"type_tinyint" tdr_count:"100" tdr_refer:"Type_Int8"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`
}

func NewTable_Sortlist_Mutil() *Table_Sortlist_Mutil {
	obj := new(Table_Sortlist_Mutil)
	obj.Init()
	return obj
}

func (this *Table_Sortlist_Mutil) GetBaseVersion() uint32 {
	return Table_Sortlist_MutilBaseVersion
}

func (this *Table_Sortlist_Mutil) GetCurrentVersion() uint32 {
	return Table_Sortlist_MutilCurrentVersion
}

func (this *Table_Sortlist_Mutil) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_Sortlist_MutilDBFeilds
}

func (this *Table_Sortlist_Mutil) Init() {

}

func (this *Table_Sortlist_Mutil) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Sortlist_Mutil Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Sortlist_Mutil) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_Sortlist_MutilCurrentVersion {
		cutVer = Table_Sortlist_MutilCurrentVersion
	}
	// check cut version
	if cutVer < Table_Sortlist_MutilBaseVersion {
		return errors.New("Table_Sortlist_Mutil cut version must large than Table_Sortlist_MutilBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Key)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Key pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Name)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Name pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value1))+1)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value1), 0))
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value2))+1)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value2), 0))
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint8)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int16)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint16)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint32)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int64)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint64)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Double)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Short)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Short pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_String string content pack error\n" + err.Error())
	}

	if this.Type_Int8 < 0 {
		return errors.New("Table_Sortlist_Mutil.Type_Tinyint's refer Type_Int8 should >= 0")
	}
	if this.Type_Int8 > 100 {
		return errors.New("Table_Sortlist_Mutil.Type_Tinyint's refer Type_Int8 should <= count 100")
	}
	if len(this.Type_Tinyint) < int(this.Type_Int8) {
		return errors.New("Table_Sortlist_Mutil.Type_Tinyint's length should > Type_Int8")
	}
	if this.Type_Int8 > 0 {
		referType_Tinyint := this.Type_Tinyint[:this.Type_Int8]
		err = binary.Write(w, binary.BigEndian, referType_Tinyint)
		if err != nil {
			return errors.New("Table_Sortlist_Mutil.Type_Tinyint pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Datetime pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Sortlist_Mutil) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Sortlist_Mutil data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Sortlist_Mutil) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_Sortlist_MutilCurrentVersion {
		cutVer = Table_Sortlist_MutilCurrentVersion
	}
	// check version
	if cutVer < Table_Sortlist_MutilBaseVersion {
		errors.New("Table_Sortlist_Mutil cut version must large than Table_Sortlist_MutilBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Key)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Key unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Name)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Name unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Level unpack error\n" + err.Error())
	}

	var value1Size uint32
	err = binary.Read(r, binary.BigEndian, &value1Size)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value1 string size unpack error\n" + err.Error())
	}

	value1Bytes := make([]byte, value1Size)
	err = binary.Read(r, binary.BigEndian, value1Bytes)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value1 string content unpack error\n" + err.Error())
	}
	this.Value1 = string(value1Bytes[:len(value1Bytes)-1])

	var value2Size uint32
	err = binary.Read(r, binary.BigEndian, &value2Size)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value2 string size unpack error\n" + err.Error())
	}

	value2Bytes := make([]byte, value2Size)
	err = binary.Read(r, binary.BigEndian, value2Bytes)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Value2 string content unpack error\n" + err.Error())
	}
	this.Value2 = string(value2Bytes[:len(value2Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint8)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int16)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint16)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint32)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int64)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint64)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Double)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Double unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Short)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Short unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	if this.Type_Int8 < 0 {
		return errors.New("Table_Sortlist_Mutil.Type_Tinyint's refer Type_Int8 should >= 0")
	}
	if this.Type_Int8 > 100 {
		return errors.New("Table_Sortlist_Mutil.Type_Tinyint's refer Type_Int8 should <= count 100")
	}

	if this.Type_Tinyint == nil {
		this.Type_Tinyint = make([]int8, int(this.Type_Int8))
	}

	referType_Tinyint := this.Type_Tinyint[:this.Type_Int8]
	err = binary.Read(r, binary.BigEndian, referType_Tinyint)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Tinyint pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("Table_Sortlist_Mutil.Type_Datetime unpack error\n" + err.Error())
	}

	return err
}

const KEY_MAX_SIZE int64 = 100
const VALUE_MAX_SIZE int64 = 256
const (
	PLAYERONLINECNT_SimplifyBaseVersion    uint32 = 1
	PLAYERONLINECNT_SimplifyCurrentVersion uint32 = 1
)

var PLAYERONLINECNT_SimplifyDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Key",
	PrimaryKey:    "Key",
}

// PLAYERONLINECNT_Simplify
type PLAYERONLINECNT_Simplify struct {
	Klen int32 `tdr_field:"klen"`

	Key []byte `tdr_field:"key" tdr_count:"100" tdr_refer:"Klen"`

	Vlen int32 `tdr_field:"vlen"`

	Value []byte `tdr_field:"value" tdr_count:"256" tdr_refer:"Vlen"`
}

func NewPLAYERONLINECNT_Simplify() *PLAYERONLINECNT_Simplify {
	obj := new(PLAYERONLINECNT_Simplify)
	obj.Init()
	return obj
}

func (this *PLAYERONLINECNT_Simplify) GetBaseVersion() uint32 {
	return PLAYERONLINECNT_SimplifyBaseVersion
}

func (this *PLAYERONLINECNT_Simplify) GetCurrentVersion() uint32 {
	return PLAYERONLINECNT_SimplifyCurrentVersion
}

func (this *PLAYERONLINECNT_Simplify) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return PLAYERONLINECNT_SimplifyDBFeilds
}

func (this *PLAYERONLINECNT_Simplify) Init() {
	this.Klen = 0

	this.Vlen = 0

}

func (this *PLAYERONLINECNT_Simplify) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("PLAYERONLINECNT_Simplify Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *PLAYERONLINECNT_Simplify) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > PLAYERONLINECNT_SimplifyCurrentVersion {
		cutVer = PLAYERONLINECNT_SimplifyCurrentVersion
	}
	// check cut version
	if cutVer < PLAYERONLINECNT_SimplifyBaseVersion {
		return errors.New("PLAYERONLINECNT_Simplify cut version must large than PLAYERONLINECNT_SimplifyBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Klen)
	if err != nil {
		return errors.New("PLAYERONLINECNT_Simplify.Klen pack error\n" + err.Error())
	}

	if this.Klen < 0 {
		return errors.New("PLAYERONLINECNT_Simplify.Key's refer Klen should >= 0")
	}
	if this.Klen > 100 {
		return errors.New("PLAYERONLINECNT_Simplify.Key's refer Klen should <= count 100")
	}
	if len(this.Key) < int(this.Klen) {
		return errors.New("PLAYERONLINECNT_Simplify.Key's length should > Klen")
	}
	if this.Klen > 0 {
		referKey := this.Key[:this.Klen]
		err = binary.Write(w, binary.BigEndian, referKey)
		if err != nil {
			return errors.New("PLAYERONLINECNT_Simplify.Key pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Vlen)
	if err != nil {
		return errors.New("PLAYERONLINECNT_Simplify.Vlen pack error\n" + err.Error())
	}

	if this.Vlen < 0 {
		return errors.New("PLAYERONLINECNT_Simplify.Value's refer Vlen should >= 0")
	}
	if this.Vlen > 256 {
		return errors.New("PLAYERONLINECNT_Simplify.Value's refer Vlen should <= count 256")
	}
	if len(this.Value) < int(this.Vlen) {
		return errors.New("PLAYERONLINECNT_Simplify.Value's length should > Vlen")
	}
	if this.Vlen > 0 {
		referValue := this.Value[:this.Vlen]
		err = binary.Write(w, binary.BigEndian, referValue)
		if err != nil {
			return errors.New("PLAYERONLINECNT_Simplify.Value pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *PLAYERONLINECNT_Simplify) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("PLAYERONLINECNT_Simplify data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *PLAYERONLINECNT_Simplify) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > PLAYERONLINECNT_SimplifyCurrentVersion {
		cutVer = PLAYERONLINECNT_SimplifyCurrentVersion
	}
	// check version
	if cutVer < PLAYERONLINECNT_SimplifyBaseVersion {
		errors.New("PLAYERONLINECNT_Simplify cut version must large than PLAYERONLINECNT_SimplifyBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Klen)
	if err != nil {
		return errors.New("PLAYERONLINECNT_Simplify.Klen unpack error\n" + err.Error())
	}

	if this.Klen < 0 {
		return errors.New("PLAYERONLINECNT_Simplify.Key's refer Klen should >= 0")
	}
	if this.Klen > 100 {
		return errors.New("PLAYERONLINECNT_Simplify.Key's refer Klen should <= count 100")
	}

	if this.Key == nil {
		this.Key = make([]byte, int(this.Klen))
	}

	referKey := this.Key[:this.Klen]
	err = binary.Read(r, binary.BigEndian, referKey)
	if err != nil {
		return errors.New("PLAYERONLINECNT_Simplify.Key pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Vlen)
	if err != nil {
		return errors.New("PLAYERONLINECNT_Simplify.Vlen unpack error\n" + err.Error())
	}

	if this.Vlen < 0 {
		return errors.New("PLAYERONLINECNT_Simplify.Value's refer Vlen should >= 0")
	}
	if this.Vlen > 256 {
		return errors.New("PLAYERONLINECNT_Simplify.Value's refer Vlen should <= count 256")
	}

	if this.Value == nil {
		this.Value = make([]byte, int(this.Vlen))
	}

	referValue := this.Value[:this.Vlen]
	err = binary.Read(r, binary.BigEndian, referValue)
	if err != nil {
		return errors.New("PLAYERONLINECNT_Simplify.Value pack error\n" + err.Error())
	}

	return err
}

const (
	Table_10M_GenericBaseVersion    uint32 = 5
	Table_10M_GenericCurrentVersion uint32 = 5
)

var Table_10M_GenericDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin",
}

// Table_10M_Generic
type Table_10M_Generic struct {
	Uin uint32 `tdr_field:"uin"`

	Big_Record_10M_Len int32 `tdr_field:"big_record_10M_len"`

	Big_Record_10M []byte `tdr_field:"big_record_10M" tdr_count:"10000000" tdr_refer:"Big_Record_10M_Len"`

	Small_Record_10M_Len int32 `tdr_field:"small_record_10M_len"`

	Small_Record_10M []byte `tdr_field:"small_record_10M" tdr_count:"10000000" tdr_refer:"Small_Record_10M_Len"`
}

func NewTable_10M_Generic() *Table_10M_Generic {
	obj := new(Table_10M_Generic)
	obj.Init()
	return obj
}

func (this *Table_10M_Generic) GetBaseVersion() uint32 {
	return Table_10M_GenericBaseVersion
}

func (this *Table_10M_Generic) GetCurrentVersion() uint32 {
	return Table_10M_GenericCurrentVersion
}

func (this *Table_10M_Generic) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_10M_GenericDBFeilds
}

func (this *Table_10M_Generic) Init() {

	this.Big_Record_10M_Len = 0

	this.Small_Record_10M_Len = 0

}

func (this *Table_10M_Generic) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_10M_Generic Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_10M_Generic) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_10M_GenericCurrentVersion {
		cutVer = Table_10M_GenericCurrentVersion
	}
	// check cut version
	if cutVer < Table_10M_GenericBaseVersion {
		return errors.New("Table_10M_Generic cut version must large than Table_10M_GenericBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_10M_Generic.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Generic.Big_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_Generic.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Generic.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}
	if len(this.Big_Record_10M) < int(this.Big_Record_10M_Len) {
		return errors.New("Table_10M_Generic.Big_Record_10M's length should > Big_Record_10M_Len")
	}
	if this.Big_Record_10M_Len > 0 {
		referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referBig_Record_10M)
		if err != nil {
			return errors.New("Table_10M_Generic.Big_Record_10M pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Generic.Small_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_Generic.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Generic.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}
	if len(this.Small_Record_10M) < int(this.Small_Record_10M_Len) {
		return errors.New("Table_10M_Generic.Small_Record_10M's length should > Small_Record_10M_Len")
	}
	if this.Small_Record_10M_Len > 0 {
		referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referSmall_Record_10M)
		if err != nil {
			return errors.New("Table_10M_Generic.Small_Record_10M pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_10M_Generic) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_10M_Generic data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_10M_Generic) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_10M_GenericCurrentVersion {
		cutVer = Table_10M_GenericCurrentVersion
	}
	// check version
	if cutVer < Table_10M_GenericBaseVersion {
		errors.New("Table_10M_Generic cut version must large than Table_10M_GenericBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_10M_Generic.Uin unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Generic.Big_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_Generic.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Generic.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}

	if this.Big_Record_10M == nil {
		this.Big_Record_10M = make([]byte, int(this.Big_Record_10M_Len))
	}

	referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referBig_Record_10M)
	if err != nil {
		return errors.New("Table_10M_Generic.Big_Record_10M pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Generic.Small_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_Generic.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Generic.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}

	if this.Small_Record_10M == nil {
		this.Small_Record_10M = make([]byte, int(this.Small_Record_10M_Len))
	}

	referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referSmall_Record_10M)
	if err != nil {
		return errors.New("Table_10M_Generic.Small_Record_10M pack error\n" + err.Error())
	}

	return err
}

const (
	Table_10M_ListBaseVersion    uint32 = 5
	Table_10M_ListCurrentVersion uint32 = 5
)

var Table_10M_ListDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin",
}

// Table_10M_List
type Table_10M_List struct {
	Uin uint32 `tdr_field:"uin"`

	Big_Record_10M_Len int32 `tdr_field:"big_record_10M_len"`

	Big_Record_10M []byte `tdr_field:"big_record_10M" tdr_count:"10000000" tdr_refer:"Big_Record_10M_Len"`

	Small_Record_10M_Len int32 `tdr_field:"small_record_10M_len"`

	Small_Record_10M []byte `tdr_field:"small_record_10M" tdr_count:"10000000" tdr_refer:"Small_Record_10M_Len"`
}

func NewTable_10M_List() *Table_10M_List {
	obj := new(Table_10M_List)
	obj.Init()
	return obj
}

func (this *Table_10M_List) GetBaseVersion() uint32 {
	return Table_10M_ListBaseVersion
}

func (this *Table_10M_List) GetCurrentVersion() uint32 {
	return Table_10M_ListCurrentVersion
}

func (this *Table_10M_List) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_10M_ListDBFeilds
}

func (this *Table_10M_List) Init() {

	this.Big_Record_10M_Len = 0

	this.Small_Record_10M_Len = 0

}

func (this *Table_10M_List) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_10M_List Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_10M_List) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_10M_ListCurrentVersion {
		cutVer = Table_10M_ListCurrentVersion
	}
	// check cut version
	if cutVer < Table_10M_ListBaseVersion {
		return errors.New("Table_10M_List cut version must large than Table_10M_ListBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_10M_List.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_List.Big_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_List.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_List.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}
	if len(this.Big_Record_10M) < int(this.Big_Record_10M_Len) {
		return errors.New("Table_10M_List.Big_Record_10M's length should > Big_Record_10M_Len")
	}
	if this.Big_Record_10M_Len > 0 {
		referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referBig_Record_10M)
		if err != nil {
			return errors.New("Table_10M_List.Big_Record_10M pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_List.Small_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_List.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_List.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}
	if len(this.Small_Record_10M) < int(this.Small_Record_10M_Len) {
		return errors.New("Table_10M_List.Small_Record_10M's length should > Small_Record_10M_Len")
	}
	if this.Small_Record_10M_Len > 0 {
		referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referSmall_Record_10M)
		if err != nil {
			return errors.New("Table_10M_List.Small_Record_10M pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_10M_List) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_10M_List data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_10M_List) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_10M_ListCurrentVersion {
		cutVer = Table_10M_ListCurrentVersion
	}
	// check version
	if cutVer < Table_10M_ListBaseVersion {
		errors.New("Table_10M_List cut version must large than Table_10M_ListBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_10M_List.Uin unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_List.Big_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_List.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_List.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}

	if this.Big_Record_10M == nil {
		this.Big_Record_10M = make([]byte, int(this.Big_Record_10M_Len))
	}

	referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referBig_Record_10M)
	if err != nil {
		return errors.New("Table_10M_List.Big_Record_10M pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_List.Small_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_List.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_List.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}

	if this.Small_Record_10M == nil {
		this.Small_Record_10M = make([]byte, int(this.Small_Record_10M_Len))
	}

	referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referSmall_Record_10M)
	if err != nil {
		return errors.New("Table_10M_List.Small_Record_10M pack error\n" + err.Error())
	}

	return err
}

const (
	Table_10M_Complex_GenericBaseVersion    uint32 = 5
	Table_10M_Complex_GenericCurrentVersion uint32 = 5
)

var Table_10M_Complex_GenericDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin,Name,Key3,Key4",
	Index2Column: map[string]string{
		"Index2": "Uin,Name",
		"Index3": "Uin,Name,Key3",
		"Index1": "Uin",
		"Index4": "Uin,Key4",
	},
}

// Table_10M_Complex_Generic
type Table_10M_Complex_Generic struct {
	Uin uint64 `tdr_field:"uin"`

	Name string `tdr_field:"name"`

	Key3 string `tdr_field:"key3"`

	Key4 string `tdr_field:"key4"`

	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Uint8 byte `tdr_field:"type_uint8"`

	Type_Int16 int16 `tdr_field:"type_int16"`

	Type_Uint16 uint16 `tdr_field:"type_uint16"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Uint32 uint32 `tdr_field:"type_uint32"`

	Type_Int64 int64 `tdr_field:"type_int64"`

	Type_Uint64 uint64 `tdr_field:"type_uint64"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_Double float64 `tdr_field:"type_double"`

	Type_Short int16 `tdr_field:"type_short"`

	Type_String string `tdr_field:"type_string"`

	Type_Tinyint int8 `tdr_field:"type_tinyint"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count int32 `tdr_field:"array_count"`

	Type_Int8_Array []int8 `tdr_field:"type_int8_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int16_Array []int16 `tdr_field:"type_int16_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int64_Array []int64 `tdr_field:"type_int64_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	Type_Uint8_Array []byte `tdr_field:"type_uint8_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint16_Array []uint16 `tdr_field:"type_uint16_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint32_Array []uint32 `tdr_field:"type_uint32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint64_Array []uint64 `tdr_field:"type_uint64_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	S0 *S0 `tdr_field:"S0"`

	S0_Array []*S0 `tdr_field:"S0_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	Union_Selector byte `tdr_field:"union_selector"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Big_Record_10M_Len int32 `tdr_field:"big_record_10M_len"`

	Big_Record_10M []byte `tdr_field:"big_record_10M" tdr_count:"10000000" tdr_refer:"Big_Record_10M_Len"`

	Small_Record_10M_Len int32 `tdr_field:"small_record_10M_len"`

	Small_Record_10M []byte `tdr_field:"small_record_10M" tdr_count:"10000000" tdr_refer:"Small_Record_10M_Len"`
}

func NewTable_10M_Complex_Generic() *Table_10M_Complex_Generic {
	obj := new(Table_10M_Complex_Generic)
	obj.Init()
	return obj
}

func (this *Table_10M_Complex_Generic) GetBaseVersion() uint32 {
	return Table_10M_Complex_GenericBaseVersion
}

func (this *Table_10M_Complex_Generic) GetCurrentVersion() uint32 {
	return Table_10M_Complex_GenericCurrentVersion
}

func (this *Table_10M_Complex_Generic) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_10M_Complex_GenericDBFeilds
}

func (this *Table_10M_Complex_Generic) Init() {

	this.S0 = NewS0()

	this.Union_Selector = 0

	this.Big_Record_10M_Len = 0

	this.Small_Record_10M_Len = 0

}

func (this *Table_10M_Complex_Generic) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_10M_Complex_Generic Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_10M_Complex_Generic) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_10M_Complex_GenericCurrentVersion {
		cutVer = Table_10M_Complex_GenericCurrentVersion
	}
	// check cut version
	if cutVer < Table_10M_Complex_GenericBaseVersion {
		return errors.New("Table_10M_Complex_Generic cut version must large than Table_10M_Complex_GenericBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key3))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key3), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key4))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key4), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint8)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int16)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint16)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint32)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int64)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint64)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Double)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Short)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Short pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Tinyint pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int8_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int8_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Int8_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int8_Array := this.Type_Int8_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int8_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Int8_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int16_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int16_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Int16_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int16_Array := this.Type_Int16_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int16_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Int16_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int64_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int64_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Int64_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int64_Array := this.Type_Int64_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int64_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Int64_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String_Array string content pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint8_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint8_Array := this.Type_Uint8_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint8_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint16_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint16_Array := this.Type_Uint16_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint16_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint32_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint32_Array := this.Type_Uint32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint32_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint64_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint64_Array := this.Type_Uint64_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint64_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Struct_Array_Count pack error\n" + err.Error())
	}

	err = this.S0.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.S0 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.S0_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("Table_10M_Complex_Generic.S0_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S0_Array) < int(this.Struct_Array_Count) {
		return errors.New("Table_10M_Complex_Generic.S0_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S0_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_10M_Complex_Generic.S0_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Union_Array_Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}
	if len(this.Big_Record_10M) < int(this.Big_Record_10M_Len) {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M's length should > Big_Record_10M_Len")
	}
	if this.Big_Record_10M_Len > 0 {
		referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referBig_Record_10M)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Big_Record_10M pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}
	if len(this.Small_Record_10M) < int(this.Small_Record_10M_Len) {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M's length should > Small_Record_10M_Len")
	}
	if this.Small_Record_10M_Len > 0 {
		referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referSmall_Record_10M)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.Small_Record_10M pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_10M_Complex_Generic) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_10M_Complex_Generic data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_10M_Complex_Generic) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_10M_Complex_GenericCurrentVersion {
		cutVer = Table_10M_Complex_GenericCurrentVersion
	}
	// check version
	if cutVer < Table_10M_Complex_GenericBaseVersion {
		errors.New("Table_10M_Complex_Generic cut version must large than Table_10M_Complex_GenericBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	var key3Size uint32
	err = binary.Read(r, binary.BigEndian, &key3Size)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key3 string size unpack error\n" + err.Error())
	}

	key3Bytes := make([]byte, key3Size)
	err = binary.Read(r, binary.BigEndian, key3Bytes)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key3 string content unpack error\n" + err.Error())
	}
	this.Key3 = string(key3Bytes[:len(key3Bytes)-1])

	var key4Size uint32
	err = binary.Read(r, binary.BigEndian, &key4Size)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key4 string size unpack error\n" + err.Error())
	}

	key4Bytes := make([]byte, key4Size)
	err = binary.Read(r, binary.BigEndian, key4Bytes)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Key4 string content unpack error\n" + err.Error())
	}
	this.Key4 = string(key4Bytes[:len(key4Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint8)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int16)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint16)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint32)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int64)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint64)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Double)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Double unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Short)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Short unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Tinyint unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int8_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int8_Array == nil {
		this.Type_Int8_Array = make([]int8, int(this.Array_Count))
	}

	referType_Int8_Array := this.Type_Int8_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int8_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int8_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int16_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int16_Array == nil {
		this.Type_Int16_Array = make([]int16, int(this.Array_Count))
	}

	referType_Int16_Array := this.Type_Int16_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int16_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int16_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int32_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Int64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Int64_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int64_Array == nil {
		this.Type_Int64_Array = make([]int64, int(this.Array_Count))
	}

	referType_Int64_Array := this.Type_Int64_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int64_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Int64_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint8_Array == nil {
		this.Type_Uint8_Array = make([]byte, int(this.Array_Count))
	}

	referType_Uint8_Array := this.Type_Uint8_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint8_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint8_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint16_Array == nil {
		this.Type_Uint16_Array = make([]uint16, int(this.Array_Count))
	}

	referType_Uint16_Array := this.Type_Uint16_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint16_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint16_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint32_Array == nil {
		this.Type_Uint32_Array = make([]uint32, int(this.Array_Count))
	}

	referType_Uint32_Array := this.Type_Uint32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint32_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint32_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint64_Array == nil {
		this.Type_Uint64_Array = make([]uint64, int(this.Array_Count))
	}

	referType_Uint64_Array := this.Type_Uint64_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint64_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Type_Uint64_Array pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = this.S0.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.S0 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("Table_10M_Complex_Generic.S0_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("Table_10M_Complex_Generic.S0_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S0_Array == nil {
		this.S0_Array = make([]*S0, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S0_Array[i] = NewS0()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S0_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_10M_Complex_Generic.S0_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Union_Array_Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}

	if this.Big_Record_10M == nil {
		this.Big_Record_10M = make([]byte, int(this.Big_Record_10M_Len))
	}

	referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referBig_Record_10M)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Big_Record_10M pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}

	if this.Small_Record_10M == nil {
		this.Small_Record_10M = make([]byte, int(this.Small_Record_10M_Len))
	}

	referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referSmall_Record_10M)
	if err != nil {
		return errors.New("Table_10M_Complex_Generic.Small_Record_10M pack error\n" + err.Error())
	}

	return err
}

const (
	Table_10M_Complex_ListBaseVersion    uint32 = 5
	Table_10M_Complex_ListCurrentVersion uint32 = 5
)

var Table_10M_Complex_ListDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin",
}

// Table_10M_Complex_List
type Table_10M_Complex_List struct {
	Uin uint64 `tdr_field:"uin"`

	Name string `tdr_field:"name"`

	Key3 string `tdr_field:"key3"`

	Key4 string `tdr_field:"key4"`

	Type_Int8 int8 `tdr_field:"type_int8"`

	Type_Uint8 byte `tdr_field:"type_uint8"`

	Type_Int16 int16 `tdr_field:"type_int16"`

	Type_Uint16 uint16 `tdr_field:"type_uint16"`

	Type_Int32 int32 `tdr_field:"type_int32"`

	Type_Uint32 uint32 `tdr_field:"type_uint32"`

	Type_Int64 int64 `tdr_field:"type_int64"`

	Type_Uint64 uint64 `tdr_field:"type_uint64"`

	Type_Float float32 `tdr_field:"type_float"`

	Type_Double float64 `tdr_field:"type_double"`

	Type_Short int16 `tdr_field:"type_short"`

	Type_String string `tdr_field:"type_string"`

	Type_Tinyint int8 `tdr_field:"type_tinyint"`

	Type_Datetime uint64 `tdr_field:"type_datetime"`

	Array_Count uint32 `tdr_field:"array_count"`

	Type_Int8_Array []int8 `tdr_field:"type_int8_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int16_Array []int16 `tdr_field:"type_int16_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int32_Array []int32 `tdr_field:"type_int32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Int64_Array []int64 `tdr_field:"type_int64_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_String_Array string `tdr_field:"type_string_array"`

	Type_Uint8_Array []byte `tdr_field:"type_uint8_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint16_Array []uint16 `tdr_field:"type_uint16_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint32_Array []uint32 `tdr_field:"type_uint32_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Type_Uint64_Array []uint64 `tdr_field:"type_uint64_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Struct_Array_Count uint32 `tdr_field:"struct_array_count"`

	S0 *S0 `tdr_field:"S0"`

	S0_Array []*S0 `tdr_field:"S0_array" tdr_count:"2" tdr_refer:"Struct_Array_Count"`

	Union_Selector byte `tdr_field:"union_selector"`

	Union_Array_Count uint32 `tdr_field:"union_array_count"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Big_Record_10M_Len int32 `tdr_field:"big_record_10M_len"`

	Big_Record_10M []byte `tdr_field:"big_record_10M" tdr_count:"10000000" tdr_refer:"Big_Record_10M_Len"`

	Small_Record_10M_Len int32 `tdr_field:"small_record_10M_len"`

	Small_Record_10M []byte `tdr_field:"small_record_10M" tdr_count:"10000000" tdr_refer:"Small_Record_10M_Len"`
}

func NewTable_10M_Complex_List() *Table_10M_Complex_List {
	obj := new(Table_10M_Complex_List)
	obj.Init()
	return obj
}

func (this *Table_10M_Complex_List) GetBaseVersion() uint32 {
	return Table_10M_Complex_ListBaseVersion
}

func (this *Table_10M_Complex_List) GetCurrentVersion() uint32 {
	return Table_10M_Complex_ListCurrentVersion
}

func (this *Table_10M_Complex_List) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_10M_Complex_ListDBFeilds
}

func (this *Table_10M_Complex_List) Init() {

	this.S0 = NewS0()

	this.Union_Selector = 0

	this.Big_Record_10M_Len = 0

	this.Small_Record_10M_Len = 0

}

func (this *Table_10M_Complex_List) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_10M_Complex_List Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_10M_Complex_List) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_10M_Complex_ListCurrentVersion {
		cutVer = Table_10M_Complex_ListCurrentVersion
	}
	// check cut version
	if cutVer < Table_10M_Complex_ListBaseVersion {
		return errors.New("Table_10M_Complex_List cut version must large than Table_10M_Complex_ListBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_List.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key3))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key3), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Key4))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Key4), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int8)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint8)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int16)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint16)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int32)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint32)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Int64)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Uint64)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Float)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Double)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Short)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Short pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Tinyint pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type_Datetime)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Datetime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int8_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int8_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Int8_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int8_Array := this.Type_Int8_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int8_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Int8_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int16_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int16_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Int16_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int16_Array := this.Type_Int16_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int16_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Int16_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int32_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Int32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int32_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Int32_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int64_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Int64_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Int64_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Int64_Array := this.Type_Int64_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Int64_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Int64_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type_String_Array))+1)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String_Array string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type_String_Array), 0))
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String_Array string content pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint8_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint8_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Uint8_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint8_Array := this.Type_Uint8_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint8_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Uint8_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint16_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint16_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Uint16_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint16_Array := this.Type_Uint16_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint16_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Uint16_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint32_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint32_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Uint32_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint32_Array := this.Type_Uint32_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint32_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Uint32_Array pack error\n" + err.Error())
		}
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint64_Array's refer Array_Count should <= count 3")
	}
	if len(this.Type_Uint64_Array) < int(this.Array_Count) {
		return errors.New("Table_10M_Complex_List.Type_Uint64_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		referType_Uint64_Array := this.Type_Uint64_Array[:this.Array_Count]
		err = binary.Write(w, binary.BigEndian, referType_Uint64_Array)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Type_Uint64_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Struct_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Struct_Array_Count pack error\n" + err.Error())
	}

	err = this.S0.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_10M_Complex_List.S0 pack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.S0_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("Table_10M_Complex_List.S0_Array's refer Struct_Array_Count should <= count 2")
	}
	if len(this.S0_Array) < int(this.Struct_Array_Count) {
		return errors.New("Table_10M_Complex_List.S0_Array's length should > Struct_Array_Count")
	}
	if this.Struct_Array_Count > 0 {
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			err = this.S0_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_10M_Complex_List.S0_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Selector)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Union_Selector pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Union_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Union_Array_Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Big_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_List.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_List.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}
	if len(this.Big_Record_10M) < int(this.Big_Record_10M_Len) {
		return errors.New("Table_10M_Complex_List.Big_Record_10M's length should > Big_Record_10M_Len")
	}
	if this.Big_Record_10M_Len > 0 {
		referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referBig_Record_10M)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Big_Record_10M pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Small_Record_10M_Len pack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_List.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_List.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}
	if len(this.Small_Record_10M) < int(this.Small_Record_10M_Len) {
		return errors.New("Table_10M_Complex_List.Small_Record_10M's length should > Small_Record_10M_Len")
	}
	if this.Small_Record_10M_Len > 0 {
		referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
		err = binary.Write(w, binary.BigEndian, referSmall_Record_10M)
		if err != nil {
			return errors.New("Table_10M_Complex_List.Small_Record_10M pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_10M_Complex_List) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_10M_Complex_List data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_10M_Complex_List) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_10M_Complex_ListCurrentVersion {
		cutVer = Table_10M_Complex_ListCurrentVersion
	}
	// check version
	if cutVer < Table_10M_Complex_ListBaseVersion {
		errors.New("Table_10M_Complex_List cut version must large than Table_10M_Complex_ListBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Uin unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	var key3Size uint32
	err = binary.Read(r, binary.BigEndian, &key3Size)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key3 string size unpack error\n" + err.Error())
	}

	key3Bytes := make([]byte, key3Size)
	err = binary.Read(r, binary.BigEndian, key3Bytes)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key3 string content unpack error\n" + err.Error())
	}
	this.Key3 = string(key3Bytes[:len(key3Bytes)-1])

	var key4Size uint32
	err = binary.Read(r, binary.BigEndian, &key4Size)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key4 string size unpack error\n" + err.Error())
	}

	key4Bytes := make([]byte, key4Size)
	err = binary.Read(r, binary.BigEndian, key4Bytes)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Key4 string content unpack error\n" + err.Error())
	}
	this.Key4 = string(key4Bytes[:len(key4Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Int8)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint8)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int16)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint16)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int32)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint32)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Int64)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Uint64)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Float)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Double)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Double unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Short)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Short unpack error\n" + err.Error())
	}

	var type_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &type_stringSize)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String string size unpack error\n" + err.Error())
	}

	type_stringBytes := make([]byte, type_stringSize)
	err = binary.Read(r, binary.BigEndian, type_stringBytes)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String string content unpack error\n" + err.Error())
	}
	this.Type_String = string(type_stringBytes[:len(type_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type_Tinyint)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Tinyint unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Type_Datetime)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Datetime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int8_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int8_Array == nil {
		this.Type_Int8_Array = make([]int8, int(this.Array_Count))
	}

	referType_Int8_Array := this.Type_Int8_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int8_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int8_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int16_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int16_Array == nil {
		this.Type_Int16_Array = make([]int16, int(this.Array_Count))
	}

	referType_Int16_Array := this.Type_Int16_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int16_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int16_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int32_Array == nil {
		this.Type_Int32_Array = make([]int32, int(this.Array_Count))
	}

	referType_Int32_Array := this.Type_Int32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int32_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int32_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Int64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Int64_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Int64_Array == nil {
		this.Type_Int64_Array = make([]int64, int(this.Array_Count))
	}

	referType_Int64_Array := this.Type_Int64_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Int64_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Int64_Array pack error\n" + err.Error())
	}

	var type_string_arraySize uint32
	err = binary.Read(r, binary.BigEndian, &type_string_arraySize)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String_Array string size unpack error\n" + err.Error())
	}

	type_string_arrayBytes := make([]byte, type_string_arraySize)
	err = binary.Read(r, binary.BigEndian, type_string_arrayBytes)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_String_Array string content unpack error\n" + err.Error())
	}
	this.Type_String_Array = string(type_string_arrayBytes[:len(type_string_arrayBytes)-1])

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint8_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint8_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint8_Array == nil {
		this.Type_Uint8_Array = make([]byte, int(this.Array_Count))
	}

	referType_Uint8_Array := this.Type_Uint8_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint8_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint8_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint16_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint16_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint16_Array == nil {
		this.Type_Uint16_Array = make([]uint16, int(this.Array_Count))
	}

	referType_Uint16_Array := this.Type_Uint16_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint16_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint16_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint32_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint32_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint32_Array == nil {
		this.Type_Uint32_Array = make([]uint32, int(this.Array_Count))
	}

	referType_Uint32_Array := this.Type_Uint32_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint32_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint32_Array pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.Type_Uint64_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_10M_Complex_List.Type_Uint64_Array's refer Array_Count should <= count 3")
	}

	if this.Type_Uint64_Array == nil {
		this.Type_Uint64_Array = make([]uint64, int(this.Array_Count))
	}

	referType_Uint64_Array := this.Type_Uint64_Array[:this.Array_Count]
	err = binary.Read(r, binary.BigEndian, referType_Uint64_Array)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Type_Uint64_Array pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Struct_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Struct_Array_Count unpack error\n" + err.Error())
	}

	err = this.S0.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_10M_Complex_List.S0 unpack error\n" + err.Error())
	}

	if this.Struct_Array_Count < 0 {
		return errors.New("Table_10M_Complex_List.S0_Array's refer Struct_Array_Count should >= 0")
	}
	if this.Struct_Array_Count > 2 {
		return errors.New("Table_10M_Complex_List.S0_Array's refer Struct_Array_Count should <= count 2")
	}

	if this.S0_Array == nil {
		this.S0_Array = make([]*S0, int(this.Struct_Array_Count))
		for i := 0; i < int(this.Struct_Array_Count); i++ {
			this.S0_Array[i] = NewS0()
		}
	}

	for i := 0; i < int(this.Struct_Array_Count); i++ {
		err = this.S0_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_10M_Complex_List.S0_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Selector)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Union_Selector unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Union_Array_Count)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Union_Array_Count unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Big_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Big_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Big_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_List.Big_Record_10M's refer Big_Record_10M_Len should >= 0")
	}
	if this.Big_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_List.Big_Record_10M's refer Big_Record_10M_Len should <= count 10000000")
	}

	if this.Big_Record_10M == nil {
		this.Big_Record_10M = make([]byte, int(this.Big_Record_10M_Len))
	}

	referBig_Record_10M := this.Big_Record_10M[:this.Big_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referBig_Record_10M)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Big_Record_10M pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Small_Record_10M_Len)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Small_Record_10M_Len unpack error\n" + err.Error())
	}

	if this.Small_Record_10M_Len < 0 {
		return errors.New("Table_10M_Complex_List.Small_Record_10M's refer Small_Record_10M_Len should >= 0")
	}
	if this.Small_Record_10M_Len > 10000000 {
		return errors.New("Table_10M_Complex_List.Small_Record_10M's refer Small_Record_10M_Len should <= count 10000000")
	}

	if this.Small_Record_10M == nil {
		this.Small_Record_10M = make([]byte, int(this.Small_Record_10M_Len))
	}

	referSmall_Record_10M := this.Small_Record_10M[:this.Small_Record_10M_Len]
	err = binary.Read(r, binary.BigEndian, referSmall_Record_10M)
	if err != nil {
		return errors.New("Table_10M_Complex_List.Small_Record_10M pack error\n" + err.Error())
	}

	return err
}

const (
	Table_8Key_GenericBaseVersion    uint32 = 6
	Table_8Key_GenericCurrentVersion uint32 = 6
)

var Table_8Key_GenericDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "K2_6223E1Fbf122Fb8B656631F4B99C",
	PrimaryKey:    "K1_6223E1Fbf122Fb8B656631F4B99C,K2_6223E1Fbf122Fb8B656631F4B99C,K3_6223E1Fbf122Fb8B656631F4B99C,K4_6223E1Fbf122Fb8B656631F4B99C,K5_6223E1Fbf122Fb8B656631F4B99C,K6_6223E1Fbf122Fb8B656631F4B99C,K7_6223E1Fbf122Fb8B656631F4B99C,K8_6223E1Fbf122Fb8B656631F4B99C",
	Index2Column: map[string]string{
		"Index8": "K1_6223E1Fbf122Fb8B656631F4B99C,K2_6223E1Fbf122Fb8B656631F4B99C,K3_6223E1Fbf122Fb8B656631F4B99C,K4_6223E1Fbf122Fb8B656631F4B99C,K5_6223E1Fbf122Fb8B656631F4B99C,K6_6223E1Fbf122Fb8B656631F4B99C,K7_6223E1Fbf122Fb8B656631F4B99C,K8_6223E1Fbf122Fb8B656631F4B99C",
		"Index2": "K1_6223E1Fbf122Fb8B656631F4B99C, K2_6223E1Fbf122Fb8B656631F4B99C",
		"Index3": "K2_6223E1Fbf122Fb8B656631F4B99C, K3_6223E1Fbf122Fb8B656631F4B99C",
		"Index1": "K2_6223E1Fbf122Fb8B656631F4B99C",
		"Index6": "K2_6223E1Fbf122Fb8B656631F4B99C, K6_6223E1Fbf122Fb8B656631F4B99C",
		"Index7": "K2_6223E1Fbf122Fb8B656631F4B99C, K7_6223E1Fbf122Fb8B656631F4B99C",
		"Index4": "K2_6223E1Fbf122Fb8B656631F4B99C, K4_6223E1Fbf122Fb8B656631F4B99C",
		"Index5": "K2_6223E1Fbf122Fb8B656631F4B99C, K5_6223E1Fbf122Fb8B656631F4B99C",
	},
}

// Table_8Key_Generic
type Table_8Key_Generic struct {
	K1_6223E1Fbf122Fb8B656631F4B99C int8 `tdr_field:"k1_6223e1fbf122fb8b656631f4b99c"`

	K2_6223E1Fbf122Fb8B656631F4B99C string `tdr_field:"k2_6223e1fbf122fb8b656631f4b99c"`

	K3_6223E1Fbf122Fb8B656631F4B99C byte `tdr_field:"k3_6223e1fbf122fb8b656631f4b99c"`

	K4_6223E1Fbf122Fb8B656631F4B99C int16 `tdr_field:"k4_6223e1fbf122fb8b656631f4b99c"`

	K5_6223E1Fbf122Fb8B656631F4B99C uint16 `tdr_field:"k5_6223e1fbf122fb8b656631f4b99c"`

	K6_6223E1Fbf122Fb8B656631F4B99C int32 `tdr_field:"k6_6223e1fbf122fb8b656631f4b99c"`

	K7_6223E1Fbf122Fb8B656631F4B99C uint32 `tdr_field:"k7_6223e1fbf122fb8b656631f4b99c"`

	K8_6223E1Fbf122Fb8B656631F4B99C string `tdr_field:"k8_6223e1fbf122fb8b656631f4b99c"`

	Level int32 `tdr_field:"level"`

	Count byte `tdr_field:"count"`

	Info string `tdr_field:"info"`

	Float_Score float32 `tdr_field:"float_score"`

	Double_Score float64 `tdr_field:"double_score"`

	Items []uint64 `tdr_field:"items" tdr_count:"10" tdr_refer:"Count"`

	Big_Record_1 string `tdr_field:"big_record_1"`

	Big_Record_2 string `tdr_field:"big_record_2"`

	Big_Record_3 string `tdr_field:"big_record_3"`

	Big_Record_4 string `tdr_field:"big_record_4"`

	Big_Record_5 string `tdr_field:"big_record_5"`

	C_Int8 int8 `tdr_field:"c_int8"`

	C_Uint8 byte `tdr_field:"c_uint8"`

	C_Int16 int16 `tdr_field:"c_int16"`

	C_Uint16 uint16 `tdr_field:"c_uint16"`

	C_Int32 int32 `tdr_field:"c_int32"`

	C_Uint32 uint32 `tdr_field:"c_uint32"`

	C_Int64 int64 `tdr_field:"c_int64"`

	C_Uint64 uint64 `tdr_field:"c_uint64"`

	C_Float float32 `tdr_field:"c_float"`

	C_Double float64 `tdr_field:"c_double"`

	C_String string `tdr_field:"c_string"`

	C_Binary []int8 `tdr_field:"c_binary" tdr_count:"100" tdr_refer:"C_Uint32"`

	Max_String string `tdr_field:"max_string"`

	Binary_Count uint32 `tdr_field:"binary_count"`

	Max_Binary []int8 `tdr_field:"max_binary" tdr_count:"131070" tdr_refer:"Binary_Count"`

	Selector int16 `tdr_field:"selector"`

	Single_Struct *Struct_Type `tdr_field:"single_struct"`

	Simple_Struct *Simple_Struct `tdr_field:"simple_struct"`

	Single_Union_Selector int8 `tdr_field:"single_union_selector"`

	Single_Union *Union_Type `tdr_field:"single_union" tdr_select:"Single_Union_Selector"`

	Array_Count uint32 `tdr_field:"array_count"`

	Array []*TableInfo `tdr_field:"array" tdr_count:"3" tdr_refer:"Array_Count"`

	C_Union *Union_Type `tdr_field:"c_union" tdr_select:"Selector"`

	Union_Array []*Union_Type `tdr_field:"union_array" tdr_count:"3" tdr_refer:"Array_Count" tdr_select:"Selector"`

	C_Struct *Struct_Type `tdr_field:"c_struct"`

	Struct_Array []*Struct_Type `tdr_field:"struct_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Simple_Array_Count int32 `tdr_field:"simple_array_count"`

	Int_Array []int32 `tdr_field:"int_array" tdr_count:"5" tdr_refer:"Simple_Array_Count"`

	Double_Array []float64 `tdr_field:"double_array" tdr_count:"3" tdr_refer:"Simple_Array_Count"`

	Big_Record_1M_Len int32 `tdr_field:"big_record_1M_len"`

	Big_Record_1M []byte `tdr_field:"big_record_1M" tdr_count:"10" tdr_refer:"Big_Record_1M_Len"`

	Small_Record_1M_Len int32 `tdr_field:"small_record_1M_len"`

	Small_Record_1M []byte `tdr_field:"small_record_1M" tdr_count:"10" tdr_refer:"Small_Record_1M_Len"`
}

func NewTable_8Key_Generic() *Table_8Key_Generic {
	obj := new(Table_8Key_Generic)
	obj.Init()
	return obj
}

func (this *Table_8Key_Generic) GetBaseVersion() uint32 {
	return Table_8Key_GenericBaseVersion
}

func (this *Table_8Key_Generic) GetCurrentVersion() uint32 {
	return Table_8Key_GenericCurrentVersion
}

func (this *Table_8Key_Generic) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_8Key_GenericDBFeilds
}

func (this *Table_8Key_Generic) Init() {

	this.Level = 1

	this.Count = 0

	this.Float_Score = 0

	this.Double_Score = 0

	this.C_Int8 = -1

	this.C_Uint8 = 2

	this.C_Int16 = -3

	this.C_Uint16 = 4

	this.C_Int32 = -5

	this.C_Uint32 = 6

	this.C_Int64 = -7

	this.C_Float = 1.23456789

	this.C_Double = 9.87654321

	this.C_String = "123456789"

	this.Max_String = "123456789"

	this.Binary_Count = 10

	this.Single_Struct = NewStruct_Type()

	this.Simple_Struct = NewSimple_Struct()

	this.Single_Union_Selector = 0

	this.Single_Union = NewUnion_Type(int64(this.Single_Union_Selector))

	this.C_Union = NewUnion_Type(int64(this.Selector))

	this.C_Struct = NewStruct_Type()

	this.Big_Record_1M_Len = 0

	this.Small_Record_1M_Len = 0

}

func (this *Table_8Key_Generic) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_8Key_Generic Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_8Key_Generic) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_8Key_GenericCurrentVersion {
		cutVer = Table_8Key_GenericCurrentVersion
	}
	// check cut version
	if cutVer < Table_8Key_GenericBaseVersion {
		return errors.New("Table_8Key_Generic cut version must large than Table_8Key_GenericBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.K1_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K1_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.K2_6223E1Fbf122Fb8B656631F4B99C))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.K2_6223E1Fbf122Fb8B656631F4B99C string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.K2_6223E1Fbf122Fb8B656631F4B99C), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.K2_6223E1Fbf122Fb8B656631F4B99C string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K3_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K3_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K4_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K4_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K5_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K5_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K6_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K6_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K7_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K7_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.K8_6223E1Fbf122Fb8B656631F4B99C))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.K8_6223E1Fbf122Fb8B656631F4B99C string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.K8_6223E1Fbf122Fb8B656631F4B99C), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.K8_6223E1Fbf122Fb8B656631F4B99C string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_8Key_Generic.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Info))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Info string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Info), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Info string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Float_Score)
	if err != nil {
		return errors.New("Table_8Key_Generic.Float_Score pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Double_Score)
	if err != nil {
		return errors.New("Table_8Key_Generic.Double_Score pack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_8Key_Generic.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_8Key_Generic.Items's refer Count should <= count 10")
	}
	if len(this.Items) < int(this.Count) {
		return errors.New("Table_8Key_Generic.Items's length should > Count")
	}
	if this.Count > 0 {
		referItems := this.Items[:this.Count]
		err = binary.Write(w, binary.BigEndian, referItems)
		if err != nil {
			return errors.New("Table_8Key_Generic.Items pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_1))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_1), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_2))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_2), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_3))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_3), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_4))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_4), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_5))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_5 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_5), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_5 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int8)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint8)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int16)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint16)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int32)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint32)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int64)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint64)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Float)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Double)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.C_String))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.C_String), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.C_String string content pack error\n" + err.Error())
	}

	if this.C_Uint32 < 0 {
		return errors.New("Table_8Key_Generic.C_Binary's refer C_Uint32 should >= 0")
	}
	if this.C_Uint32 > 100 {
		return errors.New("Table_8Key_Generic.C_Binary's refer C_Uint32 should <= count 100")
	}
	if len(this.C_Binary) < int(this.C_Uint32) {
		return errors.New("Table_8Key_Generic.C_Binary's length should > C_Uint32")
	}
	if this.C_Uint32 > 0 {
		referC_Binary := this.C_Binary[:this.C_Uint32]
		err = binary.Write(w, binary.BigEndian, referC_Binary)
		if err != nil {
			return errors.New("Table_8Key_Generic.C_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Max_String))+1)
	if err != nil {
		return errors.New("Table_8Key_Generic.Max_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Max_String), 0))
	if err != nil {
		return errors.New("Table_8Key_Generic.Max_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Binary_Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Binary_Count pack error\n" + err.Error())
	}

	if this.Binary_Count < 0 {
		return errors.New("Table_8Key_Generic.Max_Binary's refer Binary_Count should >= 0")
	}
	if this.Binary_Count > 131070 {
		return errors.New("Table_8Key_Generic.Max_Binary's refer Binary_Count should <= count 131070")
	}
	if len(this.Max_Binary) < int(this.Binary_Count) {
		return errors.New("Table_8Key_Generic.Max_Binary's length should > Binary_Count")
	}
	if this.Binary_Count > 0 {
		referMax_Binary := this.Max_Binary[:this.Binary_Count]
		err = binary.Write(w, binary.BigEndian, referMax_Binary)
		if err != nil {
			return errors.New("Table_8Key_Generic.Max_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Selector)
	if err != nil {
		return errors.New("Table_8Key_Generic.Selector pack error\n" + err.Error())
	}

	err = this.Single_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_8Key_Generic.Single_Struct pack error\n" + err.Error())
	}

	err = this.Simple_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_8Key_Generic.Simple_Struct pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Single_Union_Selector)
	if err != nil {
		return errors.New("Table_8Key_Generic.Single_Union_Selector pack error\n" + err.Error())
	}

	err = this.Single_Union.PackTo(cutVer, w, int64(this.Single_Union_Selector))
	if err != nil {
		return errors.New("Table_8Key_Generic.Single_Union pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Array's refer Array_Count should <= count 3")
	}
	if len(this.Array) < int(this.Array_Count) {
		return errors.New("Table_8Key_Generic.Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_8Key_Generic.Array pack error\n" + err.Error())
			}

		}
	}

	err = this.C_Union.PackTo(cutVer, w, int64(this.Selector))
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Union pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Union_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Union_Array's refer Array_Count should <= count 3")
	}
	if len(this.Union_Array) < int(this.Array_Count) {
		return errors.New("Table_8Key_Generic.Union_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Union_Array[i].PackTo(cutVer, w, int64(this.Selector))
			if err != nil {
				return errors.New("Table_8Key_Generic.Union_Array pack error\n" + err.Error())
			}

		}
	}

	err = this.C_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Struct pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Struct_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Struct_Array's refer Array_Count should <= count 3")
	}
	if len(this.Struct_Array) < int(this.Array_Count) {
		return errors.New("Table_8Key_Generic.Struct_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Struct_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_8Key_Generic.Struct_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_8Key_Generic.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Simple_Array_Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Simple_Array_Count pack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Int_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 5 {
		return errors.New("Table_8Key_Generic.Int_Array's refer Simple_Array_Count should <= count 5")
	}
	if len(this.Int_Array) < int(this.Simple_Array_Count) {
		return errors.New("Table_8Key_Generic.Int_Array's length should > Simple_Array_Count")
	}
	if this.Simple_Array_Count > 0 {
		referInt_Array := this.Int_Array[:this.Simple_Array_Count]
		err = binary.Write(w, binary.BigEndian, referInt_Array)
		if err != nil {
			return errors.New("Table_8Key_Generic.Int_Array pack error\n" + err.Error())
		}
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Double_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Double_Array's refer Simple_Array_Count should <= count 3")
	}
	if len(this.Double_Array) < int(this.Simple_Array_Count) {
		return errors.New("Table_8Key_Generic.Double_Array's length should > Simple_Array_Count")
	}
	if this.Simple_Array_Count > 0 {
		referDouble_Array := this.Double_Array[:this.Simple_Array_Count]
		err = binary.Write(w, binary.BigEndian, referDouble_Array)
		if err != nil {
			return errors.New("Table_8Key_Generic.Double_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Big_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1M_Len pack error\n" + err.Error())
	}

	if this.Big_Record_1M_Len < 0 {
		return errors.New("Table_8Key_Generic.Big_Record_1M's refer Big_Record_1M_Len should >= 0")
	}
	if this.Big_Record_1M_Len > 10 {
		return errors.New("Table_8Key_Generic.Big_Record_1M's refer Big_Record_1M_Len should <= count 10")
	}
	if len(this.Big_Record_1M) < int(this.Big_Record_1M_Len) {
		return errors.New("Table_8Key_Generic.Big_Record_1M's length should > Big_Record_1M_Len")
	}
	if this.Big_Record_1M_Len > 0 {
		referBig_Record_1M := this.Big_Record_1M[:this.Big_Record_1M_Len]
		err = binary.Write(w, binary.BigEndian, referBig_Record_1M)
		if err != nil {
			return errors.New("Table_8Key_Generic.Big_Record_1M pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Small_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_Generic.Small_Record_1M_Len pack error\n" + err.Error())
	}

	if this.Small_Record_1M_Len < 0 {
		return errors.New("Table_8Key_Generic.Small_Record_1M's refer Small_Record_1M_Len should >= 0")
	}
	if this.Small_Record_1M_Len > 10 {
		return errors.New("Table_8Key_Generic.Small_Record_1M's refer Small_Record_1M_Len should <= count 10")
	}
	if len(this.Small_Record_1M) < int(this.Small_Record_1M_Len) {
		return errors.New("Table_8Key_Generic.Small_Record_1M's length should > Small_Record_1M_Len")
	}
	if this.Small_Record_1M_Len > 0 {
		referSmall_Record_1M := this.Small_Record_1M[:this.Small_Record_1M_Len]
		err = binary.Write(w, binary.BigEndian, referSmall_Record_1M)
		if err != nil {
			return errors.New("Table_8Key_Generic.Small_Record_1M pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_8Key_Generic) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_8Key_Generic data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_8Key_Generic) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_8Key_GenericCurrentVersion {
		cutVer = Table_8Key_GenericCurrentVersion
	}
	// check version
	if cutVer < Table_8Key_GenericBaseVersion {
		errors.New("Table_8Key_Generic cut version must large than Table_8Key_GenericBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.K1_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K1_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	var k2_6223e1fbf122fb8b656631f4b99cSize uint32
	err = binary.Read(r, binary.BigEndian, &k2_6223e1fbf122fb8b656631f4b99cSize)
	if err != nil {
		return errors.New("Table_8Key_Generic.K2_6223E1Fbf122Fb8B656631F4B99C string size unpack error\n" + err.Error())
	}

	k2_6223e1fbf122fb8b656631f4b99cBytes := make([]byte, k2_6223e1fbf122fb8b656631f4b99cSize)
	err = binary.Read(r, binary.BigEndian, k2_6223e1fbf122fb8b656631f4b99cBytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.K2_6223E1Fbf122Fb8B656631F4B99C string content unpack error\n" + err.Error())
	}
	this.K2_6223E1Fbf122Fb8B656631F4B99C = string(k2_6223e1fbf122fb8b656631f4b99cBytes[:len(k2_6223e1fbf122fb8b656631f4b99cBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.K3_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K3_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K4_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K4_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K5_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K5_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K6_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K6_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K7_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_Generic.K7_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	var k8_6223e1fbf122fb8b656631f4b99cSize uint32
	err = binary.Read(r, binary.BigEndian, &k8_6223e1fbf122fb8b656631f4b99cSize)
	if err != nil {
		return errors.New("Table_8Key_Generic.K8_6223E1Fbf122Fb8B656631F4B99C string size unpack error\n" + err.Error())
	}

	k8_6223e1fbf122fb8b656631f4b99cBytes := make([]byte, k8_6223e1fbf122fb8b656631f4b99cSize)
	err = binary.Read(r, binary.BigEndian, k8_6223e1fbf122fb8b656631f4b99cBytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.K8_6223E1Fbf122Fb8B656631F4B99C string content unpack error\n" + err.Error())
	}
	this.K8_6223E1Fbf122Fb8B656631F4B99C = string(k8_6223e1fbf122fb8b656631f4b99cBytes[:len(k8_6223e1fbf122fb8b656631f4b99cBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_8Key_Generic.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Count unpack error\n" + err.Error())
	}

	var infoSize uint32
	err = binary.Read(r, binary.BigEndian, &infoSize)
	if err != nil {
		return errors.New("Table_8Key_Generic.Info string size unpack error\n" + err.Error())
	}

	infoBytes := make([]byte, infoSize)
	err = binary.Read(r, binary.BigEndian, infoBytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Info string content unpack error\n" + err.Error())
	}
	this.Info = string(infoBytes[:len(infoBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Float_Score)
	if err != nil {
		return errors.New("Table_8Key_Generic.Float_Score unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Double_Score)
	if err != nil {
		return errors.New("Table_8Key_Generic.Double_Score unpack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_8Key_Generic.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_8Key_Generic.Items's refer Count should <= count 10")
	}

	if this.Items == nil {
		this.Items = make([]uint64, int(this.Count))
	}

	referItems := this.Items[:this.Count]
	err = binary.Read(r, binary.BigEndian, referItems)
	if err != nil {
		return errors.New("Table_8Key_Generic.Items pack error\n" + err.Error())
	}

	var big_record_1Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_1Size)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1 string size unpack error\n" + err.Error())
	}

	big_record_1Bytes := make([]byte, big_record_1Size)
	err = binary.Read(r, binary.BigEndian, big_record_1Bytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1 string content unpack error\n" + err.Error())
	}
	this.Big_Record_1 = string(big_record_1Bytes[:len(big_record_1Bytes)-1])

	var big_record_2Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_2Size)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_2 string size unpack error\n" + err.Error())
	}

	big_record_2Bytes := make([]byte, big_record_2Size)
	err = binary.Read(r, binary.BigEndian, big_record_2Bytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_2 string content unpack error\n" + err.Error())
	}
	this.Big_Record_2 = string(big_record_2Bytes[:len(big_record_2Bytes)-1])

	var big_record_3Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_3Size)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_3 string size unpack error\n" + err.Error())
	}

	big_record_3Bytes := make([]byte, big_record_3Size)
	err = binary.Read(r, binary.BigEndian, big_record_3Bytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_3 string content unpack error\n" + err.Error())
	}
	this.Big_Record_3 = string(big_record_3Bytes[:len(big_record_3Bytes)-1])

	var big_record_4Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_4Size)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_4 string size unpack error\n" + err.Error())
	}

	big_record_4Bytes := make([]byte, big_record_4Size)
	err = binary.Read(r, binary.BigEndian, big_record_4Bytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_4 string content unpack error\n" + err.Error())
	}
	this.Big_Record_4 = string(big_record_4Bytes[:len(big_record_4Bytes)-1])

	var big_record_5Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_5Size)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_5 string size unpack error\n" + err.Error())
	}

	big_record_5Bytes := make([]byte, big_record_5Size)
	err = binary.Read(r, binary.BigEndian, big_record_5Bytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_5 string content unpack error\n" + err.Error())
	}
	this.Big_Record_5 = string(big_record_5Bytes[:len(big_record_5Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.C_Int8)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint8)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int16)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint16)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int32)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint32)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int64)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint64)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Float)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Double)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Double unpack error\n" + err.Error())
	}

	var c_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &c_stringSize)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_String string size unpack error\n" + err.Error())
	}

	c_stringBytes := make([]byte, c_stringSize)
	err = binary.Read(r, binary.BigEndian, c_stringBytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_String string content unpack error\n" + err.Error())
	}
	this.C_String = string(c_stringBytes[:len(c_stringBytes)-1])

	if this.C_Uint32 < 0 {
		return errors.New("Table_8Key_Generic.C_Binary's refer C_Uint32 should >= 0")
	}
	if this.C_Uint32 > 100 {
		return errors.New("Table_8Key_Generic.C_Binary's refer C_Uint32 should <= count 100")
	}

	if this.C_Binary == nil {
		this.C_Binary = make([]int8, int(this.C_Uint32))
	}

	referC_Binary := this.C_Binary[:this.C_Uint32]
	err = binary.Read(r, binary.BigEndian, referC_Binary)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Binary pack error\n" + err.Error())
	}

	var max_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &max_stringSize)
	if err != nil {
		return errors.New("Table_8Key_Generic.Max_String string size unpack error\n" + err.Error())
	}

	max_stringBytes := make([]byte, max_stringSize)
	err = binary.Read(r, binary.BigEndian, max_stringBytes)
	if err != nil {
		return errors.New("Table_8Key_Generic.Max_String string content unpack error\n" + err.Error())
	}
	this.Max_String = string(max_stringBytes[:len(max_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Binary_Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Binary_Count unpack error\n" + err.Error())
	}

	if this.Binary_Count < 0 {
		return errors.New("Table_8Key_Generic.Max_Binary's refer Binary_Count should >= 0")
	}
	if this.Binary_Count > 131070 {
		return errors.New("Table_8Key_Generic.Max_Binary's refer Binary_Count should <= count 131070")
	}

	if this.Max_Binary == nil {
		this.Max_Binary = make([]int8, int(this.Binary_Count))
	}

	referMax_Binary := this.Max_Binary[:this.Binary_Count]
	err = binary.Read(r, binary.BigEndian, referMax_Binary)
	if err != nil {
		return errors.New("Table_8Key_Generic.Max_Binary pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Selector)
	if err != nil {
		return errors.New("Table_8Key_Generic.Selector unpack error\n" + err.Error())
	}

	err = this.Single_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_8Key_Generic.Single_Struct unpack error\n" + err.Error())
	}

	err = this.Simple_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_8Key_Generic.Simple_Struct unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Single_Union_Selector)
	if err != nil {
		return errors.New("Table_8Key_Generic.Single_Union_Selector unpack error\n" + err.Error())
	}

	err = this.Single_Union.UnpackFrom(cutVer, r, int64(this.Single_Union_Selector))
	if err != nil {
		return errors.New("Table_8Key_Generic.Single_Union unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Array's refer Array_Count should <= count 3")
	}

	if this.Array == nil {
		this.Array = make([]*TableInfo, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Array[i] = NewTableInfo()
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_8Key_Generic.Array unpack error\n" + err.Error())
		}

	}

	err = this.C_Union.UnpackFrom(cutVer, r, int64(this.Selector))
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Union unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Union_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Union_Array's refer Array_Count should <= count 3")
	}

	if this.Union_Array == nil {
		this.Union_Array = make([]*Union_Type, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Union_Array[i] = NewUnion_Type(int64(this.Selector))
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Union_Array[i].UnpackFrom(cutVer, r, int64(this.Selector))
		if err != nil {
			return errors.New("Table_8Key_Generic.Union_Array unpack error\n" + err.Error())
		}

	}

	err = this.C_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_8Key_Generic.C_Struct unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Struct_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Struct_Array's refer Array_Count should <= count 3")
	}

	if this.Struct_Array == nil {
		this.Struct_Array = make([]*Struct_Type, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Struct_Array[i] = NewStruct_Type()
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Struct_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_8Key_Generic.Struct_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_8Key_Generic.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Simple_Array_Count)
	if err != nil {
		return errors.New("Table_8Key_Generic.Simple_Array_Count unpack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Int_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 5 {
		return errors.New("Table_8Key_Generic.Int_Array's refer Simple_Array_Count should <= count 5")
	}

	if this.Int_Array == nil {
		this.Int_Array = make([]int32, int(this.Simple_Array_Count))
	}

	referInt_Array := this.Int_Array[:this.Simple_Array_Count]
	err = binary.Read(r, binary.BigEndian, referInt_Array)
	if err != nil {
		return errors.New("Table_8Key_Generic.Int_Array pack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_Generic.Double_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 3 {
		return errors.New("Table_8Key_Generic.Double_Array's refer Simple_Array_Count should <= count 3")
	}

	if this.Double_Array == nil {
		this.Double_Array = make([]float64, int(this.Simple_Array_Count))
	}

	referDouble_Array := this.Double_Array[:this.Simple_Array_Count]
	err = binary.Read(r, binary.BigEndian, referDouble_Array)
	if err != nil {
		return errors.New("Table_8Key_Generic.Double_Array pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Big_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1M_Len unpack error\n" + err.Error())
	}

	if this.Big_Record_1M_Len < 0 {
		return errors.New("Table_8Key_Generic.Big_Record_1M's refer Big_Record_1M_Len should >= 0")
	}
	if this.Big_Record_1M_Len > 10 {
		return errors.New("Table_8Key_Generic.Big_Record_1M's refer Big_Record_1M_Len should <= count 10")
	}

	if this.Big_Record_1M == nil {
		this.Big_Record_1M = make([]byte, int(this.Big_Record_1M_Len))
	}

	referBig_Record_1M := this.Big_Record_1M[:this.Big_Record_1M_Len]
	err = binary.Read(r, binary.BigEndian, referBig_Record_1M)
	if err != nil {
		return errors.New("Table_8Key_Generic.Big_Record_1M pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Small_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_Generic.Small_Record_1M_Len unpack error\n" + err.Error())
	}

	if this.Small_Record_1M_Len < 0 {
		return errors.New("Table_8Key_Generic.Small_Record_1M's refer Small_Record_1M_Len should >= 0")
	}
	if this.Small_Record_1M_Len > 10 {
		return errors.New("Table_8Key_Generic.Small_Record_1M's refer Small_Record_1M_Len should <= count 10")
	}

	if this.Small_Record_1M == nil {
		this.Small_Record_1M = make([]byte, int(this.Small_Record_1M_Len))
	}

	referSmall_Record_1M := this.Small_Record_1M[:this.Small_Record_1M_Len]
	err = binary.Read(r, binary.BigEndian, referSmall_Record_1M)
	if err != nil {
		return errors.New("Table_8Key_Generic.Small_Record_1M pack error\n" + err.Error())
	}

	return err
}

const (
	Table_8Key_ListBaseVersion    uint32 = 6
	Table_8Key_ListCurrentVersion uint32 = 6
)

var Table_8Key_ListDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "K2_6223E1Fbf122Fb8B656631F4B99C",
	PrimaryKey:    "K1_6223E1Fbf122Fb8B656631F4B99C,K2_6223E1Fbf122Fb8B656631F4B99C,K3_6223E1Fbf122Fb8B656631F4B99C,K4_6223E1Fbf122Fb8B656631F4B99C,K5_6223E1Fbf122Fb8B656631F4B99C,K6_6223E1Fbf122Fb8B656631F4B99C,K7_6223E1Fbf122Fb8B656631F4B99C",
}

// Table_8Key_List
type Table_8Key_List struct {
	K1_6223E1Fbf122Fb8B656631F4B99C int8 `tdr_field:"k1_6223e1fbf122fb8b656631f4b99c"`

	K2_6223E1Fbf122Fb8B656631F4B99C string `tdr_field:"k2_6223e1fbf122fb8b656631f4b99c"`

	K3_6223E1Fbf122Fb8B656631F4B99C byte `tdr_field:"k3_6223e1fbf122fb8b656631f4b99c"`

	K4_6223E1Fbf122Fb8B656631F4B99C int16 `tdr_field:"k4_6223e1fbf122fb8b656631f4b99c"`

	K5_6223E1Fbf122Fb8B656631F4B99C uint16 `tdr_field:"k5_6223e1fbf122fb8b656631f4b99c"`

	K6_6223E1Fbf122Fb8B656631F4B99C int32 `tdr_field:"k6_6223e1fbf122fb8b656631f4b99c"`

	K7_6223E1Fbf122Fb8B656631F4B99C uint32 `tdr_field:"k7_6223e1fbf122fb8b656631f4b99c"`

	Value1 string `tdr_field:"value1"`

	Value2 string `tdr_field:"value2"`

	Level int32 `tdr_field:"level"`

	Count byte `tdr_field:"count"`

	Info string `tdr_field:"info"`

	Float_Score float32 `tdr_field:"float_score"`

	Double_Score float64 `tdr_field:"double_score"`

	Items []uint64 `tdr_field:"items" tdr_count:"10" tdr_refer:"Count"`

	Big_Record_1 string `tdr_field:"big_record_1"`

	Big_Record_2 string `tdr_field:"big_record_2"`

	Big_Record_3 string `tdr_field:"big_record_3"`

	Big_Record_4 string `tdr_field:"big_record_4"`

	Big_Record_5 string `tdr_field:"big_record_5"`

	C_Int8 int8 `tdr_field:"c_int8"`

	C_Uint8 byte `tdr_field:"c_uint8"`

	C_Int16 int16 `tdr_field:"c_int16"`

	C_Uint16 uint16 `tdr_field:"c_uint16"`

	C_Int32 int32 `tdr_field:"c_int32"`

	C_Uint32 uint32 `tdr_field:"c_uint32"`

	C_Int64 int64 `tdr_field:"c_int64"`

	C_Uint64 uint64 `tdr_field:"c_uint64"`

	C_Float float32 `tdr_field:"c_float"`

	C_Double float64 `tdr_field:"c_double"`

	C_String string `tdr_field:"c_string"`

	C_Binary []int8 `tdr_field:"c_binary" tdr_count:"100" tdr_refer:"C_Uint32"`

	Max_String string `tdr_field:"max_string"`

	Binary_Count uint32 `tdr_field:"binary_count"`

	Max_Binary []int8 `tdr_field:"max_binary" tdr_count:"131070" tdr_refer:"Binary_Count"`

	Selector int16 `tdr_field:"selector"`

	Single_Struct *Struct_Type `tdr_field:"single_struct"`

	Simple_Struct *Simple_Struct `tdr_field:"simple_struct"`

	Single_Union_Selector int8 `tdr_field:"single_union_selector"`

	Single_Union *Union_Type `tdr_field:"single_union" tdr_select:"Single_Union_Selector"`

	Array_Count uint32 `tdr_field:"array_count"`

	Array []*TableInfo `tdr_field:"array" tdr_count:"3" tdr_refer:"Array_Count"`

	C_Union *Union_Type `tdr_field:"c_union" tdr_select:"Selector"`

	Union_Array []*Union_Type `tdr_field:"union_array" tdr_count:"3" tdr_refer:"Array_Count" tdr_select:"Selector"`

	C_Struct *Struct_Type `tdr_field:"c_struct"`

	Struct_Array []*Struct_Type `tdr_field:"struct_array" tdr_count:"3" tdr_refer:"Array_Count"`

	Bound_31_Byte_Test_012345678901 int32 `tdr_field:"bound_31_byte_test_012345678901"`

	Simple_Array_Count int32 `tdr_field:"simple_array_count"`

	Int_Array []int32 `tdr_field:"int_array" tdr_count:"5" tdr_refer:"Simple_Array_Count"`

	Double_Array []float64 `tdr_field:"double_array" tdr_count:"3" tdr_refer:"Simple_Array_Count"`

	Big_Record_1M_Len int32 `tdr_field:"big_record_1M_len"`

	Big_Record_1M []byte `tdr_field:"big_record_1M" tdr_count:"10" tdr_refer:"Big_Record_1M_Len"`

	Small_Record_1M_Len int32 `tdr_field:"small_record_1M_len"`

	Small_Record_1M []byte `tdr_field:"small_record_1M" tdr_count:"10" tdr_refer:"Small_Record_1M_Len"`
}

func NewTable_8Key_List() *Table_8Key_List {
	obj := new(Table_8Key_List)
	obj.Init()
	return obj
}

func (this *Table_8Key_List) GetBaseVersion() uint32 {
	return Table_8Key_ListBaseVersion
}

func (this *Table_8Key_List) GetCurrentVersion() uint32 {
	return Table_8Key_ListCurrentVersion
}

func (this *Table_8Key_List) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_8Key_ListDBFeilds
}

func (this *Table_8Key_List) Init() {

	this.Level = 1

	this.Count = 0

	this.Float_Score = 0

	this.Double_Score = 0

	this.C_Int8 = -1

	this.C_Uint8 = 2

	this.C_Int16 = -3

	this.C_Uint16 = 4

	this.C_Int32 = -5

	this.C_Uint32 = 6

	this.C_Int64 = -7

	this.C_Float = 1.23456789

	this.C_Double = 9.87654321

	this.C_String = "123456789"

	this.Max_String = "123456789"

	this.Binary_Count = 10

	this.Single_Struct = NewStruct_Type()

	this.Simple_Struct = NewSimple_Struct()

	this.Single_Union_Selector = 0

	this.Single_Union = NewUnion_Type(int64(this.Single_Union_Selector))

	this.C_Union = NewUnion_Type(int64(this.Selector))

	this.C_Struct = NewStruct_Type()

	this.Big_Record_1M_Len = 0

	this.Small_Record_1M_Len = 0

}

func (this *Table_8Key_List) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_8Key_List Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_8Key_List) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_8Key_ListCurrentVersion {
		cutVer = Table_8Key_ListCurrentVersion
	}
	// check cut version
	if cutVer < Table_8Key_ListBaseVersion {
		return errors.New("Table_8Key_List cut version must large than Table_8Key_ListBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.K1_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K1_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.K2_6223E1Fbf122Fb8B656631F4B99C))+1)
	if err != nil {
		return errors.New("Table_8Key_List.K2_6223E1Fbf122Fb8B656631F4B99C string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.K2_6223E1Fbf122Fb8B656631F4B99C), 0))
	if err != nil {
		return errors.New("Table_8Key_List.K2_6223E1Fbf122Fb8B656631F4B99C string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K3_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K3_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K4_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K4_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K5_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K5_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K6_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K6_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.K7_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K7_6223E1Fbf122Fb8B656631F4B99C pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value1))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Value1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value1), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Value1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value2))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Value2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value2), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Value2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_8Key_List.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("Table_8Key_List.Count pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Info))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Info string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Info), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Info string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Float_Score)
	if err != nil {
		return errors.New("Table_8Key_List.Float_Score pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Double_Score)
	if err != nil {
		return errors.New("Table_8Key_List.Double_Score pack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_8Key_List.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_8Key_List.Items's refer Count should <= count 10")
	}
	if len(this.Items) < int(this.Count) {
		return errors.New("Table_8Key_List.Items's length should > Count")
	}
	if this.Count > 0 {
		referItems := this.Items[:this.Count]
		err = binary.Write(w, binary.BigEndian, referItems)
		if err != nil {
			return errors.New("Table_8Key_List.Items pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_1))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_1), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_2))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_2), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_3))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_3), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_4))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_4), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Big_Record_5))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_5 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Big_Record_5), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_5 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int8)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint8)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint8 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int16)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint16)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint16 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int32)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint32)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint32 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Int64)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Uint64)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint64 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Float)
	if err != nil {
		return errors.New("Table_8Key_List.C_Float pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.C_Double)
	if err != nil {
		return errors.New("Table_8Key_List.C_Double pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.C_String))+1)
	if err != nil {
		return errors.New("Table_8Key_List.C_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.C_String), 0))
	if err != nil {
		return errors.New("Table_8Key_List.C_String string content pack error\n" + err.Error())
	}

	if this.C_Uint32 < 0 {
		return errors.New("Table_8Key_List.C_Binary's refer C_Uint32 should >= 0")
	}
	if this.C_Uint32 > 100 {
		return errors.New("Table_8Key_List.C_Binary's refer C_Uint32 should <= count 100")
	}
	if len(this.C_Binary) < int(this.C_Uint32) {
		return errors.New("Table_8Key_List.C_Binary's length should > C_Uint32")
	}
	if this.C_Uint32 > 0 {
		referC_Binary := this.C_Binary[:this.C_Uint32]
		err = binary.Write(w, binary.BigEndian, referC_Binary)
		if err != nil {
			return errors.New("Table_8Key_List.C_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Max_String))+1)
	if err != nil {
		return errors.New("Table_8Key_List.Max_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Max_String), 0))
	if err != nil {
		return errors.New("Table_8Key_List.Max_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Binary_Count)
	if err != nil {
		return errors.New("Table_8Key_List.Binary_Count pack error\n" + err.Error())
	}

	if this.Binary_Count < 0 {
		return errors.New("Table_8Key_List.Max_Binary's refer Binary_Count should >= 0")
	}
	if this.Binary_Count > 131070 {
		return errors.New("Table_8Key_List.Max_Binary's refer Binary_Count should <= count 131070")
	}
	if len(this.Max_Binary) < int(this.Binary_Count) {
		return errors.New("Table_8Key_List.Max_Binary's length should > Binary_Count")
	}
	if this.Binary_Count > 0 {
		referMax_Binary := this.Max_Binary[:this.Binary_Count]
		err = binary.Write(w, binary.BigEndian, referMax_Binary)
		if err != nil {
			return errors.New("Table_8Key_List.Max_Binary pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Selector)
	if err != nil {
		return errors.New("Table_8Key_List.Selector pack error\n" + err.Error())
	}

	err = this.Single_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_8Key_List.Single_Struct pack error\n" + err.Error())
	}

	err = this.Simple_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_8Key_List.Simple_Struct pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Single_Union_Selector)
	if err != nil {
		return errors.New("Table_8Key_List.Single_Union_Selector pack error\n" + err.Error())
	}

	err = this.Single_Union.PackTo(cutVer, w, int64(this.Single_Union_Selector))
	if err != nil {
		return errors.New("Table_8Key_List.Single_Union pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Array_Count)
	if err != nil {
		return errors.New("Table_8Key_List.Array_Count pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_List.Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_List.Array's refer Array_Count should <= count 3")
	}
	if len(this.Array) < int(this.Array_Count) {
		return errors.New("Table_8Key_List.Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_8Key_List.Array pack error\n" + err.Error())
			}

		}
	}

	err = this.C_Union.PackTo(cutVer, w, int64(this.Selector))
	if err != nil {
		return errors.New("Table_8Key_List.C_Union pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_List.Union_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_List.Union_Array's refer Array_Count should <= count 3")
	}
	if len(this.Union_Array) < int(this.Array_Count) {
		return errors.New("Table_8Key_List.Union_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Union_Array[i].PackTo(cutVer, w, int64(this.Selector))
			if err != nil {
				return errors.New("Table_8Key_List.Union_Array pack error\n" + err.Error())
			}

		}
	}

	err = this.C_Struct.PackTo(cutVer, w)
	if err != nil {
		return errors.New("Table_8Key_List.C_Struct pack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_List.Struct_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_List.Struct_Array's refer Array_Count should <= count 3")
	}
	if len(this.Struct_Array) < int(this.Array_Count) {
		return errors.New("Table_8Key_List.Struct_Array's length should > Array_Count")
	}
	if this.Array_Count > 0 {
		for i := 0; i < int(this.Array_Count); i++ {
			err = this.Struct_Array[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("Table_8Key_List.Struct_Array pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_8Key_List.Bound_31_Byte_Test_012345678901 pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Simple_Array_Count)
	if err != nil {
		return errors.New("Table_8Key_List.Simple_Array_Count pack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_List.Int_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 5 {
		return errors.New("Table_8Key_List.Int_Array's refer Simple_Array_Count should <= count 5")
	}
	if len(this.Int_Array) < int(this.Simple_Array_Count) {
		return errors.New("Table_8Key_List.Int_Array's length should > Simple_Array_Count")
	}
	if this.Simple_Array_Count > 0 {
		referInt_Array := this.Int_Array[:this.Simple_Array_Count]
		err = binary.Write(w, binary.BigEndian, referInt_Array)
		if err != nil {
			return errors.New("Table_8Key_List.Int_Array pack error\n" + err.Error())
		}
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_List.Double_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 3 {
		return errors.New("Table_8Key_List.Double_Array's refer Simple_Array_Count should <= count 3")
	}
	if len(this.Double_Array) < int(this.Simple_Array_Count) {
		return errors.New("Table_8Key_List.Double_Array's length should > Simple_Array_Count")
	}
	if this.Simple_Array_Count > 0 {
		referDouble_Array := this.Double_Array[:this.Simple_Array_Count]
		err = binary.Write(w, binary.BigEndian, referDouble_Array)
		if err != nil {
			return errors.New("Table_8Key_List.Double_Array pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Big_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1M_Len pack error\n" + err.Error())
	}

	if this.Big_Record_1M_Len < 0 {
		return errors.New("Table_8Key_List.Big_Record_1M's refer Big_Record_1M_Len should >= 0")
	}
	if this.Big_Record_1M_Len > 10 {
		return errors.New("Table_8Key_List.Big_Record_1M's refer Big_Record_1M_Len should <= count 10")
	}
	if len(this.Big_Record_1M) < int(this.Big_Record_1M_Len) {
		return errors.New("Table_8Key_List.Big_Record_1M's length should > Big_Record_1M_Len")
	}
	if this.Big_Record_1M_Len > 0 {
		referBig_Record_1M := this.Big_Record_1M[:this.Big_Record_1M_Len]
		err = binary.Write(w, binary.BigEndian, referBig_Record_1M)
		if err != nil {
			return errors.New("Table_8Key_List.Big_Record_1M pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Small_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_List.Small_Record_1M_Len pack error\n" + err.Error())
	}

	if this.Small_Record_1M_Len < 0 {
		return errors.New("Table_8Key_List.Small_Record_1M's refer Small_Record_1M_Len should >= 0")
	}
	if this.Small_Record_1M_Len > 10 {
		return errors.New("Table_8Key_List.Small_Record_1M's refer Small_Record_1M_Len should <= count 10")
	}
	if len(this.Small_Record_1M) < int(this.Small_Record_1M_Len) {
		return errors.New("Table_8Key_List.Small_Record_1M's length should > Small_Record_1M_Len")
	}
	if this.Small_Record_1M_Len > 0 {
		referSmall_Record_1M := this.Small_Record_1M[:this.Small_Record_1M_Len]
		err = binary.Write(w, binary.BigEndian, referSmall_Record_1M)
		if err != nil {
			return errors.New("Table_8Key_List.Small_Record_1M pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Table_8Key_List) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_8Key_List data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_8Key_List) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_8Key_ListCurrentVersion {
		cutVer = Table_8Key_ListCurrentVersion
	}
	// check version
	if cutVer < Table_8Key_ListBaseVersion {
		errors.New("Table_8Key_List cut version must large than Table_8Key_ListBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.K1_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K1_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	var k2_6223e1fbf122fb8b656631f4b99cSize uint32
	err = binary.Read(r, binary.BigEndian, &k2_6223e1fbf122fb8b656631f4b99cSize)
	if err != nil {
		return errors.New("Table_8Key_List.K2_6223E1Fbf122Fb8B656631F4B99C string size unpack error\n" + err.Error())
	}

	k2_6223e1fbf122fb8b656631f4b99cBytes := make([]byte, k2_6223e1fbf122fb8b656631f4b99cSize)
	err = binary.Read(r, binary.BigEndian, k2_6223e1fbf122fb8b656631f4b99cBytes)
	if err != nil {
		return errors.New("Table_8Key_List.K2_6223E1Fbf122Fb8B656631F4B99C string content unpack error\n" + err.Error())
	}
	this.K2_6223E1Fbf122Fb8B656631F4B99C = string(k2_6223e1fbf122fb8b656631f4b99cBytes[:len(k2_6223e1fbf122fb8b656631f4b99cBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.K3_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K3_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K4_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K4_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K5_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K5_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K6_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K6_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.K7_6223E1Fbf122Fb8B656631F4B99C)
	if err != nil {
		return errors.New("Table_8Key_List.K7_6223E1Fbf122Fb8B656631F4B99C unpack error\n" + err.Error())
	}

	var value1Size uint32
	err = binary.Read(r, binary.BigEndian, &value1Size)
	if err != nil {
		return errors.New("Table_8Key_List.Value1 string size unpack error\n" + err.Error())
	}

	value1Bytes := make([]byte, value1Size)
	err = binary.Read(r, binary.BigEndian, value1Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Value1 string content unpack error\n" + err.Error())
	}
	this.Value1 = string(value1Bytes[:len(value1Bytes)-1])

	var value2Size uint32
	err = binary.Read(r, binary.BigEndian, &value2Size)
	if err != nil {
		return errors.New("Table_8Key_List.Value2 string size unpack error\n" + err.Error())
	}

	value2Bytes := make([]byte, value2Size)
	err = binary.Read(r, binary.BigEndian, value2Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Value2 string content unpack error\n" + err.Error())
	}
	this.Value2 = string(value2Bytes[:len(value2Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_8Key_List.Level unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("Table_8Key_List.Count unpack error\n" + err.Error())
	}

	var infoSize uint32
	err = binary.Read(r, binary.BigEndian, &infoSize)
	if err != nil {
		return errors.New("Table_8Key_List.Info string size unpack error\n" + err.Error())
	}

	infoBytes := make([]byte, infoSize)
	err = binary.Read(r, binary.BigEndian, infoBytes)
	if err != nil {
		return errors.New("Table_8Key_List.Info string content unpack error\n" + err.Error())
	}
	this.Info = string(infoBytes[:len(infoBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Float_Score)
	if err != nil {
		return errors.New("Table_8Key_List.Float_Score unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Double_Score)
	if err != nil {
		return errors.New("Table_8Key_List.Double_Score unpack error\n" + err.Error())
	}

	if this.Count < 0 {
		return errors.New("Table_8Key_List.Items's refer Count should >= 0")
	}
	if this.Count > 10 {
		return errors.New("Table_8Key_List.Items's refer Count should <= count 10")
	}

	if this.Items == nil {
		this.Items = make([]uint64, int(this.Count))
	}

	referItems := this.Items[:this.Count]
	err = binary.Read(r, binary.BigEndian, referItems)
	if err != nil {
		return errors.New("Table_8Key_List.Items pack error\n" + err.Error())
	}

	var big_record_1Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_1Size)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1 string size unpack error\n" + err.Error())
	}

	big_record_1Bytes := make([]byte, big_record_1Size)
	err = binary.Read(r, binary.BigEndian, big_record_1Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1 string content unpack error\n" + err.Error())
	}
	this.Big_Record_1 = string(big_record_1Bytes[:len(big_record_1Bytes)-1])

	var big_record_2Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_2Size)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_2 string size unpack error\n" + err.Error())
	}

	big_record_2Bytes := make([]byte, big_record_2Size)
	err = binary.Read(r, binary.BigEndian, big_record_2Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_2 string content unpack error\n" + err.Error())
	}
	this.Big_Record_2 = string(big_record_2Bytes[:len(big_record_2Bytes)-1])

	var big_record_3Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_3Size)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_3 string size unpack error\n" + err.Error())
	}

	big_record_3Bytes := make([]byte, big_record_3Size)
	err = binary.Read(r, binary.BigEndian, big_record_3Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_3 string content unpack error\n" + err.Error())
	}
	this.Big_Record_3 = string(big_record_3Bytes[:len(big_record_3Bytes)-1])

	var big_record_4Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_4Size)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_4 string size unpack error\n" + err.Error())
	}

	big_record_4Bytes := make([]byte, big_record_4Size)
	err = binary.Read(r, binary.BigEndian, big_record_4Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_4 string content unpack error\n" + err.Error())
	}
	this.Big_Record_4 = string(big_record_4Bytes[:len(big_record_4Bytes)-1])

	var big_record_5Size uint32
	err = binary.Read(r, binary.BigEndian, &big_record_5Size)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_5 string size unpack error\n" + err.Error())
	}

	big_record_5Bytes := make([]byte, big_record_5Size)
	err = binary.Read(r, binary.BigEndian, big_record_5Bytes)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_5 string content unpack error\n" + err.Error())
	}
	this.Big_Record_5 = string(big_record_5Bytes[:len(big_record_5Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.C_Int8)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint8)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint8 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int16)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint16)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint16 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int32)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint32)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint32 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Int64)
	if err != nil {
		return errors.New("Table_8Key_List.C_Int64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Uint64)
	if err != nil {
		return errors.New("Table_8Key_List.C_Uint64 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Float)
	if err != nil {
		return errors.New("Table_8Key_List.C_Float unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.C_Double)
	if err != nil {
		return errors.New("Table_8Key_List.C_Double unpack error\n" + err.Error())
	}

	var c_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &c_stringSize)
	if err != nil {
		return errors.New("Table_8Key_List.C_String string size unpack error\n" + err.Error())
	}

	c_stringBytes := make([]byte, c_stringSize)
	err = binary.Read(r, binary.BigEndian, c_stringBytes)
	if err != nil {
		return errors.New("Table_8Key_List.C_String string content unpack error\n" + err.Error())
	}
	this.C_String = string(c_stringBytes[:len(c_stringBytes)-1])

	if this.C_Uint32 < 0 {
		return errors.New("Table_8Key_List.C_Binary's refer C_Uint32 should >= 0")
	}
	if this.C_Uint32 > 100 {
		return errors.New("Table_8Key_List.C_Binary's refer C_Uint32 should <= count 100")
	}

	if this.C_Binary == nil {
		this.C_Binary = make([]int8, int(this.C_Uint32))
	}

	referC_Binary := this.C_Binary[:this.C_Uint32]
	err = binary.Read(r, binary.BigEndian, referC_Binary)
	if err != nil {
		return errors.New("Table_8Key_List.C_Binary pack error\n" + err.Error())
	}

	var max_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &max_stringSize)
	if err != nil {
		return errors.New("Table_8Key_List.Max_String string size unpack error\n" + err.Error())
	}

	max_stringBytes := make([]byte, max_stringSize)
	err = binary.Read(r, binary.BigEndian, max_stringBytes)
	if err != nil {
		return errors.New("Table_8Key_List.Max_String string content unpack error\n" + err.Error())
	}
	this.Max_String = string(max_stringBytes[:len(max_stringBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Binary_Count)
	if err != nil {
		return errors.New("Table_8Key_List.Binary_Count unpack error\n" + err.Error())
	}

	if this.Binary_Count < 0 {
		return errors.New("Table_8Key_List.Max_Binary's refer Binary_Count should >= 0")
	}
	if this.Binary_Count > 131070 {
		return errors.New("Table_8Key_List.Max_Binary's refer Binary_Count should <= count 131070")
	}

	if this.Max_Binary == nil {
		this.Max_Binary = make([]int8, int(this.Binary_Count))
	}

	referMax_Binary := this.Max_Binary[:this.Binary_Count]
	err = binary.Read(r, binary.BigEndian, referMax_Binary)
	if err != nil {
		return errors.New("Table_8Key_List.Max_Binary pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Selector)
	if err != nil {
		return errors.New("Table_8Key_List.Selector unpack error\n" + err.Error())
	}

	err = this.Single_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_8Key_List.Single_Struct unpack error\n" + err.Error())
	}

	err = this.Simple_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_8Key_List.Simple_Struct unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Single_Union_Selector)
	if err != nil {
		return errors.New("Table_8Key_List.Single_Union_Selector unpack error\n" + err.Error())
	}

	err = this.Single_Union.UnpackFrom(cutVer, r, int64(this.Single_Union_Selector))
	if err != nil {
		return errors.New("Table_8Key_List.Single_Union unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Array_Count)
	if err != nil {
		return errors.New("Table_8Key_List.Array_Count unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_List.Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_List.Array's refer Array_Count should <= count 3")
	}

	if this.Array == nil {
		this.Array = make([]*TableInfo, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Array[i] = NewTableInfo()
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_8Key_List.Array unpack error\n" + err.Error())
		}

	}

	err = this.C_Union.UnpackFrom(cutVer, r, int64(this.Selector))
	if err != nil {
		return errors.New("Table_8Key_List.C_Union unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_List.Union_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_List.Union_Array's refer Array_Count should <= count 3")
	}

	if this.Union_Array == nil {
		this.Union_Array = make([]*Union_Type, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Union_Array[i] = NewUnion_Type(int64(this.Selector))
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Union_Array[i].UnpackFrom(cutVer, r, int64(this.Selector))
		if err != nil {
			return errors.New("Table_8Key_List.Union_Array unpack error\n" + err.Error())
		}

	}

	err = this.C_Struct.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("Table_8Key_List.C_Struct unpack error\n" + err.Error())
	}

	if this.Array_Count < 0 {
		return errors.New("Table_8Key_List.Struct_Array's refer Array_Count should >= 0")
	}
	if this.Array_Count > 3 {
		return errors.New("Table_8Key_List.Struct_Array's refer Array_Count should <= count 3")
	}

	if this.Struct_Array == nil {
		this.Struct_Array = make([]*Struct_Type, int(this.Array_Count))
		for i := 0; i < int(this.Array_Count); i++ {
			this.Struct_Array[i] = NewStruct_Type()
		}
	}

	for i := 0; i < int(this.Array_Count); i++ {
		err = this.Struct_Array[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("Table_8Key_List.Struct_Array unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Bound_31_Byte_Test_012345678901)
	if err != nil {
		return errors.New("Table_8Key_List.Bound_31_Byte_Test_012345678901 unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Simple_Array_Count)
	if err != nil {
		return errors.New("Table_8Key_List.Simple_Array_Count unpack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_List.Int_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 5 {
		return errors.New("Table_8Key_List.Int_Array's refer Simple_Array_Count should <= count 5")
	}

	if this.Int_Array == nil {
		this.Int_Array = make([]int32, int(this.Simple_Array_Count))
	}

	referInt_Array := this.Int_Array[:this.Simple_Array_Count]
	err = binary.Read(r, binary.BigEndian, referInt_Array)
	if err != nil {
		return errors.New("Table_8Key_List.Int_Array pack error\n" + err.Error())
	}

	if this.Simple_Array_Count < 0 {
		return errors.New("Table_8Key_List.Double_Array's refer Simple_Array_Count should >= 0")
	}
	if this.Simple_Array_Count > 3 {
		return errors.New("Table_8Key_List.Double_Array's refer Simple_Array_Count should <= count 3")
	}

	if this.Double_Array == nil {
		this.Double_Array = make([]float64, int(this.Simple_Array_Count))
	}

	referDouble_Array := this.Double_Array[:this.Simple_Array_Count]
	err = binary.Read(r, binary.BigEndian, referDouble_Array)
	if err != nil {
		return errors.New("Table_8Key_List.Double_Array pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Big_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1M_Len unpack error\n" + err.Error())
	}

	if this.Big_Record_1M_Len < 0 {
		return errors.New("Table_8Key_List.Big_Record_1M's refer Big_Record_1M_Len should >= 0")
	}
	if this.Big_Record_1M_Len > 10 {
		return errors.New("Table_8Key_List.Big_Record_1M's refer Big_Record_1M_Len should <= count 10")
	}

	if this.Big_Record_1M == nil {
		this.Big_Record_1M = make([]byte, int(this.Big_Record_1M_Len))
	}

	referBig_Record_1M := this.Big_Record_1M[:this.Big_Record_1M_Len]
	err = binary.Read(r, binary.BigEndian, referBig_Record_1M)
	if err != nil {
		return errors.New("Table_8Key_List.Big_Record_1M pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Small_Record_1M_Len)
	if err != nil {
		return errors.New("Table_8Key_List.Small_Record_1M_Len unpack error\n" + err.Error())
	}

	if this.Small_Record_1M_Len < 0 {
		return errors.New("Table_8Key_List.Small_Record_1M's refer Small_Record_1M_Len should >= 0")
	}
	if this.Small_Record_1M_Len > 10 {
		return errors.New("Table_8Key_List.Small_Record_1M's refer Small_Record_1M_Len should <= count 10")
	}

	if this.Small_Record_1M == nil {
		this.Small_Record_1M = make([]byte, int(this.Small_Record_1M_Len))
	}

	referSmall_Record_1M := this.Small_Record_1M[:this.Small_Record_1M_Len]
	err = binary.Read(r, binary.BigEndian, referSmall_Record_1M)
	if err != nil {
		return errors.New("Table_8Key_List.Small_Record_1M pack error\n" + err.Error())
	}

	return err
}

const (
	Table_SplitBaseVersion    uint32 = 1
	Table_SplitCurrentVersion uint32 = 1
)

var Table_SplitDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Itemid",
	PrimaryKey:    "Gameid,Itemid,Name",
	Index2Column: map[string]string{
		"Index1": "Gameid,Itemid",
	},
}

// Table_Split
type Table_Split struct {
	Gameid uint32 `tdr_field:"gameid"`

	Itemid uint32 `tdr_field:"itemid"`

	Name string `tdr_field:"name"`

	Typeid byte `tdr_field:"typeid"`

	Data byte `tdr_field:"Data"`

	Uname string `tdr_field:"uname"`

	Uname2 string `tdr_field:"uname2"`

	Uname3 string `tdr_field:"uname3"`

	Uname4 string `tdr_field:"uname4"`

	Uname5 string `tdr_field:"uname5"`

	Uname6 string `tdr_field:"uname6"`

	Uname7 string `tdr_field:"uname7"`

	Uname8 string `tdr_field:"uname8"`

	Uname9 string `tdr_field:"uname9"`

	Uname10 string `tdr_field:"uname10"`
}

func NewTable_Split() *Table_Split {
	obj := new(Table_Split)
	obj.Init()
	return obj
}

func (this *Table_Split) GetBaseVersion() uint32 {
	return Table_SplitBaseVersion
}

func (this *Table_Split) GetCurrentVersion() uint32 {
	return Table_SplitCurrentVersion
}

func (this *Table_Split) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_SplitDBFeilds
}

func (this *Table_Split) Init() {

	this.Data = 9

	this.Uname = "ab"

	this.Uname2 = "ab"

	this.Uname3 = "ab"

	this.Uname4 = "ab"

	this.Uname5 = "ab"

	this.Uname6 = "ab"

	this.Uname7 = "ab"

	this.Uname8 = "ab"

	this.Uname9 = "ab"

	this.Uname10 = "ab"

}

func (this *Table_Split) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_Split Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_Split) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_SplitCurrentVersion {
		cutVer = Table_SplitCurrentVersion
	}
	// check cut version
	if cutVer < Table_SplitBaseVersion {
		return errors.New("Table_Split cut version must large than Table_SplitBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Gameid)
	if err != nil {
		return errors.New("Table_Split.Gameid pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Itemid)
	if err != nil {
		return errors.New("Table_Split.Itemid pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("Table_Split.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("Table_Split.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Typeid)
	if err != nil {
		return errors.New("Table_Split.Typeid pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Data)
	if err != nil {
		return errors.New("Table_Split.Data pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname))+1)
	if err != nil {
		return errors.New("Table_Split.Uname string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname), 0))
	if err != nil {
		return errors.New("Table_Split.Uname string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname2))+1)
	if err != nil {
		return errors.New("Table_Split.Uname2 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname2), 0))
	if err != nil {
		return errors.New("Table_Split.Uname2 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname3))+1)
	if err != nil {
		return errors.New("Table_Split.Uname3 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname3), 0))
	if err != nil {
		return errors.New("Table_Split.Uname3 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname4))+1)
	if err != nil {
		return errors.New("Table_Split.Uname4 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname4), 0))
	if err != nil {
		return errors.New("Table_Split.Uname4 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname5))+1)
	if err != nil {
		return errors.New("Table_Split.Uname5 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname5), 0))
	if err != nil {
		return errors.New("Table_Split.Uname5 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname6))+1)
	if err != nil {
		return errors.New("Table_Split.Uname6 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname6), 0))
	if err != nil {
		return errors.New("Table_Split.Uname6 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname7))+1)
	if err != nil {
		return errors.New("Table_Split.Uname7 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname7), 0))
	if err != nil {
		return errors.New("Table_Split.Uname7 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname8))+1)
	if err != nil {
		return errors.New("Table_Split.Uname8 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname8), 0))
	if err != nil {
		return errors.New("Table_Split.Uname8 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname9))+1)
	if err != nil {
		return errors.New("Table_Split.Uname9 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname9), 0))
	if err != nil {
		return errors.New("Table_Split.Uname9 string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Uname10))+1)
	if err != nil {
		return errors.New("Table_Split.Uname10 string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Uname10), 0))
	if err != nil {
		return errors.New("Table_Split.Uname10 string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_Split) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_Split data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_Split) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_SplitCurrentVersion {
		cutVer = Table_SplitCurrentVersion
	}
	// check version
	if cutVer < Table_SplitBaseVersion {
		errors.New("Table_Split cut version must large than Table_SplitBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Gameid)
	if err != nil {
		return errors.New("Table_Split.Gameid unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Itemid)
	if err != nil {
		return errors.New("Table_Split.Itemid unpack error\n" + err.Error())
	}

	var nameSize uint32
	err = binary.Read(r, binary.BigEndian, &nameSize)
	if err != nil {
		return errors.New("Table_Split.Name string size unpack error\n" + err.Error())
	}

	nameBytes := make([]byte, nameSize)
	err = binary.Read(r, binary.BigEndian, nameBytes)
	if err != nil {
		return errors.New("Table_Split.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(nameBytes[:len(nameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Typeid)
	if err != nil {
		return errors.New("Table_Split.Typeid unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Data)
	if err != nil {
		return errors.New("Table_Split.Data unpack error\n" + err.Error())
	}

	var unameSize uint32
	err = binary.Read(r, binary.BigEndian, &unameSize)
	if err != nil {
		return errors.New("Table_Split.Uname string size unpack error\n" + err.Error())
	}

	unameBytes := make([]byte, unameSize)
	err = binary.Read(r, binary.BigEndian, unameBytes)
	if err != nil {
		return errors.New("Table_Split.Uname string content unpack error\n" + err.Error())
	}
	this.Uname = string(unameBytes[:len(unameBytes)-1])

	var uname2Size uint32
	err = binary.Read(r, binary.BigEndian, &uname2Size)
	if err != nil {
		return errors.New("Table_Split.Uname2 string size unpack error\n" + err.Error())
	}

	uname2Bytes := make([]byte, uname2Size)
	err = binary.Read(r, binary.BigEndian, uname2Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname2 string content unpack error\n" + err.Error())
	}
	this.Uname2 = string(uname2Bytes[:len(uname2Bytes)-1])

	var uname3Size uint32
	err = binary.Read(r, binary.BigEndian, &uname3Size)
	if err != nil {
		return errors.New("Table_Split.Uname3 string size unpack error\n" + err.Error())
	}

	uname3Bytes := make([]byte, uname3Size)
	err = binary.Read(r, binary.BigEndian, uname3Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname3 string content unpack error\n" + err.Error())
	}
	this.Uname3 = string(uname3Bytes[:len(uname3Bytes)-1])

	var uname4Size uint32
	err = binary.Read(r, binary.BigEndian, &uname4Size)
	if err != nil {
		return errors.New("Table_Split.Uname4 string size unpack error\n" + err.Error())
	}

	uname4Bytes := make([]byte, uname4Size)
	err = binary.Read(r, binary.BigEndian, uname4Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname4 string content unpack error\n" + err.Error())
	}
	this.Uname4 = string(uname4Bytes[:len(uname4Bytes)-1])

	var uname5Size uint32
	err = binary.Read(r, binary.BigEndian, &uname5Size)
	if err != nil {
		return errors.New("Table_Split.Uname5 string size unpack error\n" + err.Error())
	}

	uname5Bytes := make([]byte, uname5Size)
	err = binary.Read(r, binary.BigEndian, uname5Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname5 string content unpack error\n" + err.Error())
	}
	this.Uname5 = string(uname5Bytes[:len(uname5Bytes)-1])

	var uname6Size uint32
	err = binary.Read(r, binary.BigEndian, &uname6Size)
	if err != nil {
		return errors.New("Table_Split.Uname6 string size unpack error\n" + err.Error())
	}

	uname6Bytes := make([]byte, uname6Size)
	err = binary.Read(r, binary.BigEndian, uname6Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname6 string content unpack error\n" + err.Error())
	}
	this.Uname6 = string(uname6Bytes[:len(uname6Bytes)-1])

	var uname7Size uint32
	err = binary.Read(r, binary.BigEndian, &uname7Size)
	if err != nil {
		return errors.New("Table_Split.Uname7 string size unpack error\n" + err.Error())
	}

	uname7Bytes := make([]byte, uname7Size)
	err = binary.Read(r, binary.BigEndian, uname7Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname7 string content unpack error\n" + err.Error())
	}
	this.Uname7 = string(uname7Bytes[:len(uname7Bytes)-1])

	var uname8Size uint32
	err = binary.Read(r, binary.BigEndian, &uname8Size)
	if err != nil {
		return errors.New("Table_Split.Uname8 string size unpack error\n" + err.Error())
	}

	uname8Bytes := make([]byte, uname8Size)
	err = binary.Read(r, binary.BigEndian, uname8Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname8 string content unpack error\n" + err.Error())
	}
	this.Uname8 = string(uname8Bytes[:len(uname8Bytes)-1])

	var uname9Size uint32
	err = binary.Read(r, binary.BigEndian, &uname9Size)
	if err != nil {
		return errors.New("Table_Split.Uname9 string size unpack error\n" + err.Error())
	}

	uname9Bytes := make([]byte, uname9Size)
	err = binary.Read(r, binary.BigEndian, uname9Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname9 string content unpack error\n" + err.Error())
	}
	this.Uname9 = string(uname9Bytes[:len(uname9Bytes)-1])

	var uname10Size uint32
	err = binary.Read(r, binary.BigEndian, &uname10Size)
	if err != nil {
		return errors.New("Table_Split.Uname10 string size unpack error\n" + err.Error())
	}

	uname10Bytes := make([]byte, uname10Size)
	err = binary.Read(r, binary.BigEndian, uname10Bytes)
	if err != nil {
		return errors.New("Table_Split.Uname10 string content unpack error\n" + err.Error())
	}
	this.Uname10 = string(uname10Bytes[:len(uname10Bytes)-1])

	return err
}

const (
	Table_10M_String_MutiBaseVersion    uint32 = 5
	Table_10M_String_MutiCurrentVersion uint32 = 5
)

var Table_10M_String_MutiDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin",
	Index2Column: map[string]string{
		"Index1": "Uin",
	},
}

// Table_10M_String_Muti
type Table_10M_String_Muti struct {
	Uin uint32 `tdr_field:"uin"`

	Level int32 `tdr_field:"level"`

	Little_String string `tdr_field:"little_string"`

	Value string `tdr_field:"value"`
}

func NewTable_10M_String_Muti() *Table_10M_String_Muti {
	obj := new(Table_10M_String_Muti)
	obj.Init()
	return obj
}

func (this *Table_10M_String_Muti) GetBaseVersion() uint32 {
	return Table_10M_String_MutiBaseVersion
}

func (this *Table_10M_String_Muti) GetCurrentVersion() uint32 {
	return Table_10M_String_MutiCurrentVersion
}

func (this *Table_10M_String_Muti) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_10M_String_MutiDBFeilds
}

func (this *Table_10M_String_Muti) Init() {

	this.Level = 1

	this.Little_String = "one field with string,value 1kb"

	this.Value = "one field with string ,whitch size is 10m"

}

func (this *Table_10M_String_Muti) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_10M_String_Muti Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_10M_String_Muti) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_10M_String_MutiCurrentVersion {
		cutVer = Table_10M_String_MutiCurrentVersion
	}
	// check cut version
	if cutVer < Table_10M_String_MutiBaseVersion {
		return errors.New("Table_10M_String_Muti cut version must large than Table_10M_String_MutiBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Little_String))+1)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Little_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Little_String), 0))
	if err != nil {
		return errors.New("Table_10M_String_Muti.Little_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value))+1)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Value string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value), 0))
	if err != nil {
		return errors.New("Table_10M_String_Muti.Value string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_10M_String_Muti) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_10M_String_Muti data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_10M_String_Muti) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_10M_String_MutiCurrentVersion {
		cutVer = Table_10M_String_MutiCurrentVersion
	}
	// check version
	if cutVer < Table_10M_String_MutiBaseVersion {
		errors.New("Table_10M_String_Muti cut version must large than Table_10M_String_MutiBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Uin unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Level unpack error\n" + err.Error())
	}

	var little_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &little_stringSize)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Little_String string size unpack error\n" + err.Error())
	}

	little_stringBytes := make([]byte, little_stringSize)
	err = binary.Read(r, binary.BigEndian, little_stringBytes)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Little_String string content unpack error\n" + err.Error())
	}
	this.Little_String = string(little_stringBytes[:len(little_stringBytes)-1])

	var valueSize uint32
	err = binary.Read(r, binary.BigEndian, &valueSize)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Value string size unpack error\n" + err.Error())
	}

	valueBytes := make([]byte, valueSize)
	err = binary.Read(r, binary.BigEndian, valueBytes)
	if err != nil {
		return errors.New("Table_10M_String_Muti.Value string content unpack error\n" + err.Error())
	}
	this.Value = string(valueBytes[:len(valueBytes)-1])

	return err
}

const (
	Table_10M_String_List_MutiBaseVersion    uint32 = 5
	Table_10M_String_List_MutiCurrentVersion uint32 = 5
)

var Table_10M_String_List_MutiDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Uin",
	PrimaryKey:    "Uin",
}

// Table_10M_String_List_Muti
type Table_10M_String_List_Muti struct {
	Uin uint32 `tdr_field:"uin"`

	Level int32 `tdr_field:"level"`

	Little_String string `tdr_field:"little_string"`

	Value string `tdr_field:"value"`
}

func NewTable_10M_String_List_Muti() *Table_10M_String_List_Muti {
	obj := new(Table_10M_String_List_Muti)
	obj.Init()
	return obj
}

func (this *Table_10M_String_List_Muti) GetBaseVersion() uint32 {
	return Table_10M_String_List_MutiBaseVersion
}

func (this *Table_10M_String_List_Muti) GetCurrentVersion() uint32 {
	return Table_10M_String_List_MutiCurrentVersion
}

func (this *Table_10M_String_List_Muti) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Table_10M_String_List_MutiDBFeilds
}

func (this *Table_10M_String_List_Muti) Init() {

	this.Level = 1

	this.Little_String = "one field with string,value 1kb"

	this.Value = "one field with string ,whitch size is 10m"

}

func (this *Table_10M_String_List_Muti) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Table_10M_String_List_Muti Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Table_10M_String_List_Muti) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Table_10M_String_List_MutiCurrentVersion {
		cutVer = Table_10M_String_List_MutiCurrentVersion
	}
	// check cut version
	if cutVer < Table_10M_String_List_MutiBaseVersion {
		return errors.New("Table_10M_String_List_Muti cut version must large than Table_10M_String_List_MutiBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Uin)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Uin pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Level)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Level pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Little_String))+1)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Little_String string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Little_String), 0))
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Little_String string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Value))+1)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Value string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Value), 0))
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Value string content pack error\n" + err.Error())
	}

	return nil
}

func (this *Table_10M_String_List_Muti) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Table_10M_String_List_Muti data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Table_10M_String_List_Muti) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Table_10M_String_List_MutiCurrentVersion {
		cutVer = Table_10M_String_List_MutiCurrentVersion
	}
	// check version
	if cutVer < Table_10M_String_List_MutiBaseVersion {
		errors.New("Table_10M_String_List_Muti cut version must large than Table_10M_String_List_MutiBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Uin)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Uin unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Level)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Level unpack error\n" + err.Error())
	}

	var little_stringSize uint32
	err = binary.Read(r, binary.BigEndian, &little_stringSize)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Little_String string size unpack error\n" + err.Error())
	}

	little_stringBytes := make([]byte, little_stringSize)
	err = binary.Read(r, binary.BigEndian, little_stringBytes)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Little_String string content unpack error\n" + err.Error())
	}
	this.Little_String = string(little_stringBytes[:len(little_stringBytes)-1])

	var valueSize uint32
	err = binary.Read(r, binary.BigEndian, &valueSize)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Value string size unpack error\n" + err.Error())
	}

	valueBytes := make([]byte, valueSize)
	err = binary.Read(r, binary.BigEndian, valueBytes)
	if err != nil {
		return errors.New("Table_10M_String_List_Muti.Value string content unpack error\n" + err.Error())
	}
	this.Value = string(valueBytes[:len(valueBytes)-1])

	return err
}
