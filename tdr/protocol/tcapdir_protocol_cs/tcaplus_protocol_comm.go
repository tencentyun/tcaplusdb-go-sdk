// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2020-11-12 20:09:54
package tcapdir_protocol_cs

import (
	"encoding/binary"
	"errors"

	"git.code.oa.com/tsf4g/tdrcom"
)

// Server ID的最大长度
const MAX_SERVER_ID_LEN int64 = 32
const TCAPLUS_MAX_FIELD_NAME int64 = 32
const TCAPLUS_PROTOBUF_MAX_TAG_PATH int64 = 1024
const TCAPLUS_PROTOBUF_MAX_TAG_DEPTH int64 = 32
const TCAPLUS_MAX_LIST_ELEMENTS_NUM int64 = 10240
const TCAPLUS_MAX_BUSINESS_ID_LEN int64 = 64

// 数据淘汰规则最大个数
const MAX_DATA_EXPIRE_RULE_CNT int64 = 2

// 速度控制分段个数
const MAX_SPEED_CONTROL_RULE_CNT int64 = 4

// Tcapsvr 监控告警屏蔽单个条目最大长度,注意包括分号
const MAX_SINGLE_BLOCK_ALARM_ITEM_SIZE int64 = 1024
const TCAPLUS_MAX_DEFAULT_VALUE_LEN int64 = 64

// 每个服务(目前是app, zone)提供的最多的接入进程的个数
const TCAPLUS_MAX_ACCESS_CNT int64 = 1024

// 每个服务(目前是app, zone)tcapdir提供给client的最多的接入进程的个数
const TCAPLUS_MAX_ACCESS_CNT_DIR_TO_CLIENT int64 = 200
const DEFAULT_VALUE_OF_MAXBLOCKNUMOFTASKQUEUE int64 = 300
const TCAPLUS_MAX_LIST_SORT_NUM int64 = 4

// 区分sort_list和list的特殊版本号
const TCAPLUS_SORT_LIST_SPECIAL_VERSION int64 = 1000000

// 较长的错误信息长度
const LONG_ERROR_MSG_LEN int64 = 10240
const MAX_DBNAME_LEN int64 = 128
const MAX_DBFIELD_NUM int64 = 256
const MAX_DEFAULT_LEN int64 = 64

// 每个服务(app)提供的最多的tcapdb进程的个数
const TCAPLUS_MAX_TCAPDB_CNT int64 = 1024

// 每个服务(目前是app, zone)提供的最多的接入RestProxies个数
const TCAPLUS_MAX_REST_PROXY_CNT int64 = 1024

// 变更tcaplus访问白名单的最大IP数量
const MAX_MODIFY_WRITELIST_IP_COUNT int64 = 6000

// 要变更tcaplus访问白名单的的最大zone数量，注意这个数量是zone操作类型的数量
const MAX_MODIFY_WRITELIST_ZONE_COUNT int64 = 200

// 索引名的最大长度
const TCAPLUS_MAX_INDEX_NAME_LEN int64 = 1024
const META_TCAPLUS_TABLE_TYPE_GENERIC int64 = 0
const META_TCAPLUS_TABLE_TYPE_LIST int64 = 1

// 操作成功
const TCAPLUS_OP_RESULT_OK int64 = 0x0000
const DATA_EXPIRE_RULE_LAST_ACCESS_TIME int64 = 1

// 普通慢启动
const NORMAL_START int64 = 0

// 快启动
const RESUME_START int64 = 1

// 推送最新配置后慢启动
const PUSHCFG_START int64 = 2

// 普通慢停止
const NORMAL_STOP int64 = 0

// 快停止
const RESUME_STOP int64 = 1

// 非自增字段
const NON_INCREASE_FLAG int64 = 0

// 自增字段
const INCREASE_FLAG int64 = 1

// 增加白名单中的IP操作
const ADD_IPS int64 = 0

// 删除白名单中的IP操作
const DELETE_IPS int64 = 1

// 关闭白名单
const OFF_WHITELIST int64 = 0

// 打开白名单
const ON_WHITELIST int64 = 1

// 关闭并且删除白名单
const OFF_AND_DELETE_WHITELIST int64 = 2

// 白名单校验通过
const AUTH_SUCCEED int64 = 0

// 白名单校验未通过
const AUTH_FAILED_WHITELIST int64 = 1
const (
	TCaplusKeyFieldBaseVersion    uint32 = 1
	TCaplusKeyFieldCurrentVersion uint32 = 1
)

// TCaplusKeyField
type TCaplusKeyField struct {
	FieldName string `tdr_field:"FieldName"`

	FieldLen uint32 `tdr_field:"FieldLen"`

	FieldBuff []byte `tdr_field:"FieldBuff" tdr_count:"1024" tdr_refer:"FieldLen"`
}

func NewTCaplusKeyField() *TCaplusKeyField {
	obj := new(TCaplusKeyField)
	obj.Init()
	return obj
}

func (this *TCaplusKeyField) GetBaseVersion() uint32 {
	return TCaplusKeyFieldBaseVersion
}

func (this *TCaplusKeyField) GetCurrentVersion() uint32 {
	return TCaplusKeyFieldCurrentVersion
}

func (this *TCaplusKeyField) Init() {

}

func (this *TCaplusKeyField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusKeyField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusKeyField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusKeyFieldCurrentVersion {
		cutVer = TCaplusKeyFieldCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusKeyFieldBaseVersion {
		return errors.New("TCaplusKeyField cut version must large than TCaplusKeyFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName))+1)
	if err != nil {
		return errors.New("TCaplusKeyField.FieldName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName), 0))
	if err != nil {
		return errors.New("TCaplusKeyField.FieldName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldLen)
	if err != nil {
		return errors.New("TCaplusKeyField.FieldLen pack error\n" + err.Error())
	}

	if this.FieldLen < 0 {
		return errors.New("TCaplusKeyField.FieldBuff's refer FieldLen should >= 0")
	}
	if this.FieldLen > 1024 {
		return errors.New("TCaplusKeyField.FieldBuff's refer FieldLen should <= count 1024")
	}
	if len(this.FieldBuff) < int(this.FieldLen) {
		return errors.New("TCaplusKeyField.FieldBuff's length should > FieldLen")
	}
	if this.FieldLen > 0 {
		referFieldBuff := this.FieldBuff[:this.FieldLen]
		err = binary.Write(w, binary.BigEndian, referFieldBuff)
		if err != nil {
			return errors.New("TCaplusKeyField.FieldBuff pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusKeyField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusKeyField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusKeyField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusKeyFieldCurrentVersion {
		cutVer = TCaplusKeyFieldCurrentVersion
	}
	// check version
	if cutVer < TCaplusKeyFieldBaseVersion {
		errors.New("TCaplusKeyField cut version must large than TCaplusKeyFieldBaseVersion\n")
	}

	var FieldNameSize uint32
	err = binary.Read(r, binary.BigEndian, &FieldNameSize)
	if err != nil {
		return errors.New("TCaplusKeyField.FieldName string size unpack error\n" + err.Error())
	}

	FieldNameBytes := make([]byte, FieldNameSize)
	err = binary.Read(r, binary.BigEndian, FieldNameBytes)
	if err != nil {
		return errors.New("TCaplusKeyField.FieldName string content unpack error\n" + err.Error())
	}
	this.FieldName = string(FieldNameBytes[:len(FieldNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.FieldLen)
	if err != nil {
		return errors.New("TCaplusKeyField.FieldLen unpack error\n" + err.Error())
	}

	if this.FieldLen < 0 {
		return errors.New("TCaplusKeyField.FieldBuff's refer FieldLen should >= 0")
	}
	if this.FieldLen > 1024 {
		return errors.New("TCaplusKeyField.FieldBuff's refer FieldLen should <= count 1024")
	}

	if this.FieldBuff == nil {
		this.FieldBuff = make([]byte, int(this.FieldLen))
	}

	referFieldBuff := this.FieldBuff[:this.FieldLen]
	err = binary.Read(r, binary.BigEndian, referFieldBuff)
	if err != nil {
		return errors.New("TCaplusKeyField.FieldBuff pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusValueField_BaseVersion    uint32 = 1
	TCaplusValueField_CurrentVersion uint32 = 36
	TCaplusValueField_Flag_Version   uint32 = 36
)

// TCaplusValueField_
type TCaplusValueField_ struct {
	FieldName_ string `tdr_field:"FieldName_"`

	FieldLen_ uint32 `tdr_field:"FieldLen_"`

	FieldBuff_ []byte `tdr_field:"FieldBuff_" tdr_count:"262144" tdr_refer:"FieldLen_"`

	Flag_ byte `tdr_field:"Flag_"`
}

func NewTCaplusValueField_() *TCaplusValueField_ {
	obj := new(TCaplusValueField_)
	obj.Init()
	return obj
}

func (this *TCaplusValueField_) GetBaseVersion() uint32 {
	return TCaplusValueField_BaseVersion
}

func (this *TCaplusValueField_) GetCurrentVersion() uint32 {
	return TCaplusValueField_CurrentVersion
}

func (this *TCaplusValueField_) Init() {

	this.Flag_ = 0

}

func (this *TCaplusValueField_) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusValueField_ Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusValueField_) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusValueField_CurrentVersion {
		cutVer = TCaplusValueField_CurrentVersion
	}
	// check cut version
	if cutVer < TCaplusValueField_BaseVersion {
		return errors.New("TCaplusValueField_ cut version must large than TCaplusValueField_BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName_))+1)
	if err != nil {
		return errors.New("TCaplusValueField_.FieldName_ string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName_), 0))
	if err != nil {
		return errors.New("TCaplusValueField_.FieldName_ string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldLen_)
	if err != nil {
		return errors.New("TCaplusValueField_.FieldLen_ pack error\n" + err.Error())
	}

	if this.FieldLen_ < 0 {
		return errors.New("TCaplusValueField_.FieldBuff_'s refer FieldLen_ should >= 0")
	}
	if this.FieldLen_ > 262144 {
		return errors.New("TCaplusValueField_.FieldBuff_'s refer FieldLen_ should <= count 262144")
	}
	if len(this.FieldBuff_) < int(this.FieldLen_) {
		return errors.New("TCaplusValueField_.FieldBuff_'s length should > FieldLen_")
	}
	if this.FieldLen_ > 0 {
		referFieldBuff_ := this.FieldBuff_[:this.FieldLen_]
		err = binary.Write(w, binary.BigEndian, referFieldBuff_)
		if err != nil {
			return errors.New("TCaplusValueField_.FieldBuff_ pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusValueField_Flag_Version {

		err = binary.Write(w, binary.BigEndian, this.Flag_)
		if err != nil {
			return errors.New("TCaplusValueField_.Flag_ pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusValueField_) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusValueField_ data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusValueField_) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusValueField_CurrentVersion {
		cutVer = TCaplusValueField_CurrentVersion
	}
	// check version
	if cutVer < TCaplusValueField_BaseVersion {
		errors.New("TCaplusValueField_ cut version must large than TCaplusValueField_BaseVersion\n")
	}

	var FieldName_Size uint32
	err = binary.Read(r, binary.BigEndian, &FieldName_Size)
	if err != nil {
		return errors.New("TCaplusValueField_.FieldName_ string size unpack error\n" + err.Error())
	}

	FieldName_Bytes := make([]byte, FieldName_Size)
	err = binary.Read(r, binary.BigEndian, FieldName_Bytes)
	if err != nil {
		return errors.New("TCaplusValueField_.FieldName_ string content unpack error\n" + err.Error())
	}
	this.FieldName_ = string(FieldName_Bytes[:len(FieldName_Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.FieldLen_)
	if err != nil {
		return errors.New("TCaplusValueField_.FieldLen_ unpack error\n" + err.Error())
	}

	if this.FieldLen_ < 0 {
		return errors.New("TCaplusValueField_.FieldBuff_'s refer FieldLen_ should >= 0")
	}
	if this.FieldLen_ > 262144 {
		return errors.New("TCaplusValueField_.FieldBuff_'s refer FieldLen_ should <= count 262144")
	}

	if this.FieldBuff_ == nil {
		this.FieldBuff_ = make([]byte, int(this.FieldLen_))
	}

	referFieldBuff_ := this.FieldBuff_[:this.FieldLen_]
	err = binary.Read(r, binary.BigEndian, referFieldBuff_)
	if err != nil {
		return errors.New("TCaplusValueField_.FieldBuff_ pack error\n" + err.Error())
	}

	if cutVer >= TCaplusValueField_Flag_Version {

		err = binary.Read(r, binary.BigEndian, &this.Flag_)
		if err != nil {
			return errors.New("TCaplusValueField_.Flag_ unpack error\n" + err.Error())
		}

	} else {
		this.Flag_ = 0

	}
	return err
}

const (
	KeyFieldBaseVersion    uint32 = 1
	KeyFieldCurrentVersion uint32 = 1
)

// KeyField
type KeyField struct {
	Name string `tdr_field:"Name"`

	Type string `tdr_field:"Type"`

	MaxLen int32 `tdr_field:"MaxLen"`
}

func NewKeyField() *KeyField {
	obj := new(KeyField)
	obj.Init()
	return obj
}

func (this *KeyField) GetBaseVersion() uint32 {
	return KeyFieldBaseVersion
}

func (this *KeyField) GetCurrentVersion() uint32 {
	return KeyFieldCurrentVersion
}

func (this *KeyField) Init() {

	this.MaxLen = 0

}

func (this *KeyField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("KeyField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *KeyField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > KeyFieldCurrentVersion {
		cutVer = KeyFieldCurrentVersion
	}
	// check cut version
	if cutVer < KeyFieldBaseVersion {
		return errors.New("KeyField cut version must large than KeyFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("KeyField.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("KeyField.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type))+1)
	if err != nil {
		return errors.New("KeyField.Type string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type), 0))
	if err != nil {
		return errors.New("KeyField.Type string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MaxLen)
	if err != nil {
		return errors.New("KeyField.MaxLen pack error\n" + err.Error())
	}

	return nil
}

func (this *KeyField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("KeyField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *KeyField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > KeyFieldCurrentVersion {
		cutVer = KeyFieldCurrentVersion
	}
	// check version
	if cutVer < KeyFieldBaseVersion {
		errors.New("KeyField cut version must large than KeyFieldBaseVersion\n")
	}

	var NameSize uint32
	err = binary.Read(r, binary.BigEndian, &NameSize)
	if err != nil {
		return errors.New("KeyField.Name string size unpack error\n" + err.Error())
	}

	NameBytes := make([]byte, NameSize)
	err = binary.Read(r, binary.BigEndian, NameBytes)
	if err != nil {
		return errors.New("KeyField.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(NameBytes[:len(NameBytes)-1])

	var TypeSize uint32
	err = binary.Read(r, binary.BigEndian, &TypeSize)
	if err != nil {
		return errors.New("KeyField.Type string size unpack error\n" + err.Error())
	}

	TypeBytes := make([]byte, TypeSize)
	err = binary.Read(r, binary.BigEndian, TypeBytes)
	if err != nil {
		return errors.New("KeyField.Type string content unpack error\n" + err.Error())
	}
	this.Type = string(TypeBytes[:len(TypeBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.MaxLen)
	if err != nil {
		return errors.New("KeyField.MaxLen unpack error\n" + err.Error())
	}

	return err
}

const (
	ValueFieldBaseVersion    uint32 = 1
	ValueFieldCurrentVersion uint32 = 1
)

// ValueField
type ValueField struct {
	Name string `tdr_field:"Name"`

	Type string `tdr_field:"Type"`

	MaxLen int32 `tdr_field:"MaxLen"`

	Default string `tdr_field:"Default"`
}

func NewValueField() *ValueField {
	obj := new(ValueField)
	obj.Init()
	return obj
}

func (this *ValueField) GetBaseVersion() uint32 {
	return ValueFieldBaseVersion
}

func (this *ValueField) GetCurrentVersion() uint32 {
	return ValueFieldCurrentVersion
}

func (this *ValueField) Init() {

	this.MaxLen = 0

}

func (this *ValueField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ValueField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ValueField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ValueFieldCurrentVersion {
		cutVer = ValueFieldCurrentVersion
	}
	// check cut version
	if cutVer < ValueFieldBaseVersion {
		return errors.New("ValueField cut version must large than ValueFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Name))+1)
	if err != nil {
		return errors.New("ValueField.Name string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Name), 0))
	if err != nil {
		return errors.New("ValueField.Name string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Type))+1)
	if err != nil {
		return errors.New("ValueField.Type string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Type), 0))
	if err != nil {
		return errors.New("ValueField.Type string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MaxLen)
	if err != nil {
		return errors.New("ValueField.MaxLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Default))+1)
	if err != nil {
		return errors.New("ValueField.Default string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Default), 0))
	if err != nil {
		return errors.New("ValueField.Default string content pack error\n" + err.Error())
	}

	return nil
}

func (this *ValueField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ValueField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ValueField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ValueFieldCurrentVersion {
		cutVer = ValueFieldCurrentVersion
	}
	// check version
	if cutVer < ValueFieldBaseVersion {
		errors.New("ValueField cut version must large than ValueFieldBaseVersion\n")
	}

	var NameSize uint32
	err = binary.Read(r, binary.BigEndian, &NameSize)
	if err != nil {
		return errors.New("ValueField.Name string size unpack error\n" + err.Error())
	}

	NameBytes := make([]byte, NameSize)
	err = binary.Read(r, binary.BigEndian, NameBytes)
	if err != nil {
		return errors.New("ValueField.Name string content unpack error\n" + err.Error())
	}
	this.Name = string(NameBytes[:len(NameBytes)-1])

	var TypeSize uint32
	err = binary.Read(r, binary.BigEndian, &TypeSize)
	if err != nil {
		return errors.New("ValueField.Type string size unpack error\n" + err.Error())
	}

	TypeBytes := make([]byte, TypeSize)
	err = binary.Read(r, binary.BigEndian, TypeBytes)
	if err != nil {
		return errors.New("ValueField.Type string content unpack error\n" + err.Error())
	}
	this.Type = string(TypeBytes[:len(TypeBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.MaxLen)
	if err != nil {
		return errors.New("ValueField.MaxLen unpack error\n" + err.Error())
	}

	var DefaultSize uint32
	err = binary.Read(r, binary.BigEndian, &DefaultSize)
	if err != nil {
		return errors.New("ValueField.Default string size unpack error\n" + err.Error())
	}

	DefaultBytes := make([]byte, DefaultSize)
	err = binary.Read(r, binary.BigEndian, DefaultBytes)
	if err != nil {
		return errors.New("ValueField.Default string content unpack error\n" + err.Error())
	}
	this.Default = string(DefaultBytes[:len(DefaultBytes)-1])

	return err
}

const (
	TCaplusKeySetBaseVersion    uint32 = 1
	TCaplusKeySetCurrentVersion uint32 = 1
)

// TCaplusKeySet
type TCaplusKeySet struct {
	Version int32 `tdr_field:"Version"`

	FieldNum uint32 `tdr_field:"FieldNum"`

	Fields []*TCaplusKeyField `tdr_field:"Fields" tdr_count:"8" tdr_refer:"FieldNum"`
}

func NewTCaplusKeySet() *TCaplusKeySet {
	obj := new(TCaplusKeySet)
	obj.Init()
	return obj
}

func (this *TCaplusKeySet) GetBaseVersion() uint32 {
	return TCaplusKeySetBaseVersion
}

func (this *TCaplusKeySet) GetCurrentVersion() uint32 {
	return TCaplusKeySetCurrentVersion
}

func (this *TCaplusKeySet) Init() {

}

func (this *TCaplusKeySet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusKeySet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusKeySet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusKeySetCurrentVersion {
		cutVer = TCaplusKeySetCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusKeySetBaseVersion {
		return errors.New("TCaplusKeySet cut version must large than TCaplusKeySetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusKeySet.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldNum)
	if err != nil {
		return errors.New("TCaplusKeySet.FieldNum pack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TCaplusKeySet.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 8 {
		return errors.New("TCaplusKeySet.Fields's refer FieldNum should <= count 8")
	}
	if len(this.Fields) < int(this.FieldNum) {
		return errors.New("TCaplusKeySet.Fields's length should > FieldNum")
	}
	if this.FieldNum > 0 {
		for i := 0; i < int(this.FieldNum); i++ {
			err = this.Fields[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusKeySet.Fields pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TCaplusKeySet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusKeySet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusKeySet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusKeySetCurrentVersion {
		cutVer = TCaplusKeySetCurrentVersion
	}
	// check version
	if cutVer < TCaplusKeySetBaseVersion {
		errors.New("TCaplusKeySet cut version must large than TCaplusKeySetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusKeySet.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum)
	if err != nil {
		return errors.New("TCaplusKeySet.FieldNum unpack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TCaplusKeySet.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 8 {
		return errors.New("TCaplusKeySet.Fields's refer FieldNum should <= count 8")
	}

	if this.Fields == nil {
		this.Fields = make([]*TCaplusKeyField, int(this.FieldNum))
		for i := 0; i < int(this.FieldNum); i++ {
			this.Fields[i] = NewTCaplusKeyField()
		}
	}

	for i := 0; i < int(this.FieldNum); i++ {
		err = this.Fields[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusKeySet.Fields unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	FieldIndexBaseVersion    uint32 = 109
	FieldIndexCurrentVersion uint32 = 109
)

// FieldIndex
type FieldIndex struct {
	Offset int32 `tdr_field:"Offset"`

	Size int32 `tdr_field:"Size"`

	Flag int32 `tdr_field:"Flag"`
}

func NewFieldIndex() *FieldIndex {
	obj := new(FieldIndex)
	obj.Init()
	return obj
}

func (this *FieldIndex) GetBaseVersion() uint32 {
	return FieldIndexBaseVersion
}

func (this *FieldIndex) GetCurrentVersion() uint32 {
	return FieldIndexCurrentVersion
}

func (this *FieldIndex) Init() {

}

func (this *FieldIndex) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("FieldIndex Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *FieldIndex) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > FieldIndexCurrentVersion {
		cutVer = FieldIndexCurrentVersion
	}
	// check cut version
	if cutVer < FieldIndexBaseVersion {
		return errors.New("FieldIndex cut version must large than FieldIndexBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Offset)
	if err != nil {
		return errors.New("FieldIndex.Offset pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Size)
	if err != nil {
		return errors.New("FieldIndex.Size pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("FieldIndex.Flag pack error\n" + err.Error())
	}

	return nil
}

func (this *FieldIndex) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("FieldIndex data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *FieldIndex) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > FieldIndexCurrentVersion {
		cutVer = FieldIndexCurrentVersion
	}
	// check version
	if cutVer < FieldIndexBaseVersion {
		errors.New("FieldIndex cut version must large than FieldIndexBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Offset)
	if err != nil {
		return errors.New("FieldIndex.Offset unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Size)
	if err != nil {
		return errors.New("FieldIndex.Size unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("FieldIndex.Flag unpack error\n" + err.Error())
	}

	return err
}

const (
	CompactValueSetBaseVersion    uint32 = 109
	CompactValueSetCurrentVersion uint32 = 109
)

// CompactValueSet
type CompactValueSet struct {
	FieldIndexNum int32 `tdr_field:"FieldIndexNum"`

	FieldIndexs []*FieldIndex `tdr_field:"FieldIndexs" tdr_count:"256" tdr_refer:"FieldIndexNum"`

	ValueBufLen int32 `tdr_field:"ValueBufLen"`

	ValueBuf []byte `tdr_field:"ValueBuf" tdr_count:"10200000" tdr_refer:"ValueBufLen"`
}

func NewCompactValueSet() *CompactValueSet {
	obj := new(CompactValueSet)
	obj.Init()
	return obj
}

func (this *CompactValueSet) GetBaseVersion() uint32 {
	return CompactValueSetBaseVersion
}

func (this *CompactValueSet) GetCurrentVersion() uint32 {
	return CompactValueSetCurrentVersion
}

func (this *CompactValueSet) Init() {

}

func (this *CompactValueSet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CompactValueSet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CompactValueSet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CompactValueSetCurrentVersion {
		cutVer = CompactValueSetCurrentVersion
	}
	// check cut version
	if cutVer < CompactValueSetBaseVersion {
		return errors.New("CompactValueSet cut version must large than CompactValueSetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.FieldIndexNum)
	if err != nil {
		return errors.New("CompactValueSet.FieldIndexNum pack error\n" + err.Error())
	}

	if this.FieldIndexNum < 0 {
		return errors.New("CompactValueSet.FieldIndexs's refer FieldIndexNum should >= 0")
	}
	if this.FieldIndexNum > 256 {
		return errors.New("CompactValueSet.FieldIndexs's refer FieldIndexNum should <= count 256")
	}
	if len(this.FieldIndexs) < int(this.FieldIndexNum) {
		return errors.New("CompactValueSet.FieldIndexs's length should > FieldIndexNum")
	}
	if this.FieldIndexNum > 0 {
		for i := 0; i < int(this.FieldIndexNum); i++ {
			err = this.FieldIndexs[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("CompactValueSet.FieldIndexs pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.ValueBufLen)
	if err != nil {
		return errors.New("CompactValueSet.ValueBufLen pack error\n" + err.Error())
	}

	if this.ValueBufLen < 0 {
		return errors.New("CompactValueSet.ValueBuf's refer ValueBufLen should >= 0")
	}
	if this.ValueBufLen > 10200000 {
		return errors.New("CompactValueSet.ValueBuf's refer ValueBufLen should <= count 10200000")
	}
	if len(this.ValueBuf) < int(this.ValueBufLen) {
		return errors.New("CompactValueSet.ValueBuf's length should > ValueBufLen")
	}
	if this.ValueBufLen > 0 {
		referValueBuf := this.ValueBuf[:this.ValueBufLen]
		err = binary.Write(w, binary.BigEndian, referValueBuf)
		if err != nil {
			return errors.New("CompactValueSet.ValueBuf pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *CompactValueSet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CompactValueSet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CompactValueSet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CompactValueSetCurrentVersion {
		cutVer = CompactValueSetCurrentVersion
	}
	// check version
	if cutVer < CompactValueSetBaseVersion {
		errors.New("CompactValueSet cut version must large than CompactValueSetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldIndexNum)
	if err != nil {
		return errors.New("CompactValueSet.FieldIndexNum unpack error\n" + err.Error())
	}

	if this.FieldIndexNum < 0 {
		return errors.New("CompactValueSet.FieldIndexs's refer FieldIndexNum should >= 0")
	}
	if this.FieldIndexNum > 256 {
		return errors.New("CompactValueSet.FieldIndexs's refer FieldIndexNum should <= count 256")
	}

	if this.FieldIndexs == nil {
		this.FieldIndexs = make([]*FieldIndex, int(this.FieldIndexNum))
		for i := 0; i < int(this.FieldIndexNum); i++ {
			this.FieldIndexs[i] = NewFieldIndex()
		}
	}

	for i := 0; i < int(this.FieldIndexNum); i++ {
		err = this.FieldIndexs[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("CompactValueSet.FieldIndexs unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.ValueBufLen)
	if err != nil {
		return errors.New("CompactValueSet.ValueBufLen unpack error\n" + err.Error())
	}

	if this.ValueBufLen < 0 {
		return errors.New("CompactValueSet.ValueBuf's refer ValueBufLen should >= 0")
	}
	if this.ValueBufLen > 10200000 {
		return errors.New("CompactValueSet.ValueBuf's refer ValueBufLen should <= count 10200000")
	}

	if this.ValueBuf == nil {
		this.ValueBuf = make([]byte, int(this.ValueBufLen))
	}

	referValueBuf := this.ValueBuf[:this.ValueBufLen]
	err = binary.Read(r, binary.BigEndian, referValueBuf)
	if err != nil {
		return errors.New("CompactValueSet.ValueBuf pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusValueSet_BaseVersion            uint32 = 1
	TCaplusValueSet_CurrentVersion         uint32 = 109
	TCaplusValueSet_EncodeTypeVersion      uint32 = 109
	TCaplusValueSet_CompactValueSetVersion uint32 = 109
)

// TCaplusValueSet_
type TCaplusValueSet_ struct {
	Version_ int32 `tdr_field:"Version_"`

	FieldNum_ uint32 `tdr_field:"FieldNum_"`

	Fields_ []*TCaplusValueField_ `tdr_field:"Fields_" tdr_count:"128" tdr_refer:"FieldNum_"`

	EncodeType int32 `tdr_field:"EncodeType"`

	CompactValueSet *CompactValueSet `tdr_field:"CompactValueSet"`
}

func NewTCaplusValueSet_() *TCaplusValueSet_ {
	obj := new(TCaplusValueSet_)
	obj.Init()
	return obj
}

func (this *TCaplusValueSet_) GetBaseVersion() uint32 {
	return TCaplusValueSet_BaseVersion
}

func (this *TCaplusValueSet_) GetCurrentVersion() uint32 {
	return TCaplusValueSet_CurrentVersion
}

func (this *TCaplusValueSet_) Init() {

	this.CompactValueSet = NewCompactValueSet()

}

func (this *TCaplusValueSet_) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusValueSet_ Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusValueSet_) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusValueSet_CurrentVersion {
		cutVer = TCaplusValueSet_CurrentVersion
	}
	// check cut version
	if cutVer < TCaplusValueSet_BaseVersion {
		return errors.New("TCaplusValueSet_ cut version must large than TCaplusValueSet_BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version_)
	if err != nil {
		return errors.New("TCaplusValueSet_.Version_ pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldNum_)
	if err != nil {
		return errors.New("TCaplusValueSet_.FieldNum_ pack error\n" + err.Error())
	}

	if this.FieldNum_ < 0 {
		return errors.New("TCaplusValueSet_.Fields_'s refer FieldNum_ should >= 0")
	}
	if this.FieldNum_ > 128 {
		return errors.New("TCaplusValueSet_.Fields_'s refer FieldNum_ should <= count 128")
	}
	if len(this.Fields_) < int(this.FieldNum_) {
		return errors.New("TCaplusValueSet_.Fields_'s length should > FieldNum_")
	}
	if this.FieldNum_ > 0 {
		for i := 0; i < int(this.FieldNum_); i++ {
			err = this.Fields_[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusValueSet_.Fields_ pack error\n" + err.Error())
			}

		}
	}

	if cutVer >= TCaplusValueSet_EncodeTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.EncodeType)
		if err != nil {
			return errors.New("TCaplusValueSet_.EncodeType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusValueSet_CompactValueSetVersion {

		err = this.CompactValueSet.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusValueSet_.CompactValueSet pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusValueSet_) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusValueSet_ data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusValueSet_) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusValueSet_CurrentVersion {
		cutVer = TCaplusValueSet_CurrentVersion
	}
	// check version
	if cutVer < TCaplusValueSet_BaseVersion {
		errors.New("TCaplusValueSet_ cut version must large than TCaplusValueSet_BaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version_)
	if err != nil {
		return errors.New("TCaplusValueSet_.Version_ unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum_)
	if err != nil {
		return errors.New("TCaplusValueSet_.FieldNum_ unpack error\n" + err.Error())
	}

	if this.FieldNum_ < 0 {
		return errors.New("TCaplusValueSet_.Fields_'s refer FieldNum_ should >= 0")
	}
	if this.FieldNum_ > 128 {
		return errors.New("TCaplusValueSet_.Fields_'s refer FieldNum_ should <= count 128")
	}

	if this.Fields_ == nil {
		this.Fields_ = make([]*TCaplusValueField_, int(this.FieldNum_))
		for i := 0; i < int(this.FieldNum_); i++ {
			this.Fields_[i] = NewTCaplusValueField_()
		}
	}

	for i := 0; i < int(this.FieldNum_); i++ {
		err = this.Fields_[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusValueSet_.Fields_ unpack error\n" + err.Error())
		}

	}

	if cutVer >= TCaplusValueSet_EncodeTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.EncodeType)
		if err != nil {
			return errors.New("TCaplusValueSet_.EncodeType unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusValueSet_CompactValueSetVersion {

		err = this.CompactValueSet.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusValueSet_.CompactValueSet unpack error\n" + err.Error())
		}

	} else {
		this.CompactValueSet.Init()

	}
	return err
}

const (
	SortBufferBaseVersion    uint32 = 91
	SortBufferCurrentVersion uint32 = 91
)

// SortBuffer
type SortBuffer struct {
	SortBuf []byte `tdr_field:"SortBuf" tdr_count:"8"`
}

func NewSortBuffer() *SortBuffer {
	obj := new(SortBuffer)
	obj.Init()
	return obj
}

func (this *SortBuffer) GetBaseVersion() uint32 {
	return SortBufferBaseVersion
}

func (this *SortBuffer) GetCurrentVersion() uint32 {
	return SortBufferCurrentVersion
}

func (this *SortBuffer) Init() {

}

func (this *SortBuffer) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("SortBuffer Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *SortBuffer) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > SortBufferCurrentVersion {
		cutVer = SortBufferCurrentVersion
	}
	// check cut version
	if cutVer < SortBufferBaseVersion {
		return errors.New("SortBuffer cut version must large than SortBufferBaseVersion\n")
	}

	var err error

	if len(this.SortBuf) != int(8) {
		return errors.New("SortBuffer.SortBuf's length should = 8")
	}
	err = binary.Write(w, binary.BigEndian, this.SortBuf[:])
	if err != nil {
		return errors.New("SortBuffer.SortBuf pack error\n" + err.Error())
	}

	return nil
}

func (this *SortBuffer) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("SortBuffer data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *SortBuffer) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > SortBufferCurrentVersion {
		cutVer = SortBufferCurrentVersion
	}
	// check version
	if cutVer < SortBufferBaseVersion {
		errors.New("SortBuffer cut version must large than SortBufferBaseVersion\n")
	}

	if this.SortBuf == nil {
		this.SortBuf = make([]byte, int(8))
	}

	err = binary.Read(r, binary.BigEndian, this.SortBuf[:])
	if err != nil {
		return errors.New("SortBuffer.SortBuf unpack error\n" + err.Error())
	}

	return err
}

const (
	SortFieldInfoBaseVersion    uint32 = 91
	SortFieldInfoCurrentVersion uint32 = 91
)

// SortFieldInfo
type SortFieldInfo struct {
	SortField []*SortBuffer `tdr_field:"SortField" tdr_count:"4"`
}

func NewSortFieldInfo() *SortFieldInfo {
	obj := new(SortFieldInfo)
	obj.Init()
	return obj
}

func (this *SortFieldInfo) GetBaseVersion() uint32 {
	return SortFieldInfoBaseVersion
}

func (this *SortFieldInfo) GetCurrentVersion() uint32 {
	return SortFieldInfoCurrentVersion
}

func (this *SortFieldInfo) Init() {

}

func (this *SortFieldInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("SortFieldInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *SortFieldInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > SortFieldInfoCurrentVersion {
		cutVer = SortFieldInfoCurrentVersion
	}
	// check cut version
	if cutVer < SortFieldInfoBaseVersion {
		return errors.New("SortFieldInfo cut version must large than SortFieldInfoBaseVersion\n")
	}

	var err error

	if len(this.SortField) != int(4) {
		return errors.New("SortFieldInfo.SortField's length should = 4")
	}
	for i := 0; i < int(4); i++ {
		err = this.SortField[i].PackTo(cutVer, w)
		if err != nil {
			return errors.New("SortFieldInfo.SortField pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *SortFieldInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("SortFieldInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *SortFieldInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > SortFieldInfoCurrentVersion {
		cutVer = SortFieldInfoCurrentVersion
	}
	// check version
	if cutVer < SortFieldInfoBaseVersion {
		errors.New("SortFieldInfo cut version must large than SortFieldInfoBaseVersion\n")
	}

	if this.SortField == nil {
		this.SortField = make([]*SortBuffer, int(4))
		for i := 0; i < int(4); i++ {
			this.SortField[i] = NewSortBuffer()
		}
	}

	for i := 0; i < int(4); i++ {
		err = this.SortField[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("SortFieldInfo.SortField unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	TcapListIndexBaseVersion          uint32 = 1
	TcapListIndexCurrentVersion       uint32 = 91
	TcapListIndexVersionVersion       uint32 = 91
	TcapListIndexSortFieldNumVersion  uint32 = 91
	TcapListIndexSortFieldInfoVersion uint32 = 91
)

// TcapListIndex
type TcapListIndex struct {
	ElementNum int32 `tdr_field:"ElementNum"`

	CurBiggestIdx uint32 `tdr_field:"CurBiggestIdx"`

	Index []int32 `tdr_field:"Index" tdr_count:"10240" tdr_refer:"ElementNum"`

	Version int32 `tdr_field:"version"`

	SortFieldNum int32 `tdr_field:"SortFieldNum"`

	SortFieldInfo []*SortFieldInfo `tdr_field:"SortFieldInfo" tdr_count:"10240" tdr_refer:"ElementNum"`
}

func NewTcapListIndex() *TcapListIndex {
	obj := new(TcapListIndex)
	obj.Init()
	return obj
}

func (this *TcapListIndex) GetBaseVersion() uint32 {
	return TcapListIndexBaseVersion
}

func (this *TcapListIndex) GetCurrentVersion() uint32 {
	return TcapListIndexCurrentVersion
}

func (this *TcapListIndex) Init() {

	this.Version = 0

	this.SortFieldNum = 0

}

func (this *TcapListIndex) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TcapListIndex Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapListIndex) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapListIndexCurrentVersion {
		cutVer = TcapListIndexCurrentVersion
	}
	// check cut version
	if cutVer < TcapListIndexBaseVersion {
		return errors.New("TcapListIndex cut version must large than TcapListIndexBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementNum)
	if err != nil {
		return errors.New("TcapListIndex.ElementNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CurBiggestIdx)
	if err != nil {
		return errors.New("TcapListIndex.CurBiggestIdx pack error\n" + err.Error())
	}

	if this.ElementNum < 0 {
		return errors.New("TcapListIndex.Index's refer ElementNum should >= 0")
	}
	if this.ElementNum > 10240 {
		return errors.New("TcapListIndex.Index's refer ElementNum should <= count 10240")
	}
	if len(this.Index) < int(this.ElementNum) {
		return errors.New("TcapListIndex.Index's length should > ElementNum")
	}
	if this.ElementNum > 0 {
		referIndex := this.Index[:this.ElementNum]
		err = binary.Write(w, binary.BigEndian, referIndex)
		if err != nil {
			return errors.New("TcapListIndex.Index pack error\n" + err.Error())
		}
	}

	if cutVer >= TcapListIndexVersionVersion {

		err = binary.Write(w, binary.BigEndian, this.Version)
		if err != nil {
			return errors.New("TcapListIndex.Version pack error\n" + err.Error())
		}

	}
	if cutVer >= TcapListIndexSortFieldNumVersion {

		err = binary.Write(w, binary.BigEndian, this.SortFieldNum)
		if err != nil {
			return errors.New("TcapListIndex.SortFieldNum pack error\n" + err.Error())
		}

	}
	if cutVer >= TcapListIndexSortFieldInfoVersion {

		if this.ElementNum < 0 {
			return errors.New("TcapListIndex.SortFieldInfo's refer ElementNum should >= 0")
		}
		if this.ElementNum > 10240 {
			return errors.New("TcapListIndex.SortFieldInfo's refer ElementNum should <= count 10240")
		}
		if len(this.SortFieldInfo) < int(this.ElementNum) {
			return errors.New("TcapListIndex.SortFieldInfo's length should > ElementNum")
		}
		if this.ElementNum > 0 {
			for i := 0; i < int(this.ElementNum); i++ {
				err = this.SortFieldInfo[i].PackTo(cutVer, w)
				if err != nil {
					return errors.New("TcapListIndex.SortFieldInfo pack error\n" + err.Error())
				}

			}
		}

	}

	return nil
}

func (this *TcapListIndex) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TcapListIndex data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TcapListIndex) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapListIndexCurrentVersion {
		cutVer = TcapListIndexCurrentVersion
	}
	// check version
	if cutVer < TcapListIndexBaseVersion {
		errors.New("TcapListIndex cut version must large than TcapListIndexBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementNum)
	if err != nil {
		return errors.New("TcapListIndex.ElementNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CurBiggestIdx)
	if err != nil {
		return errors.New("TcapListIndex.CurBiggestIdx unpack error\n" + err.Error())
	}

	if this.ElementNum < 0 {
		return errors.New("TcapListIndex.Index's refer ElementNum should >= 0")
	}
	if this.ElementNum > 10240 {
		return errors.New("TcapListIndex.Index's refer ElementNum should <= count 10240")
	}

	if this.Index == nil {
		this.Index = make([]int32, int(this.ElementNum))
	}

	referIndex := this.Index[:this.ElementNum]
	err = binary.Read(r, binary.BigEndian, referIndex)
	if err != nil {
		return errors.New("TcapListIndex.Index pack error\n" + err.Error())
	}

	if cutVer >= TcapListIndexVersionVersion {

		err = binary.Read(r, binary.BigEndian, &this.Version)
		if err != nil {
			return errors.New("TcapListIndex.Version unpack error\n" + err.Error())
		}

	} else {
		this.Version = 0

	}
	if cutVer >= TcapListIndexSortFieldNumVersion {

		err = binary.Read(r, binary.BigEndian, &this.SortFieldNum)
		if err != nil {
			return errors.New("TcapListIndex.SortFieldNum unpack error\n" + err.Error())
		}

	} else {
		this.SortFieldNum = 0

	}
	if cutVer >= TcapListIndexSortFieldInfoVersion {

		if this.ElementNum < 0 {
			return errors.New("TcapListIndex.SortFieldInfo's refer ElementNum should >= 0")
		}
		if this.ElementNum > 10240 {
			return errors.New("TcapListIndex.SortFieldInfo's refer ElementNum should <= count 10240")
		}

		if this.SortFieldInfo == nil {
			this.SortFieldInfo = make([]*SortFieldInfo, int(this.ElementNum))
			for i := 0; i < int(this.ElementNum); i++ {
				this.SortFieldInfo[i] = NewSortFieldInfo()
			}
		}

		for i := 0; i < int(this.ElementNum); i++ {
			err = this.SortFieldInfo[i].UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TcapListIndex.SortFieldInfo unpack error\n" + err.Error())
			}

		}

	} else {

	}
	return err
}

const (
	TCaplusKeyMetadataFieldBaseVersion    uint32 = 1
	TCaplusKeyMetadataFieldCurrentVersion uint32 = 1
)

// TCaplusKeyMetadataField
type TCaplusKeyMetadataField struct {
	FieldName string `tdr_field:"FieldName"`

	FieldType byte `tdr_field:"FieldType"`

	FieldMaxLen uint32 `tdr_field:"FieldMaxLen"`

	FieldIdx byte `tdr_field:"FieldIdx"`

	IsGenKeyMeta byte `tdr_field:"IsGenKeyMeta"`
}

func NewTCaplusKeyMetadataField() *TCaplusKeyMetadataField {
	obj := new(TCaplusKeyMetadataField)
	obj.Init()
	return obj
}

func (this *TCaplusKeyMetadataField) GetBaseVersion() uint32 {
	return TCaplusKeyMetadataFieldBaseVersion
}

func (this *TCaplusKeyMetadataField) GetCurrentVersion() uint32 {
	return TCaplusKeyMetadataFieldCurrentVersion
}

func (this *TCaplusKeyMetadataField) Init() {

	this.FieldMaxLen = 0

	this.IsGenKeyMeta = 0

}

func (this *TCaplusKeyMetadataField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusKeyMetadataField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusKeyMetadataField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusKeyMetadataFieldCurrentVersion {
		cutVer = TCaplusKeyMetadataFieldCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusKeyMetadataFieldBaseVersion {
		return errors.New("TCaplusKeyMetadataField cut version must large than TCaplusKeyMetadataFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName))+1)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName), 0))
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldType)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldType pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldMaxLen)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldMaxLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldIdx)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldIdx pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsGenKeyMeta)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.IsGenKeyMeta pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusKeyMetadataField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusKeyMetadataField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusKeyMetadataField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusKeyMetadataFieldCurrentVersion {
		cutVer = TCaplusKeyMetadataFieldCurrentVersion
	}
	// check version
	if cutVer < TCaplusKeyMetadataFieldBaseVersion {
		errors.New("TCaplusKeyMetadataField cut version must large than TCaplusKeyMetadataFieldBaseVersion\n")
	}

	var FieldNameSize uint32
	err = binary.Read(r, binary.BigEndian, &FieldNameSize)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldName string size unpack error\n" + err.Error())
	}

	FieldNameBytes := make([]byte, FieldNameSize)
	err = binary.Read(r, binary.BigEndian, FieldNameBytes)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldName string content unpack error\n" + err.Error())
	}
	this.FieldName = string(FieldNameBytes[:len(FieldNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.FieldType)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldType unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldMaxLen)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldMaxLen unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldIdx)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.FieldIdx unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsGenKeyMeta)
	if err != nil {
		return errors.New("TCaplusKeyMetadataField.IsGenKeyMeta unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusValueMetadataFieldBaseVersion    uint32 = 1
	TCaplusValueMetadataFieldCurrentVersion uint32 = 1
)

// TCaplusValueMetadataField
type TCaplusValueMetadataField struct {
	FieldName string `tdr_field:"FieldName"`

	FieldType byte `tdr_field:"FieldType"`

	FieldMaxLen uint32 `tdr_field:"FieldMaxLen"`

	FieldIdx byte `tdr_field:"FieldIdx"`

	IsGenKeyMeta byte `tdr_field:"IsGenKeyMeta"`

	FieldDefaultValueLen uint32 `tdr_field:"FieldDefaultValueLen"`

	FieldDefaultValue []byte `tdr_field:"FieldDefaultValue" tdr_count:"64" tdr_refer:"FieldDefaultValueLen"`
}

func NewTCaplusValueMetadataField() *TCaplusValueMetadataField {
	obj := new(TCaplusValueMetadataField)
	obj.Init()
	return obj
}

func (this *TCaplusValueMetadataField) GetBaseVersion() uint32 {
	return TCaplusValueMetadataFieldBaseVersion
}

func (this *TCaplusValueMetadataField) GetCurrentVersion() uint32 {
	return TCaplusValueMetadataFieldCurrentVersion
}

func (this *TCaplusValueMetadataField) Init() {

	this.FieldMaxLen = 0

	this.IsGenKeyMeta = 0

	this.FieldDefaultValueLen = 0

}

func (this *TCaplusValueMetadataField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusValueMetadataField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusValueMetadataField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusValueMetadataFieldCurrentVersion {
		cutVer = TCaplusValueMetadataFieldCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusValueMetadataFieldBaseVersion {
		return errors.New("TCaplusValueMetadataField cut version must large than TCaplusValueMetadataFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName))+1)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName), 0))
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldType)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldType pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldMaxLen)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldMaxLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldIdx)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldIdx pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsGenKeyMeta)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.IsGenKeyMeta pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldDefaultValueLen)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValueLen pack error\n" + err.Error())
	}

	if this.FieldDefaultValueLen < 0 {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValue's refer FieldDefaultValueLen should >= 0")
	}
	if this.FieldDefaultValueLen > 64 {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValue's refer FieldDefaultValueLen should <= count 64")
	}
	if len(this.FieldDefaultValue) < int(this.FieldDefaultValueLen) {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValue's length should > FieldDefaultValueLen")
	}
	if this.FieldDefaultValueLen > 0 {
		referFieldDefaultValue := this.FieldDefaultValue[:this.FieldDefaultValueLen]
		err = binary.Write(w, binary.BigEndian, referFieldDefaultValue)
		if err != nil {
			return errors.New("TCaplusValueMetadataField.FieldDefaultValue pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusValueMetadataField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusValueMetadataField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusValueMetadataField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusValueMetadataFieldCurrentVersion {
		cutVer = TCaplusValueMetadataFieldCurrentVersion
	}
	// check version
	if cutVer < TCaplusValueMetadataFieldBaseVersion {
		errors.New("TCaplusValueMetadataField cut version must large than TCaplusValueMetadataFieldBaseVersion\n")
	}

	var FieldNameSize uint32
	err = binary.Read(r, binary.BigEndian, &FieldNameSize)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldName string size unpack error\n" + err.Error())
	}

	FieldNameBytes := make([]byte, FieldNameSize)
	err = binary.Read(r, binary.BigEndian, FieldNameBytes)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldName string content unpack error\n" + err.Error())
	}
	this.FieldName = string(FieldNameBytes[:len(FieldNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.FieldType)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldType unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldMaxLen)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldMaxLen unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldIdx)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldIdx unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsGenKeyMeta)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.IsGenKeyMeta unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldDefaultValueLen)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValueLen unpack error\n" + err.Error())
	}

	if this.FieldDefaultValueLen < 0 {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValue's refer FieldDefaultValueLen should >= 0")
	}
	if this.FieldDefaultValueLen > 64 {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValue's refer FieldDefaultValueLen should <= count 64")
	}

	if this.FieldDefaultValue == nil {
		this.FieldDefaultValue = make([]byte, int(this.FieldDefaultValueLen))
	}

	referFieldDefaultValue := this.FieldDefaultValue[:this.FieldDefaultValueLen]
	err = binary.Read(r, binary.BigEndian, referFieldDefaultValue)
	if err != nil {
		return errors.New("TCaplusValueMetadataField.FieldDefaultValue pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusKeyMetadataSetBaseVersion    uint32 = 1
	TCaplusKeyMetadataSetCurrentVersion uint32 = 1
)

// TCaplusKeyMetadataSet
type TCaplusKeyMetadataSet struct {
	KeyMetadataFieldNum uint32 `tdr_field:"KeyMetadataFieldNum"`

	KeyMetadataField []*TCaplusKeyMetadataField `tdr_field:"KeyMetadataField" tdr_count:"8" tdr_refer:"KeyMetadataFieldNum"`
}

func NewTCaplusKeyMetadataSet() *TCaplusKeyMetadataSet {
	obj := new(TCaplusKeyMetadataSet)
	obj.Init()
	return obj
}

func (this *TCaplusKeyMetadataSet) GetBaseVersion() uint32 {
	return TCaplusKeyMetadataSetBaseVersion
}

func (this *TCaplusKeyMetadataSet) GetCurrentVersion() uint32 {
	return TCaplusKeyMetadataSetCurrentVersion
}

func (this *TCaplusKeyMetadataSet) Init() {

}

func (this *TCaplusKeyMetadataSet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusKeyMetadataSet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusKeyMetadataSet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusKeyMetadataSetCurrentVersion {
		cutVer = TCaplusKeyMetadataSetCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusKeyMetadataSetBaseVersion {
		return errors.New("TCaplusKeyMetadataSet cut version must large than TCaplusKeyMetadataSetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.KeyMetadataFieldNum)
	if err != nil {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataFieldNum pack error\n" + err.Error())
	}

	if this.KeyMetadataFieldNum < 0 {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataField's refer KeyMetadataFieldNum should >= 0")
	}
	if this.KeyMetadataFieldNum > 8 {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataField's refer KeyMetadataFieldNum should <= count 8")
	}
	if len(this.KeyMetadataField) < int(this.KeyMetadataFieldNum) {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataField's length should > KeyMetadataFieldNum")
	}
	if this.KeyMetadataFieldNum > 0 {
		for i := 0; i < int(this.KeyMetadataFieldNum); i++ {
			err = this.KeyMetadataField[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusKeyMetadataSet.KeyMetadataField pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TCaplusKeyMetadataSet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusKeyMetadataSet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusKeyMetadataSet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusKeyMetadataSetCurrentVersion {
		cutVer = TCaplusKeyMetadataSetCurrentVersion
	}
	// check version
	if cutVer < TCaplusKeyMetadataSetBaseVersion {
		errors.New("TCaplusKeyMetadataSet cut version must large than TCaplusKeyMetadataSetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyMetadataFieldNum)
	if err != nil {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataFieldNum unpack error\n" + err.Error())
	}

	if this.KeyMetadataFieldNum < 0 {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataField's refer KeyMetadataFieldNum should >= 0")
	}
	if this.KeyMetadataFieldNum > 8 {
		return errors.New("TCaplusKeyMetadataSet.KeyMetadataField's refer KeyMetadataFieldNum should <= count 8")
	}

	if this.KeyMetadataField == nil {
		this.KeyMetadataField = make([]*TCaplusKeyMetadataField, int(this.KeyMetadataFieldNum))
		for i := 0; i < int(this.KeyMetadataFieldNum); i++ {
			this.KeyMetadataField[i] = NewTCaplusKeyMetadataField()
		}
	}

	for i := 0; i < int(this.KeyMetadataFieldNum); i++ {
		err = this.KeyMetadataField[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusKeyMetadataSet.KeyMetadataField unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	TCaplusValueMetadataSetBaseVersion    uint32 = 1
	TCaplusValueMetadataSetCurrentVersion uint32 = 1
)

// TCaplusValueMetadataSet
type TCaplusValueMetadataSet struct {
	ValueMetadataFieldNum uint32 `tdr_field:"ValueMetadataFieldNum"`

	ValueMetadataField []*TCaplusValueMetadataField `tdr_field:"ValueMetadataField" tdr_count:"256" tdr_refer:"ValueMetadataFieldNum"`
}

func NewTCaplusValueMetadataSet() *TCaplusValueMetadataSet {
	obj := new(TCaplusValueMetadataSet)
	obj.Init()
	return obj
}

func (this *TCaplusValueMetadataSet) GetBaseVersion() uint32 {
	return TCaplusValueMetadataSetBaseVersion
}

func (this *TCaplusValueMetadataSet) GetCurrentVersion() uint32 {
	return TCaplusValueMetadataSetCurrentVersion
}

func (this *TCaplusValueMetadataSet) Init() {

}

func (this *TCaplusValueMetadataSet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusValueMetadataSet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusValueMetadataSet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusValueMetadataSetCurrentVersion {
		cutVer = TCaplusValueMetadataSetCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusValueMetadataSetBaseVersion {
		return errors.New("TCaplusValueMetadataSet cut version must large than TCaplusValueMetadataSetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ValueMetadataFieldNum)
	if err != nil {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataFieldNum pack error\n" + err.Error())
	}

	if this.ValueMetadataFieldNum < 0 {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataField's refer ValueMetadataFieldNum should >= 0")
	}
	if this.ValueMetadataFieldNum > 256 {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataField's refer ValueMetadataFieldNum should <= count 256")
	}
	if len(this.ValueMetadataField) < int(this.ValueMetadataFieldNum) {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataField's length should > ValueMetadataFieldNum")
	}
	if this.ValueMetadataFieldNum > 0 {
		for i := 0; i < int(this.ValueMetadataFieldNum); i++ {
			err = this.ValueMetadataField[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusValueMetadataSet.ValueMetadataField pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TCaplusValueMetadataSet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusValueMetadataSet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusValueMetadataSet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusValueMetadataSetCurrentVersion {
		cutVer = TCaplusValueMetadataSetCurrentVersion
	}
	// check version
	if cutVer < TCaplusValueMetadataSetBaseVersion {
		errors.New("TCaplusValueMetadataSet cut version must large than TCaplusValueMetadataSetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ValueMetadataFieldNum)
	if err != nil {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataFieldNum unpack error\n" + err.Error())
	}

	if this.ValueMetadataFieldNum < 0 {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataField's refer ValueMetadataFieldNum should >= 0")
	}
	if this.ValueMetadataFieldNum > 256 {
		return errors.New("TCaplusValueMetadataSet.ValueMetadataField's refer ValueMetadataFieldNum should <= count 256")
	}

	if this.ValueMetadataField == nil {
		this.ValueMetadataField = make([]*TCaplusValueMetadataField, int(this.ValueMetadataFieldNum))
		for i := 0; i < int(this.ValueMetadataFieldNum); i++ {
			this.ValueMetadataField[i] = NewTCaplusValueMetadataField()
		}
	}

	for i := 0; i < int(this.ValueMetadataFieldNum); i++ {
		err = this.ValueMetadataField[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusValueMetadataSet.ValueMetadataField unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	DataExpireRuleLastAccessTimeBaseVersion              uint32 = 3
	DataExpireRuleLastAccessTimeCurrentVersion           uint32 = 84
	DataExpireRuleLastAccessTimeListEmptyIndexAgeVersion uint32 = 84
)

// DataExpireRuleLastAccessTime
type DataExpireRuleLastAccessTime struct {
	Age uint64 `tdr_field:"Age"`

	ListEmptyIndexAge uint64 `tdr_field:"ListEmptyIndexAge"`
}

func NewDataExpireRuleLastAccessTime() *DataExpireRuleLastAccessTime {
	obj := new(DataExpireRuleLastAccessTime)
	obj.Init()
	return obj
}

func (this *DataExpireRuleLastAccessTime) GetBaseVersion() uint32 {
	return DataExpireRuleLastAccessTimeBaseVersion
}

func (this *DataExpireRuleLastAccessTime) GetCurrentVersion() uint32 {
	return DataExpireRuleLastAccessTimeCurrentVersion
}

func (this *DataExpireRuleLastAccessTime) Init() {
	this.Age = 0

	this.ListEmptyIndexAge = 0

}

func (this *DataExpireRuleLastAccessTime) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DataExpireRuleLastAccessTime Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DataExpireRuleLastAccessTime) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DataExpireRuleLastAccessTimeCurrentVersion {
		cutVer = DataExpireRuleLastAccessTimeCurrentVersion
	}
	// check cut version
	if cutVer < DataExpireRuleLastAccessTimeBaseVersion {
		return errors.New("DataExpireRuleLastAccessTime cut version must large than DataExpireRuleLastAccessTimeBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Age)
	if err != nil {
		return errors.New("DataExpireRuleLastAccessTime.Age pack error\n" + err.Error())
	}

	if cutVer >= DataExpireRuleLastAccessTimeListEmptyIndexAgeVersion {

		err = binary.Write(w, binary.BigEndian, this.ListEmptyIndexAge)
		if err != nil {
			return errors.New("DataExpireRuleLastAccessTime.ListEmptyIndexAge pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *DataExpireRuleLastAccessTime) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DataExpireRuleLastAccessTime data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DataExpireRuleLastAccessTime) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DataExpireRuleLastAccessTimeCurrentVersion {
		cutVer = DataExpireRuleLastAccessTimeCurrentVersion
	}
	// check version
	if cutVer < DataExpireRuleLastAccessTimeBaseVersion {
		errors.New("DataExpireRuleLastAccessTime cut version must large than DataExpireRuleLastAccessTimeBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Age)
	if err != nil {
		return errors.New("DataExpireRuleLastAccessTime.Age unpack error\n" + err.Error())
	}

	if cutVer >= DataExpireRuleLastAccessTimeListEmptyIndexAgeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ListEmptyIndexAge)
		if err != nil {
			return errors.New("DataExpireRuleLastAccessTime.ListEmptyIndexAge unpack error\n" + err.Error())
		}

	} else {
		this.ListEmptyIndexAge = 0

	}
	return err
}

const (
	DataExpireUnionBaseVersion    uint32 = 3
	DataExpireUnionCurrentVersion uint32 = 84
)

// DataExpireUnion
type DataExpireUnion struct {
	RuleLastAccessTime *DataExpireRuleLastAccessTime `tdr_field:"RuleLastAccessTime"`
}

func NewDataExpireUnion(selector int64) *DataExpireUnion {
	obj := new(DataExpireUnion)
	obj.Init(selector)
	return obj
}

func (this *DataExpireUnion) GetBaseVersion() uint32 {
	return DataExpireUnionBaseVersion
}

func (this *DataExpireUnion) GetCurrentVersion() uint32 {
	return DataExpireUnionCurrentVersion
}

func (this *DataExpireUnion) Init(selector int64) {
	switch selector {
	case DATA_EXPIRE_RULE_LAST_ACCESS_TIME:
		this.RuleLastAccessTime = NewDataExpireRuleLastAccessTime()

	}
}

func (this *DataExpireUnion) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *DataExpireUnion) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DataExpireUnionCurrentVersion {
		cutVer = DataExpireUnionCurrentVersion
	}
	// check cut version
	if cutVer < DataExpireUnionBaseVersion {
		return errors.New("DataExpireUnion cut version must large than DataExpireUnionBaseVersion\n")
	}

	var err error = nil
	switch selector {
	case DATA_EXPIRE_RULE_LAST_ACCESS_TIME:
		if this.RuleLastAccessTime == nil {
			return errors.New("DataExpireUnion.RuleLastAccessTime is nil")
		}

		err = this.RuleLastAccessTime.PackTo(cutVer, w)
		if err != nil {
			return errors.New("DataExpireUnion.RuleLastAccessTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *DataExpireUnion) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("DataExpireUnion data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *DataExpireUnion) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DataExpireUnionCurrentVersion {
		cutVer = DataExpireUnionCurrentVersion
	}
	// check version
	if cutVer < DataExpireUnionBaseVersion {
		errors.New("DataExpireUnion cut version must large than DataExpireUnionBaseVersion\n")
	}

	switch selector {
	case DATA_EXPIRE_RULE_LAST_ACCESS_TIME:
		if this.RuleLastAccessTime == nil {
			this.RuleLastAccessTime = NewDataExpireRuleLastAccessTime()
		}

		err = this.RuleLastAccessTime.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("DataExpireUnion.RuleLastAccessTime unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	DataExpireRuleBaseVersion    uint32 = 3
	DataExpireRuleCurrentVersion uint32 = 84
)

// DataExpireRule
type DataExpireRule struct {
	RuleType int32 `tdr_field:"RuleType"`

	RuleItem *DataExpireUnion `tdr_field:"RuleItem" tdr_select:"RuleType"`
}

func NewDataExpireRule() *DataExpireRule {
	obj := new(DataExpireRule)
	obj.Init()
	return obj
}

func (this *DataExpireRule) GetBaseVersion() uint32 {
	return DataExpireRuleBaseVersion
}

func (this *DataExpireRule) GetCurrentVersion() uint32 {
	return DataExpireRuleCurrentVersion
}

func (this *DataExpireRule) Init() {

	this.RuleItem = NewDataExpireUnion(int64(this.RuleType))

}

func (this *DataExpireRule) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DataExpireRule Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DataExpireRule) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DataExpireRuleCurrentVersion {
		cutVer = DataExpireRuleCurrentVersion
	}
	// check cut version
	if cutVer < DataExpireRuleBaseVersion {
		return errors.New("DataExpireRule cut version must large than DataExpireRuleBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.RuleType)
	if err != nil {
		return errors.New("DataExpireRule.RuleType pack error\n" + err.Error())
	}

	err = this.RuleItem.PackTo(cutVer, w, int64(this.RuleType))
	if err != nil {
		return errors.New("DataExpireRule.RuleItem pack error\n" + err.Error())
	}

	return nil
}

func (this *DataExpireRule) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DataExpireRule data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DataExpireRule) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DataExpireRuleCurrentVersion {
		cutVer = DataExpireRuleCurrentVersion
	}
	// check version
	if cutVer < DataExpireRuleBaseVersion {
		errors.New("DataExpireRule cut version must large than DataExpireRuleBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.RuleType)
	if err != nil {
		return errors.New("DataExpireRule.RuleType unpack error\n" + err.Error())
	}

	err = this.RuleItem.UnpackFrom(cutVer, r, int64(this.RuleType))
	if err != nil {
		return errors.New("DataExpireRule.RuleItem unpack error\n" + err.Error())
	}

	return err
}

const (
	DataExpireBaseVersion    uint32 = 3
	DataExpireCurrentVersion uint32 = 84
)

// DataExpire
type DataExpire struct {
	RuleCnt int32 `tdr_field:"RuleCnt"`

	Rules []*DataExpireRule `tdr_field:"Rules" tdr_count:"2" tdr_refer:"RuleCnt"`
}

func NewDataExpire() *DataExpire {
	obj := new(DataExpire)
	obj.Init()
	return obj
}

func (this *DataExpire) GetBaseVersion() uint32 {
	return DataExpireBaseVersion
}

func (this *DataExpire) GetCurrentVersion() uint32 {
	return DataExpireCurrentVersion
}

func (this *DataExpire) Init() {
	this.RuleCnt = 0

}

func (this *DataExpire) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DataExpire Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DataExpire) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DataExpireCurrentVersion {
		cutVer = DataExpireCurrentVersion
	}
	// check cut version
	if cutVer < DataExpireBaseVersion {
		return errors.New("DataExpire cut version must large than DataExpireBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.RuleCnt)
	if err != nil {
		return errors.New("DataExpire.RuleCnt pack error\n" + err.Error())
	}

	if this.RuleCnt < 0 {
		return errors.New("DataExpire.Rules's refer RuleCnt should >= 0")
	}
	if this.RuleCnt > 2 {
		return errors.New("DataExpire.Rules's refer RuleCnt should <= count 2")
	}
	if len(this.Rules) < int(this.RuleCnt) {
		return errors.New("DataExpire.Rules's length should > RuleCnt")
	}
	if this.RuleCnt > 0 {
		for i := 0; i < int(this.RuleCnt); i++ {
			err = this.Rules[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("DataExpire.Rules pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *DataExpire) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DataExpire data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DataExpire) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DataExpireCurrentVersion {
		cutVer = DataExpireCurrentVersion
	}
	// check version
	if cutVer < DataExpireBaseVersion {
		errors.New("DataExpire cut version must large than DataExpireBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.RuleCnt)
	if err != nil {
		return errors.New("DataExpire.RuleCnt unpack error\n" + err.Error())
	}

	if this.RuleCnt < 0 {
		return errors.New("DataExpire.Rules's refer RuleCnt should >= 0")
	}
	if this.RuleCnt > 2 {
		return errors.New("DataExpire.Rules's refer RuleCnt should <= count 2")
	}

	if this.Rules == nil {
		this.Rules = make([]*DataExpireRule, int(this.RuleCnt))
		for i := 0; i < int(this.RuleCnt); i++ {
			this.Rules[i] = NewDataExpireRule()
		}
	}

	for i := 0; i < int(this.RuleCnt); i++ {
		err = this.Rules[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("DataExpire.Rules unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	TimeSpeedRuleItemBaseVersion    uint32 = 3
	TimeSpeedRuleItemCurrentVersion uint32 = 3
)

// TimeSpeedRuleItem
type TimeSpeedRuleItem struct {
	TimeLow int64 `tdr_field:"TimeLow"`

	TimeHigh int64 `tdr_field:"TimeHigh"`

	MaxSpeed int64 `tdr_field:"MaxSpeed"`
}

func NewTimeSpeedRuleItem() *TimeSpeedRuleItem {
	obj := new(TimeSpeedRuleItem)
	obj.Init()
	return obj
}

func (this *TimeSpeedRuleItem) GetBaseVersion() uint32 {
	return TimeSpeedRuleItemBaseVersion
}

func (this *TimeSpeedRuleItem) GetCurrentVersion() uint32 {
	return TimeSpeedRuleItemCurrentVersion
}

func (this *TimeSpeedRuleItem) Init() {

}

func (this *TimeSpeedRuleItem) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TimeSpeedRuleItem Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TimeSpeedRuleItem) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TimeSpeedRuleItemCurrentVersion {
		cutVer = TimeSpeedRuleItemCurrentVersion
	}
	// check cut version
	if cutVer < TimeSpeedRuleItemBaseVersion {
		return errors.New("TimeSpeedRuleItem cut version must large than TimeSpeedRuleItemBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.TimeLow)
	if err != nil {
		return errors.New("TimeSpeedRuleItem.TimeLow pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TimeHigh)
	if err != nil {
		return errors.New("TimeSpeedRuleItem.TimeHigh pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MaxSpeed)
	if err != nil {
		return errors.New("TimeSpeedRuleItem.MaxSpeed pack error\n" + err.Error())
	}

	return nil
}

func (this *TimeSpeedRuleItem) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TimeSpeedRuleItem data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TimeSpeedRuleItem) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TimeSpeedRuleItemCurrentVersion {
		cutVer = TimeSpeedRuleItemCurrentVersion
	}
	// check version
	if cutVer < TimeSpeedRuleItemBaseVersion {
		errors.New("TimeSpeedRuleItem cut version must large than TimeSpeedRuleItemBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.TimeLow)
	if err != nil {
		return errors.New("TimeSpeedRuleItem.TimeLow unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TimeHigh)
	if err != nil {
		return errors.New("TimeSpeedRuleItem.TimeHigh unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.MaxSpeed)
	if err != nil {
		return errors.New("TimeSpeedRuleItem.MaxSpeed unpack error\n" + err.Error())
	}

	return err
}

const (
	SpeedControlRulesBaseVersion    uint32 = 3
	SpeedControlRulesCurrentVersion uint32 = 3
)

// SpeedControlRules
type SpeedControlRules struct {
	RuleCnt int32 `tdr_field:"RuleCnt"`

	RuleItem []*TimeSpeedRuleItem `tdr_field:"RuleItem" tdr_count:"4" tdr_refer:"RuleCnt"`
}

func NewSpeedControlRules() *SpeedControlRules {
	obj := new(SpeedControlRules)
	obj.Init()
	return obj
}

func (this *SpeedControlRules) GetBaseVersion() uint32 {
	return SpeedControlRulesBaseVersion
}

func (this *SpeedControlRules) GetCurrentVersion() uint32 {
	return SpeedControlRulesCurrentVersion
}

func (this *SpeedControlRules) Init() {
	this.RuleCnt = 0

}

func (this *SpeedControlRules) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("SpeedControlRules Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *SpeedControlRules) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > SpeedControlRulesCurrentVersion {
		cutVer = SpeedControlRulesCurrentVersion
	}
	// check cut version
	if cutVer < SpeedControlRulesBaseVersion {
		return errors.New("SpeedControlRules cut version must large than SpeedControlRulesBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.RuleCnt)
	if err != nil {
		return errors.New("SpeedControlRules.RuleCnt pack error\n" + err.Error())
	}

	if this.RuleCnt < 0 {
		return errors.New("SpeedControlRules.RuleItem's refer RuleCnt should >= 0")
	}
	if this.RuleCnt > 4 {
		return errors.New("SpeedControlRules.RuleItem's refer RuleCnt should <= count 4")
	}
	if len(this.RuleItem) < int(this.RuleCnt) {
		return errors.New("SpeedControlRules.RuleItem's length should > RuleCnt")
	}
	if this.RuleCnt > 0 {
		for i := 0; i < int(this.RuleCnt); i++ {
			err = this.RuleItem[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("SpeedControlRules.RuleItem pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *SpeedControlRules) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("SpeedControlRules data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *SpeedControlRules) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > SpeedControlRulesCurrentVersion {
		cutVer = SpeedControlRulesCurrentVersion
	}
	// check version
	if cutVer < SpeedControlRulesBaseVersion {
		errors.New("SpeedControlRules cut version must large than SpeedControlRulesBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.RuleCnt)
	if err != nil {
		return errors.New("SpeedControlRules.RuleCnt unpack error\n" + err.Error())
	}

	if this.RuleCnt < 0 {
		return errors.New("SpeedControlRules.RuleItem's refer RuleCnt should >= 0")
	}
	if this.RuleCnt > 4 {
		return errors.New("SpeedControlRules.RuleItem's refer RuleCnt should <= count 4")
	}

	if this.RuleItem == nil {
		this.RuleItem = make([]*TimeSpeedRuleItem, int(this.RuleCnt))
		for i := 0; i < int(this.RuleCnt); i++ {
			this.RuleItem[i] = NewTimeSpeedRuleItem()
		}
	}

	for i := 0; i < int(this.RuleCnt); i++ {
		err = this.RuleItem[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("SpeedControlRules.RuleItem unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	Sasvr_InfoBaseVersion    uint32 = 37
	Sasvr_InfoCurrentVersion uint32 = 49
	Sasvr_InfoBuidVersion    uint32 = 49
)

// Sasvr_Info
type Sasvr_Info struct {
	Valid_Flag int32 `tdr_field:"valid_flag"`

	Buid int32 `tdr_field:"buid"`

	Process_Class string `tdr_field:"process_class"`

	Sasvr_Url string `tdr_field:"sasvr_url"`

	Report_Period uint32 `tdr_field:"report_period"`

	Last_Report_Tm uint64 `tdr_field:"last_report_tm"`
}

func NewSasvr_Info() *Sasvr_Info {
	obj := new(Sasvr_Info)
	obj.Init()
	return obj
}

func (this *Sasvr_Info) GetBaseVersion() uint32 {
	return Sasvr_InfoBaseVersion
}

func (this *Sasvr_Info) GetCurrentVersion() uint32 {
	return Sasvr_InfoCurrentVersion
}

func (this *Sasvr_Info) Init() {
	this.Valid_Flag = 0

	this.Buid = 1

	this.Report_Period = 0

	this.Last_Report_Tm = 0

}

func (this *Sasvr_Info) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Sasvr_Info Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Sasvr_Info) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Sasvr_InfoCurrentVersion {
		cutVer = Sasvr_InfoCurrentVersion
	}
	// check cut version
	if cutVer < Sasvr_InfoBaseVersion {
		return errors.New("Sasvr_Info cut version must large than Sasvr_InfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Valid_Flag)
	if err != nil {
		return errors.New("Sasvr_Info.Valid_Flag pack error\n" + err.Error())
	}

	if cutVer >= Sasvr_InfoBuidVersion {

		err = binary.Write(w, binary.BigEndian, this.Buid)
		if err != nil {
			return errors.New("Sasvr_Info.Buid pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Process_Class))+1)
	if err != nil {
		return errors.New("Sasvr_Info.Process_Class string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Process_Class), 0))
	if err != nil {
		return errors.New("Sasvr_Info.Process_Class string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Sasvr_Url))+1)
	if err != nil {
		return errors.New("Sasvr_Info.Sasvr_Url string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Sasvr_Url), 0))
	if err != nil {
		return errors.New("Sasvr_Info.Sasvr_Url string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Report_Period)
	if err != nil {
		return errors.New("Sasvr_Info.Report_Period pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Last_Report_Tm)
	if err != nil {
		return errors.New("Sasvr_Info.Last_Report_Tm pack error\n" + err.Error())
	}

	return nil
}

func (this *Sasvr_Info) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Sasvr_Info data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Sasvr_Info) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Sasvr_InfoCurrentVersion {
		cutVer = Sasvr_InfoCurrentVersion
	}
	// check version
	if cutVer < Sasvr_InfoBaseVersion {
		errors.New("Sasvr_Info cut version must large than Sasvr_InfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Valid_Flag)
	if err != nil {
		return errors.New("Sasvr_Info.Valid_Flag unpack error\n" + err.Error())
	}

	if cutVer >= Sasvr_InfoBuidVersion {

		err = binary.Read(r, binary.BigEndian, &this.Buid)
		if err != nil {
			return errors.New("Sasvr_Info.Buid unpack error\n" + err.Error())
		}

	} else {
		this.Buid = 1

	}

	var process_classSize uint32
	err = binary.Read(r, binary.BigEndian, &process_classSize)
	if err != nil {
		return errors.New("Sasvr_Info.Process_Class string size unpack error\n" + err.Error())
	}

	process_classBytes := make([]byte, process_classSize)
	err = binary.Read(r, binary.BigEndian, process_classBytes)
	if err != nil {
		return errors.New("Sasvr_Info.Process_Class string content unpack error\n" + err.Error())
	}
	this.Process_Class = string(process_classBytes[:len(process_classBytes)-1])

	var sasvr_urlSize uint32
	err = binary.Read(r, binary.BigEndian, &sasvr_urlSize)
	if err != nil {
		return errors.New("Sasvr_Info.Sasvr_Url string size unpack error\n" + err.Error())
	}

	sasvr_urlBytes := make([]byte, sasvr_urlSize)
	err = binary.Read(r, binary.BigEndian, sasvr_urlBytes)
	if err != nil {
		return errors.New("Sasvr_Info.Sasvr_Url string content unpack error\n" + err.Error())
	}
	this.Sasvr_Url = string(sasvr_urlBytes[:len(sasvr_urlBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Report_Period)
	if err != nil {
		return errors.New("Sasvr_Info.Report_Period unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Last_Report_Tm)
	if err != nil {
		return errors.New("Sasvr_Info.Last_Report_Tm unpack error\n" + err.Error())
	}

	return err
}

const (
	ProtobufValueField_BaseVersion    uint32 = 78
	ProtobufValueField_CurrentVersion uint32 = 78
)

// ProtobufValueField_
type ProtobufValueField_ struct {
	TagPath_ string `tdr_field:"TagPath_"`

	WireType_ uint32 `tdr_field:"WireType_"`

	FieldLen_ uint32 `tdr_field:"FieldLen_"`

	FieldBuff_ []byte `tdr_field:"FieldBuff_" tdr_count:"262144" tdr_refer:"FieldLen_"`
}

func NewProtobufValueField_() *ProtobufValueField_ {
	obj := new(ProtobufValueField_)
	obj.Init()
	return obj
}

func (this *ProtobufValueField_) GetBaseVersion() uint32 {
	return ProtobufValueField_BaseVersion
}

func (this *ProtobufValueField_) GetCurrentVersion() uint32 {
	return ProtobufValueField_CurrentVersion
}

func (this *ProtobufValueField_) Init() {

}

func (this *ProtobufValueField_) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ProtobufValueField_ Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ProtobufValueField_) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ProtobufValueField_CurrentVersion {
		cutVer = ProtobufValueField_CurrentVersion
	}
	// check cut version
	if cutVer < ProtobufValueField_BaseVersion {
		return errors.New("ProtobufValueField_ cut version must large than ProtobufValueField_BaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TagPath_))+1)
	if err != nil {
		return errors.New("ProtobufValueField_.TagPath_ string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TagPath_), 0))
	if err != nil {
		return errors.New("ProtobufValueField_.TagPath_ string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.WireType_)
	if err != nil {
		return errors.New("ProtobufValueField_.WireType_ pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldLen_)
	if err != nil {
		return errors.New("ProtobufValueField_.FieldLen_ pack error\n" + err.Error())
	}

	if this.FieldLen_ < 0 {
		return errors.New("ProtobufValueField_.FieldBuff_'s refer FieldLen_ should >= 0")
	}
	if this.FieldLen_ > 262144 {
		return errors.New("ProtobufValueField_.FieldBuff_'s refer FieldLen_ should <= count 262144")
	}
	if len(this.FieldBuff_) < int(this.FieldLen_) {
		return errors.New("ProtobufValueField_.FieldBuff_'s length should > FieldLen_")
	}
	if this.FieldLen_ > 0 {
		referFieldBuff_ := this.FieldBuff_[:this.FieldLen_]
		err = binary.Write(w, binary.BigEndian, referFieldBuff_)
		if err != nil {
			return errors.New("ProtobufValueField_.FieldBuff_ pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *ProtobufValueField_) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ProtobufValueField_ data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ProtobufValueField_) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ProtobufValueField_CurrentVersion {
		cutVer = ProtobufValueField_CurrentVersion
	}
	// check version
	if cutVer < ProtobufValueField_BaseVersion {
		errors.New("ProtobufValueField_ cut version must large than ProtobufValueField_BaseVersion\n")
	}

	var TagPath_Size uint32
	err = binary.Read(r, binary.BigEndian, &TagPath_Size)
	if err != nil {
		return errors.New("ProtobufValueField_.TagPath_ string size unpack error\n" + err.Error())
	}

	TagPath_Bytes := make([]byte, TagPath_Size)
	err = binary.Read(r, binary.BigEndian, TagPath_Bytes)
	if err != nil {
		return errors.New("ProtobufValueField_.TagPath_ string content unpack error\n" + err.Error())
	}
	this.TagPath_ = string(TagPath_Bytes[:len(TagPath_Bytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.WireType_)
	if err != nil {
		return errors.New("ProtobufValueField_.WireType_ unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldLen_)
	if err != nil {
		return errors.New("ProtobufValueField_.FieldLen_ unpack error\n" + err.Error())
	}

	if this.FieldLen_ < 0 {
		return errors.New("ProtobufValueField_.FieldBuff_'s refer FieldLen_ should >= 0")
	}
	if this.FieldLen_ > 262144 {
		return errors.New("ProtobufValueField_.FieldBuff_'s refer FieldLen_ should <= count 262144")
	}

	if this.FieldBuff_ == nil {
		this.FieldBuff_ = make([]byte, int(this.FieldLen_))
	}

	referFieldBuff_ := this.FieldBuff_[:this.FieldLen_]
	err = binary.Read(r, binary.BigEndian, referFieldBuff_)
	if err != nil {
		return errors.New("ProtobufValueField_.FieldBuff_ pack error\n" + err.Error())
	}

	return err
}

const (
	ProtobufValueSet_BaseVersion            uint32 = 78
	ProtobufValueSet_CurrentVersion         uint32 = 109
	ProtobufValueSet_Version_Version        uint32 = 102
	ProtobufValueSet_EncodeTypeVersion      uint32 = 109
	ProtobufValueSet_CompactValueSetVersion uint32 = 109
)

// ProtobufValueSet_
type ProtobufValueSet_ struct {
	Version_ int32 `tdr_field:"Version_"`

	FieldNum_ uint32 `tdr_field:"FieldNum_"`

	Fields_ []*ProtobufValueField_ `tdr_field:"Fields_" tdr_count:"128" tdr_refer:"FieldNum_"`

	EncodeType int32 `tdr_field:"EncodeType"`

	CompactValueSet *CompactValueSet `tdr_field:"CompactValueSet"`
}

func NewProtobufValueSet_() *ProtobufValueSet_ {
	obj := new(ProtobufValueSet_)
	obj.Init()
	return obj
}

func (this *ProtobufValueSet_) GetBaseVersion() uint32 {
	return ProtobufValueSet_BaseVersion
}

func (this *ProtobufValueSet_) GetCurrentVersion() uint32 {
	return ProtobufValueSet_CurrentVersion
}

func (this *ProtobufValueSet_) Init() {

	this.CompactValueSet = NewCompactValueSet()

}

func (this *ProtobufValueSet_) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ProtobufValueSet_ Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ProtobufValueSet_) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ProtobufValueSet_CurrentVersion {
		cutVer = ProtobufValueSet_CurrentVersion
	}
	// check cut version
	if cutVer < ProtobufValueSet_BaseVersion {
		return errors.New("ProtobufValueSet_ cut version must large than ProtobufValueSet_BaseVersion\n")
	}

	var err error
	if cutVer >= ProtobufValueSet_Version_Version {

		err = binary.Write(w, binary.BigEndian, this.Version_)
		if err != nil {
			return errors.New("ProtobufValueSet_.Version_ pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.FieldNum_)
	if err != nil {
		return errors.New("ProtobufValueSet_.FieldNum_ pack error\n" + err.Error())
	}

	if this.FieldNum_ < 0 {
		return errors.New("ProtobufValueSet_.Fields_'s refer FieldNum_ should >= 0")
	}
	if this.FieldNum_ > 128 {
		return errors.New("ProtobufValueSet_.Fields_'s refer FieldNum_ should <= count 128")
	}
	if len(this.Fields_) < int(this.FieldNum_) {
		return errors.New("ProtobufValueSet_.Fields_'s length should > FieldNum_")
	}
	if this.FieldNum_ > 0 {
		for i := 0; i < int(this.FieldNum_); i++ {
			err = this.Fields_[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("ProtobufValueSet_.Fields_ pack error\n" + err.Error())
			}

		}
	}

	if cutVer >= ProtobufValueSet_EncodeTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.EncodeType)
		if err != nil {
			return errors.New("ProtobufValueSet_.EncodeType pack error\n" + err.Error())
		}

	}
	if cutVer >= ProtobufValueSet_CompactValueSetVersion {

		err = this.CompactValueSet.PackTo(cutVer, w)
		if err != nil {
			return errors.New("ProtobufValueSet_.CompactValueSet pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *ProtobufValueSet_) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ProtobufValueSet_ data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ProtobufValueSet_) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ProtobufValueSet_CurrentVersion {
		cutVer = ProtobufValueSet_CurrentVersion
	}
	// check version
	if cutVer < ProtobufValueSet_BaseVersion {
		errors.New("ProtobufValueSet_ cut version must large than ProtobufValueSet_BaseVersion\n")
	}

	if cutVer >= ProtobufValueSet_Version_Version {

		err = binary.Read(r, binary.BigEndian, &this.Version_)
		if err != nil {
			return errors.New("ProtobufValueSet_.Version_ unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum_)
	if err != nil {
		return errors.New("ProtobufValueSet_.FieldNum_ unpack error\n" + err.Error())
	}

	if this.FieldNum_ < 0 {
		return errors.New("ProtobufValueSet_.Fields_'s refer FieldNum_ should >= 0")
	}
	if this.FieldNum_ > 128 {
		return errors.New("ProtobufValueSet_.Fields_'s refer FieldNum_ should <= count 128")
	}

	if this.Fields_ == nil {
		this.Fields_ = make([]*ProtobufValueField_, int(this.FieldNum_))
		for i := 0; i < int(this.FieldNum_); i++ {
			this.Fields_[i] = NewProtobufValueField_()
		}
	}

	for i := 0; i < int(this.FieldNum_); i++ {
		err = this.Fields_[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ProtobufValueSet_.Fields_ unpack error\n" + err.Error())
		}

	}

	if cutVer >= ProtobufValueSet_EncodeTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.EncodeType)
		if err != nil {
			return errors.New("ProtobufValueSet_.EncodeType unpack error\n" + err.Error())
		}

	}
	if cutVer >= ProtobufValueSet_CompactValueSetVersion {

		err = this.CompactValueSet.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ProtobufValueSet_.CompactValueSet unpack error\n" + err.Error())
		}

	} else {
		this.CompactValueSet.Init()

	}
	return err
}

const (
	ModifyWritelistBaseVersion    uint32 = 111
	ModifyWritelistCurrentVersion uint32 = 111
)

// ModifyWritelist
type ModifyWritelist struct {
	ZoneID int32 `tdr_field:"ZoneID"`

	ModifyCmd int32 `tdr_field:"ModifyCmd"`

	IpCount uint32 `tdr_field:"IpCount"`

	Writelist []string `tdr_field:"Writelist" tdr_count:"6000" tdr_refer:"IpCount"`
}

func NewModifyWritelist() *ModifyWritelist {
	obj := new(ModifyWritelist)
	obj.Init()
	return obj
}

func (this *ModifyWritelist) GetBaseVersion() uint32 {
	return ModifyWritelistBaseVersion
}

func (this *ModifyWritelist) GetCurrentVersion() uint32 {
	return ModifyWritelistCurrentVersion
}

func (this *ModifyWritelist) Init() {

	this.IpCount = 0

}

func (this *ModifyWritelist) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ModifyWritelist Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ModifyWritelist) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ModifyWritelistCurrentVersion {
		cutVer = ModifyWritelistCurrentVersion
	}
	// check cut version
	if cutVer < ModifyWritelistBaseVersion {
		return errors.New("ModifyWritelist cut version must large than ModifyWritelistBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("ModifyWritelist.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ModifyCmd)
	if err != nil {
		return errors.New("ModifyWritelist.ModifyCmd pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IpCount)
	if err != nil {
		return errors.New("ModifyWritelist.IpCount pack error\n" + err.Error())
	}

	if this.IpCount < 0 {
		return errors.New("ModifyWritelist.Writelist's refer IpCount should >= 0")
	}
	if this.IpCount > 6000 {
		return errors.New("ModifyWritelist.Writelist's refer IpCount should <= count 6000")
	}
	if len(this.Writelist) < int(this.IpCount) {
		return errors.New("ModifyWritelist.Writelist's length should > IpCount")
	}
	if this.IpCount > 0 {
		for i := 0; i < int(this.IpCount); i++ {
			err = binary.Write(w, binary.BigEndian, uint32(len(this.Writelist[i]))+1)
			if err != nil {
				return errors.New("ModifyWritelist.Writelist string size pack error\n" + err.Error())
			}
			err = binary.Write(w, binary.BigEndian, append([]byte(this.Writelist[i]), 0))
			if err != nil {
				return errors.New("ModifyWritelist.Writelist string content pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *ModifyWritelist) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ModifyWritelist data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ModifyWritelist) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ModifyWritelistCurrentVersion {
		cutVer = ModifyWritelistCurrentVersion
	}
	// check version
	if cutVer < ModifyWritelistBaseVersion {
		errors.New("ModifyWritelist cut version must large than ModifyWritelistBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("ModifyWritelist.ZoneID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ModifyCmd)
	if err != nil {
		return errors.New("ModifyWritelist.ModifyCmd unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IpCount)
	if err != nil {
		return errors.New("ModifyWritelist.IpCount unpack error\n" + err.Error())
	}

	if this.IpCount < 0 {
		return errors.New("ModifyWritelist.Writelist's refer IpCount should >= 0")
	}
	if this.IpCount > 6000 {
		return errors.New("ModifyWritelist.Writelist's refer IpCount should <= count 6000")
	}

	if this.Writelist == nil {
		this.Writelist = make([]string, int(this.IpCount))
	}

	for i := 0; i < int(this.IpCount); i++ {
		var WritelistSize uint32
		err = binary.Read(r, binary.BigEndian, &WritelistSize)
		if err != nil {
			return errors.New("ModifyWritelist.Writelist string size unpack error\n" + err.Error())
		}

		WritelistBytes := make([]byte, WritelistSize)
		err = binary.Read(r, binary.BigEndian, WritelistBytes)
		if err != nil {
			return errors.New("ModifyWritelist.Writelist string content unpack error\n" + err.Error())
		}
		this.Writelist[i] = string(WritelistBytes[:len(WritelistBytes)-1])

	}

	return err
}

const (
	ModifyServiceApiAccessWhitelistsReqBaseVersion    uint32 = 111
	ModifyServiceApiAccessWhitelistsReqCurrentVersion uint32 = 111
)

// ModifyServiceApiAccessWhitelistsReq
type ModifyServiceApiAccessWhitelistsReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneCount uint32 `tdr_field:"ZoneCount"`

	TotalZoneAccessWritelist []*ModifyWritelist `tdr_field:"TotalZoneAccessWritelist" tdr_count:"200" tdr_refer:"ZoneCount"`

	UserName string `tdr_field:"UserName"`
}

func NewModifyServiceApiAccessWhitelistsReq() *ModifyServiceApiAccessWhitelistsReq {
	obj := new(ModifyServiceApiAccessWhitelistsReq)
	obj.Init()
	return obj
}

func (this *ModifyServiceApiAccessWhitelistsReq) GetBaseVersion() uint32 {
	return ModifyServiceApiAccessWhitelistsReqBaseVersion
}

func (this *ModifyServiceApiAccessWhitelistsReq) GetCurrentVersion() uint32 {
	return ModifyServiceApiAccessWhitelistsReqCurrentVersion
}

func (this *ModifyServiceApiAccessWhitelistsReq) Init() {

	this.ZoneCount = 0

}

func (this *ModifyServiceApiAccessWhitelistsReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ModifyServiceApiAccessWhitelistsReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ModifyServiceApiAccessWhitelistsReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ModifyServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = ModifyServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check cut version
	if cutVer < ModifyServiceApiAccessWhitelistsReqBaseVersion {
		return errors.New("ModifyServiceApiAccessWhitelistsReq cut version must large than ModifyServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneCount)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.ZoneCount pack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should <= count 200")
	}
	if len(this.TotalZoneAccessWritelist) < int(this.ZoneCount) {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's length should > ZoneCount")
	}
	if this.ZoneCount > 0 {
		for i := 0; i < int(this.ZoneCount); i++ {
			err = this.TotalZoneAccessWritelist[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.UserName))+1)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.UserName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.UserName), 0))
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.UserName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *ModifyServiceApiAccessWhitelistsReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ModifyServiceApiAccessWhitelistsReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ModifyServiceApiAccessWhitelistsReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ModifyServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = ModifyServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check version
	if cutVer < ModifyServiceApiAccessWhitelistsReqBaseVersion {
		errors.New("ModifyServiceApiAccessWhitelistsReq cut version must large than ModifyServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneCount)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.ZoneCount unpack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should <= count 200")
	}

	if this.TotalZoneAccessWritelist == nil {
		this.TotalZoneAccessWritelist = make([]*ModifyWritelist, int(this.ZoneCount))
		for i := 0; i < int(this.ZoneCount); i++ {
			this.TotalZoneAccessWritelist[i] = NewModifyWritelist()
		}
	}

	for i := 0; i < int(this.ZoneCount); i++ {
		err = this.TotalZoneAccessWritelist[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("ModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist unpack error\n" + err.Error())
		}

	}

	var UserNameSize uint32
	err = binary.Read(r, binary.BigEndian, &UserNameSize)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.UserName string size unpack error\n" + err.Error())
	}

	UserNameBytes := make([]byte, UserNameSize)
	err = binary.Read(r, binary.BigEndian, UserNameBytes)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsReq.UserName string content unpack error\n" + err.Error())
	}
	this.UserName = string(UserNameBytes[:len(UserNameBytes)-1])

	return err
}

const (
	ModifyServiceApiAccessWhitelistsResBaseVersion    uint32 = 111
	ModifyServiceApiAccessWhitelistsResCurrentVersion uint32 = 111
)

// ModifyServiceApiAccessWhitelistsRes
type ModifyServiceApiAccessWhitelistsRes struct {
	Result int32 `tdr_field:"Result"`

	ErrMsg string `tdr_field:"ErrMsg"`
}

func NewModifyServiceApiAccessWhitelistsRes() *ModifyServiceApiAccessWhitelistsRes {
	obj := new(ModifyServiceApiAccessWhitelistsRes)
	obj.Init()
	return obj
}

func (this *ModifyServiceApiAccessWhitelistsRes) GetBaseVersion() uint32 {
	return ModifyServiceApiAccessWhitelistsResBaseVersion
}

func (this *ModifyServiceApiAccessWhitelistsRes) GetCurrentVersion() uint32 {
	return ModifyServiceApiAccessWhitelistsResCurrentVersion
}

func (this *ModifyServiceApiAccessWhitelistsRes) Init() {

}

func (this *ModifyServiceApiAccessWhitelistsRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ModifyServiceApiAccessWhitelistsRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ModifyServiceApiAccessWhitelistsRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ModifyServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = ModifyServiceApiAccessWhitelistsResCurrentVersion
	}
	// check cut version
	if cutVer < ModifyServiceApiAccessWhitelistsResBaseVersion {
		return errors.New("ModifyServiceApiAccessWhitelistsRes cut version must large than ModifyServiceApiAccessWhitelistsResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.ErrMsg))+1)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsRes.ErrMsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.ErrMsg), 0))
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsRes.ErrMsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *ModifyServiceApiAccessWhitelistsRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ModifyServiceApiAccessWhitelistsRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ModifyServiceApiAccessWhitelistsRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ModifyServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = ModifyServiceApiAccessWhitelistsResCurrentVersion
	}
	// check version
	if cutVer < ModifyServiceApiAccessWhitelistsResBaseVersion {
		errors.New("ModifyServiceApiAccessWhitelistsRes cut version must large than ModifyServiceApiAccessWhitelistsResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsRes.Result unpack error\n" + err.Error())
	}

	var ErrMsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrMsgSize)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsRes.ErrMsg string size unpack error\n" + err.Error())
	}

	ErrMsgBytes := make([]byte, ErrMsgSize)
	err = binary.Read(r, binary.BigEndian, ErrMsgBytes)
	if err != nil {
		return errors.New("ModifyServiceApiAccessWhitelistsRes.ErrMsg string content unpack error\n" + err.Error())
	}
	this.ErrMsg = string(ErrMsgBytes[:len(ErrMsgBytes)-1])

	return err
}

const (
	CheckModifyServiceApiAccessWhitelistsReqBaseVersion    uint32 = 111
	CheckModifyServiceApiAccessWhitelistsReqCurrentVersion uint32 = 111
)

// CheckModifyServiceApiAccessWhitelistsReq
type CheckModifyServiceApiAccessWhitelistsReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneCount uint32 `tdr_field:"ZoneCount"`

	TotalZoneAccessWritelist []*ModifyWritelist `tdr_field:"TotalZoneAccessWritelist" tdr_count:"200" tdr_refer:"ZoneCount"`

	UserName string `tdr_field:"UserName"`
}

func NewCheckModifyServiceApiAccessWhitelistsReq() *CheckModifyServiceApiAccessWhitelistsReq {
	obj := new(CheckModifyServiceApiAccessWhitelistsReq)
	obj.Init()
	return obj
}

func (this *CheckModifyServiceApiAccessWhitelistsReq) GetBaseVersion() uint32 {
	return CheckModifyServiceApiAccessWhitelistsReqBaseVersion
}

func (this *CheckModifyServiceApiAccessWhitelistsReq) GetCurrentVersion() uint32 {
	return CheckModifyServiceApiAccessWhitelistsReqCurrentVersion
}

func (this *CheckModifyServiceApiAccessWhitelistsReq) Init() {

	this.ZoneCount = 0

}

func (this *CheckModifyServiceApiAccessWhitelistsReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CheckModifyServiceApiAccessWhitelistsReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CheckModifyServiceApiAccessWhitelistsReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CheckModifyServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = CheckModifyServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check cut version
	if cutVer < CheckModifyServiceApiAccessWhitelistsReqBaseVersion {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq cut version must large than CheckModifyServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneCount)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.ZoneCount pack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should <= count 200")
	}
	if len(this.TotalZoneAccessWritelist) < int(this.ZoneCount) {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's length should > ZoneCount")
	}
	if this.ZoneCount > 0 {
		for i := 0; i < int(this.ZoneCount); i++ {
			err = this.TotalZoneAccessWritelist[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.UserName))+1)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.UserName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.UserName), 0))
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.UserName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *CheckModifyServiceApiAccessWhitelistsReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CheckModifyServiceApiAccessWhitelistsReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CheckModifyServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = CheckModifyServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check version
	if cutVer < CheckModifyServiceApiAccessWhitelistsReqBaseVersion {
		errors.New("CheckModifyServiceApiAccessWhitelistsReq cut version must large than CheckModifyServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneCount)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.ZoneCount unpack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist's refer ZoneCount should <= count 200")
	}

	if this.TotalZoneAccessWritelist == nil {
		this.TotalZoneAccessWritelist = make([]*ModifyWritelist, int(this.ZoneCount))
		for i := 0; i < int(this.ZoneCount); i++ {
			this.TotalZoneAccessWritelist[i] = NewModifyWritelist()
		}
	}

	for i := 0; i < int(this.ZoneCount); i++ {
		err = this.TotalZoneAccessWritelist[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("CheckModifyServiceApiAccessWhitelistsReq.TotalZoneAccessWritelist unpack error\n" + err.Error())
		}

	}

	var UserNameSize uint32
	err = binary.Read(r, binary.BigEndian, &UserNameSize)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.UserName string size unpack error\n" + err.Error())
	}

	UserNameBytes := make([]byte, UserNameSize)
	err = binary.Read(r, binary.BigEndian, UserNameBytes)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsReq.UserName string content unpack error\n" + err.Error())
	}
	this.UserName = string(UserNameBytes[:len(UserNameBytes)-1])

	return err
}

const (
	CheckModifyServiceApiAccessWhitelistsResBaseVersion    uint32 = 111
	CheckModifyServiceApiAccessWhitelistsResCurrentVersion uint32 = 111
)

// CheckModifyServiceApiAccessWhitelistsRes
type CheckModifyServiceApiAccessWhitelistsRes struct {
	Result int32 `tdr_field:"Result"`

	ErrMsg string `tdr_field:"ErrMsg"`
}

func NewCheckModifyServiceApiAccessWhitelistsRes() *CheckModifyServiceApiAccessWhitelistsRes {
	obj := new(CheckModifyServiceApiAccessWhitelistsRes)
	obj.Init()
	return obj
}

func (this *CheckModifyServiceApiAccessWhitelistsRes) GetBaseVersion() uint32 {
	return CheckModifyServiceApiAccessWhitelistsResBaseVersion
}

func (this *CheckModifyServiceApiAccessWhitelistsRes) GetCurrentVersion() uint32 {
	return CheckModifyServiceApiAccessWhitelistsResCurrentVersion
}

func (this *CheckModifyServiceApiAccessWhitelistsRes) Init() {

}

func (this *CheckModifyServiceApiAccessWhitelistsRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CheckModifyServiceApiAccessWhitelistsRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CheckModifyServiceApiAccessWhitelistsRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CheckModifyServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = CheckModifyServiceApiAccessWhitelistsResCurrentVersion
	}
	// check cut version
	if cutVer < CheckModifyServiceApiAccessWhitelistsResBaseVersion {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes cut version must large than CheckModifyServiceApiAccessWhitelistsResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.ErrMsg))+1)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes.ErrMsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.ErrMsg), 0))
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes.ErrMsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *CheckModifyServiceApiAccessWhitelistsRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CheckModifyServiceApiAccessWhitelistsRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CheckModifyServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = CheckModifyServiceApiAccessWhitelistsResCurrentVersion
	}
	// check version
	if cutVer < CheckModifyServiceApiAccessWhitelistsResBaseVersion {
		errors.New("CheckModifyServiceApiAccessWhitelistsRes cut version must large than CheckModifyServiceApiAccessWhitelistsResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes.Result unpack error\n" + err.Error())
	}

	var ErrMsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrMsgSize)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes.ErrMsg string size unpack error\n" + err.Error())
	}

	ErrMsgBytes := make([]byte, ErrMsgSize)
	err = binary.Read(r, binary.BigEndian, ErrMsgBytes)
	if err != nil {
		return errors.New("CheckModifyServiceApiAccessWhitelistsRes.ErrMsg string content unpack error\n" + err.Error())
	}
	this.ErrMsg = string(ErrMsgBytes[:len(ErrMsgBytes)-1])

	return err
}

const (
	CheckOnServiceApiAccessWhitelistsReqBaseVersion    uint32 = 111
	CheckOnServiceApiAccessWhitelistsReqCurrentVersion uint32 = 111
)

// CheckOnServiceApiAccessWhitelistsReq
type CheckOnServiceApiAccessWhitelistsReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneCount uint32 `tdr_field:"ZoneCount"`

	ZoneList []int32 `tdr_field:"ZoneList" tdr_count:"200" tdr_refer:"ZoneCount"`

	UserName string `tdr_field:"UserName"`
}

func NewCheckOnServiceApiAccessWhitelistsReq() *CheckOnServiceApiAccessWhitelistsReq {
	obj := new(CheckOnServiceApiAccessWhitelistsReq)
	obj.Init()
	return obj
}

func (this *CheckOnServiceApiAccessWhitelistsReq) GetBaseVersion() uint32 {
	return CheckOnServiceApiAccessWhitelistsReqBaseVersion
}

func (this *CheckOnServiceApiAccessWhitelistsReq) GetCurrentVersion() uint32 {
	return CheckOnServiceApiAccessWhitelistsReqCurrentVersion
}

func (this *CheckOnServiceApiAccessWhitelistsReq) Init() {

	this.ZoneCount = 0

}

func (this *CheckOnServiceApiAccessWhitelistsReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CheckOnServiceApiAccessWhitelistsReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CheckOnServiceApiAccessWhitelistsReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CheckOnServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = CheckOnServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check cut version
	if cutVer < CheckOnServiceApiAccessWhitelistsReqBaseVersion {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq cut version must large than CheckOnServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneCount)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneCount pack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList's refer ZoneCount should <= count 200")
	}
	if len(this.ZoneList) < int(this.ZoneCount) {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList's length should > ZoneCount")
	}
	if this.ZoneCount > 0 {
		referZoneList := this.ZoneList[:this.ZoneCount]
		err = binary.Write(w, binary.BigEndian, referZoneList)
		if err != nil {
			return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.UserName))+1)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.UserName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.UserName), 0))
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.UserName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *CheckOnServiceApiAccessWhitelistsReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CheckOnServiceApiAccessWhitelistsReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CheckOnServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = CheckOnServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check version
	if cutVer < CheckOnServiceApiAccessWhitelistsReqBaseVersion {
		errors.New("CheckOnServiceApiAccessWhitelistsReq cut version must large than CheckOnServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneCount)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneCount unpack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList's refer ZoneCount should <= count 200")
	}

	if this.ZoneList == nil {
		this.ZoneList = make([]int32, int(this.ZoneCount))
	}

	referZoneList := this.ZoneList[:this.ZoneCount]
	err = binary.Read(r, binary.BigEndian, referZoneList)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.ZoneList pack error\n" + err.Error())
	}

	var UserNameSize uint32
	err = binary.Read(r, binary.BigEndian, &UserNameSize)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.UserName string size unpack error\n" + err.Error())
	}

	UserNameBytes := make([]byte, UserNameSize)
	err = binary.Read(r, binary.BigEndian, UserNameBytes)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsReq.UserName string content unpack error\n" + err.Error())
	}
	this.UserName = string(UserNameBytes[:len(UserNameBytes)-1])

	return err
}

const (
	CheckOnServiceApiAccessWhitelistsResBaseVersion    uint32 = 111
	CheckOnServiceApiAccessWhitelistsResCurrentVersion uint32 = 111
)

// CheckOnServiceApiAccessWhitelistsRes
type CheckOnServiceApiAccessWhitelistsRes struct {
	Result int32 `tdr_field:"Result"`

	ErrMsg string `tdr_field:"ErrMsg"`
}

func NewCheckOnServiceApiAccessWhitelistsRes() *CheckOnServiceApiAccessWhitelistsRes {
	obj := new(CheckOnServiceApiAccessWhitelistsRes)
	obj.Init()
	return obj
}

func (this *CheckOnServiceApiAccessWhitelistsRes) GetBaseVersion() uint32 {
	return CheckOnServiceApiAccessWhitelistsResBaseVersion
}

func (this *CheckOnServiceApiAccessWhitelistsRes) GetCurrentVersion() uint32 {
	return CheckOnServiceApiAccessWhitelistsResCurrentVersion
}

func (this *CheckOnServiceApiAccessWhitelistsRes) Init() {

}

func (this *CheckOnServiceApiAccessWhitelistsRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CheckOnServiceApiAccessWhitelistsRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CheckOnServiceApiAccessWhitelistsRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CheckOnServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = CheckOnServiceApiAccessWhitelistsResCurrentVersion
	}
	// check cut version
	if cutVer < CheckOnServiceApiAccessWhitelistsResBaseVersion {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes cut version must large than CheckOnServiceApiAccessWhitelistsResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.ErrMsg))+1)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes.ErrMsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.ErrMsg), 0))
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes.ErrMsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *CheckOnServiceApiAccessWhitelistsRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CheckOnServiceApiAccessWhitelistsRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CheckOnServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = CheckOnServiceApiAccessWhitelistsResCurrentVersion
	}
	// check version
	if cutVer < CheckOnServiceApiAccessWhitelistsResBaseVersion {
		errors.New("CheckOnServiceApiAccessWhitelistsRes cut version must large than CheckOnServiceApiAccessWhitelistsResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes.Result unpack error\n" + err.Error())
	}

	var ErrMsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrMsgSize)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes.ErrMsg string size unpack error\n" + err.Error())
	}

	ErrMsgBytes := make([]byte, ErrMsgSize)
	err = binary.Read(r, binary.BigEndian, ErrMsgBytes)
	if err != nil {
		return errors.New("CheckOnServiceApiAccessWhitelistsRes.ErrMsg string content unpack error\n" + err.Error())
	}
	this.ErrMsg = string(ErrMsgBytes[:len(ErrMsgBytes)-1])

	return err
}

const (
	OperateWritelistBaseVersion    uint32 = 111
	OperateWritelistCurrentVersion uint32 = 111
)

// OperateWritelist
type OperateWritelist struct {
	ZoneID int32 `tdr_field:"ZoneID"`

	OperateCmd int32 `tdr_field:"OperateCmd"`
}

func NewOperateWritelist() *OperateWritelist {
	obj := new(OperateWritelist)
	obj.Init()
	return obj
}

func (this *OperateWritelist) GetBaseVersion() uint32 {
	return OperateWritelistBaseVersion
}

func (this *OperateWritelist) GetCurrentVersion() uint32 {
	return OperateWritelistCurrentVersion
}

func (this *OperateWritelist) Init() {

}

func (this *OperateWritelist) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("OperateWritelist Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *OperateWritelist) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > OperateWritelistCurrentVersion {
		cutVer = OperateWritelistCurrentVersion
	}
	// check cut version
	if cutVer < OperateWritelistBaseVersion {
		return errors.New("OperateWritelist cut version must large than OperateWritelistBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("OperateWritelist.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.OperateCmd)
	if err != nil {
		return errors.New("OperateWritelist.OperateCmd pack error\n" + err.Error())
	}

	return nil
}

func (this *OperateWritelist) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("OperateWritelist data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *OperateWritelist) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > OperateWritelistCurrentVersion {
		cutVer = OperateWritelistCurrentVersion
	}
	// check version
	if cutVer < OperateWritelistBaseVersion {
		errors.New("OperateWritelist cut version must large than OperateWritelistBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("OperateWritelist.ZoneID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.OperateCmd)
	if err != nil {
		return errors.New("OperateWritelist.OperateCmd unpack error\n" + err.Error())
	}

	return err
}

const (
	OnOffServiceApiAccessWhitelistsReqBaseVersion    uint32 = 111
	OnOffServiceApiAccessWhitelistsReqCurrentVersion uint32 = 111
)

// OnOffServiceApiAccessWhitelistsReq
type OnOffServiceApiAccessWhitelistsReq struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneCount uint32 `tdr_field:"ZoneCount"`

	TotalOperateWritelist []*OperateWritelist `tdr_field:"TotalOperateWritelist" tdr_count:"200" tdr_refer:"ZoneCount"`

	UserName string `tdr_field:"UserName"`
}

func NewOnOffServiceApiAccessWhitelistsReq() *OnOffServiceApiAccessWhitelistsReq {
	obj := new(OnOffServiceApiAccessWhitelistsReq)
	obj.Init()
	return obj
}

func (this *OnOffServiceApiAccessWhitelistsReq) GetBaseVersion() uint32 {
	return OnOffServiceApiAccessWhitelistsReqBaseVersion
}

func (this *OnOffServiceApiAccessWhitelistsReq) GetCurrentVersion() uint32 {
	return OnOffServiceApiAccessWhitelistsReqCurrentVersion
}

func (this *OnOffServiceApiAccessWhitelistsReq) Init() {

	this.ZoneCount = 0

}

func (this *OnOffServiceApiAccessWhitelistsReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("OnOffServiceApiAccessWhitelistsReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *OnOffServiceApiAccessWhitelistsReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > OnOffServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = OnOffServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check cut version
	if cutVer < OnOffServiceApiAccessWhitelistsReqBaseVersion {
		return errors.New("OnOffServiceApiAccessWhitelistsReq cut version must large than OnOffServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneCount)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.ZoneCount pack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist's refer ZoneCount should <= count 200")
	}
	if len(this.TotalOperateWritelist) < int(this.ZoneCount) {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist's length should > ZoneCount")
	}
	if this.ZoneCount > 0 {
		for i := 0; i < int(this.ZoneCount); i++ {
			err = this.TotalOperateWritelist[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.UserName))+1)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.UserName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.UserName), 0))
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.UserName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *OnOffServiceApiAccessWhitelistsReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("OnOffServiceApiAccessWhitelistsReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *OnOffServiceApiAccessWhitelistsReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > OnOffServiceApiAccessWhitelistsReqCurrentVersion {
		cutVer = OnOffServiceApiAccessWhitelistsReqCurrentVersion
	}
	// check version
	if cutVer < OnOffServiceApiAccessWhitelistsReqBaseVersion {
		errors.New("OnOffServiceApiAccessWhitelistsReq cut version must large than OnOffServiceApiAccessWhitelistsReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneCount)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.ZoneCount unpack error\n" + err.Error())
	}

	if this.ZoneCount < 0 {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist's refer ZoneCount should >= 0")
	}
	if this.ZoneCount > 200 {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist's refer ZoneCount should <= count 200")
	}

	if this.TotalOperateWritelist == nil {
		this.TotalOperateWritelist = make([]*OperateWritelist, int(this.ZoneCount))
		for i := 0; i < int(this.ZoneCount); i++ {
			this.TotalOperateWritelist[i] = NewOperateWritelist()
		}
	}

	for i := 0; i < int(this.ZoneCount); i++ {
		err = this.TotalOperateWritelist[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("OnOffServiceApiAccessWhitelistsReq.TotalOperateWritelist unpack error\n" + err.Error())
		}

	}

	var UserNameSize uint32
	err = binary.Read(r, binary.BigEndian, &UserNameSize)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.UserName string size unpack error\n" + err.Error())
	}

	UserNameBytes := make([]byte, UserNameSize)
	err = binary.Read(r, binary.BigEndian, UserNameBytes)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsReq.UserName string content unpack error\n" + err.Error())
	}
	this.UserName = string(UserNameBytes[:len(UserNameBytes)-1])

	return err
}

const (
	OnOffServiceApiAccessWhitelistsResBaseVersion    uint32 = 111
	OnOffServiceApiAccessWhitelistsResCurrentVersion uint32 = 111
)

// OnOffServiceApiAccessWhitelistsRes
type OnOffServiceApiAccessWhitelistsRes struct {
	Result int32 `tdr_field:"Result"`

	ErrMsg string `tdr_field:"ErrMsg"`
}

func NewOnOffServiceApiAccessWhitelistsRes() *OnOffServiceApiAccessWhitelistsRes {
	obj := new(OnOffServiceApiAccessWhitelistsRes)
	obj.Init()
	return obj
}

func (this *OnOffServiceApiAccessWhitelistsRes) GetBaseVersion() uint32 {
	return OnOffServiceApiAccessWhitelistsResBaseVersion
}

func (this *OnOffServiceApiAccessWhitelistsRes) GetCurrentVersion() uint32 {
	return OnOffServiceApiAccessWhitelistsResCurrentVersion
}

func (this *OnOffServiceApiAccessWhitelistsRes) Init() {

}

func (this *OnOffServiceApiAccessWhitelistsRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("OnOffServiceApiAccessWhitelistsRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *OnOffServiceApiAccessWhitelistsRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > OnOffServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = OnOffServiceApiAccessWhitelistsResCurrentVersion
	}
	// check cut version
	if cutVer < OnOffServiceApiAccessWhitelistsResBaseVersion {
		return errors.New("OnOffServiceApiAccessWhitelistsRes cut version must large than OnOffServiceApiAccessWhitelistsResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.ErrMsg))+1)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsRes.ErrMsg string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.ErrMsg), 0))
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsRes.ErrMsg string content pack error\n" + err.Error())
	}

	return nil
}

func (this *OnOffServiceApiAccessWhitelistsRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("OnOffServiceApiAccessWhitelistsRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *OnOffServiceApiAccessWhitelistsRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > OnOffServiceApiAccessWhitelistsResCurrentVersion {
		cutVer = OnOffServiceApiAccessWhitelistsResCurrentVersion
	}
	// check version
	if cutVer < OnOffServiceApiAccessWhitelistsResBaseVersion {
		errors.New("OnOffServiceApiAccessWhitelistsRes cut version must large than OnOffServiceApiAccessWhitelistsResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsRes.Result unpack error\n" + err.Error())
	}

	var ErrMsgSize uint32
	err = binary.Read(r, binary.BigEndian, &ErrMsgSize)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsRes.ErrMsg string size unpack error\n" + err.Error())
	}

	ErrMsgBytes := make([]byte, ErrMsgSize)
	err = binary.Read(r, binary.BigEndian, ErrMsgBytes)
	if err != nil {
		return errors.New("OnOffServiceApiAccessWhitelistsRes.ErrMsg string content unpack error\n" + err.Error())
	}
	this.ErrMsg = string(ErrMsgBytes[:len(ErrMsgBytes)-1])

	return err
}

const (
	TcapdbIndexFieldInfoBaseVersion    uint32 = 117
	TcapdbIndexFieldInfoCurrentVersion uint32 = 117
)

// TcapdbIndexFieldInfo
type TcapdbIndexFieldInfo struct {
	FieldName string `tdr_field:"FieldName"`

	FieldType int32 `tdr_field:"FieldType"`
}

func NewTcapdbIndexFieldInfo() *TcapdbIndexFieldInfo {
	obj := new(TcapdbIndexFieldInfo)
	obj.Init()
	return obj
}

func (this *TcapdbIndexFieldInfo) GetBaseVersion() uint32 {
	return TcapdbIndexFieldInfoBaseVersion
}

func (this *TcapdbIndexFieldInfo) GetCurrentVersion() uint32 {
	return TcapdbIndexFieldInfoCurrentVersion
}

func (this *TcapdbIndexFieldInfo) Init() {

}

func (this *TcapdbIndexFieldInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TcapdbIndexFieldInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapdbIndexFieldInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapdbIndexFieldInfoCurrentVersion {
		cutVer = TcapdbIndexFieldInfoCurrentVersion
	}
	// check cut version
	if cutVer < TcapdbIndexFieldInfoBaseVersion {
		return errors.New("TcapdbIndexFieldInfo cut version must large than TcapdbIndexFieldInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName))+1)
	if err != nil {
		return errors.New("TcapdbIndexFieldInfo.FieldName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName), 0))
	if err != nil {
		return errors.New("TcapdbIndexFieldInfo.FieldName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldType)
	if err != nil {
		return errors.New("TcapdbIndexFieldInfo.FieldType pack error\n" + err.Error())
	}

	return nil
}

func (this *TcapdbIndexFieldInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TcapdbIndexFieldInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TcapdbIndexFieldInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapdbIndexFieldInfoCurrentVersion {
		cutVer = TcapdbIndexFieldInfoCurrentVersion
	}
	// check version
	if cutVer < TcapdbIndexFieldInfoBaseVersion {
		errors.New("TcapdbIndexFieldInfo cut version must large than TcapdbIndexFieldInfoBaseVersion\n")
	}

	var FieldNameSize uint32
	err = binary.Read(r, binary.BigEndian, &FieldNameSize)
	if err != nil {
		return errors.New("TcapdbIndexFieldInfo.FieldName string size unpack error\n" + err.Error())
	}

	FieldNameBytes := make([]byte, FieldNameSize)
	err = binary.Read(r, binary.BigEndian, FieldNameBytes)
	if err != nil {
		return errors.New("TcapdbIndexFieldInfo.FieldName string content unpack error\n" + err.Error())
	}
	this.FieldName = string(FieldNameBytes[:len(FieldNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.FieldType)
	if err != nil {
		return errors.New("TcapdbIndexFieldInfo.FieldType unpack error\n" + err.Error())
	}

	return err
}

const (
	TcapdbIndexFieldsBaseVersion    uint32 = 117
	TcapdbIndexFieldsCurrentVersion uint32 = 117
)

// TcapdbIndexFields
type TcapdbIndexFields struct {
	FieldNum uint32 `tdr_field:"FieldNum"`

	Fields []*TcapdbIndexFieldInfo `tdr_field:"Fields" tdr_count:"256" tdr_refer:"FieldNum"`
}

func NewTcapdbIndexFields() *TcapdbIndexFields {
	obj := new(TcapdbIndexFields)
	obj.Init()
	return obj
}

func (this *TcapdbIndexFields) GetBaseVersion() uint32 {
	return TcapdbIndexFieldsBaseVersion
}

func (this *TcapdbIndexFields) GetCurrentVersion() uint32 {
	return TcapdbIndexFieldsCurrentVersion
}

func (this *TcapdbIndexFields) Init() {

}

func (this *TcapdbIndexFields) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TcapdbIndexFields Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapdbIndexFields) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapdbIndexFieldsCurrentVersion {
		cutVer = TcapdbIndexFieldsCurrentVersion
	}
	// check cut version
	if cutVer < TcapdbIndexFieldsBaseVersion {
		return errors.New("TcapdbIndexFields cut version must large than TcapdbIndexFieldsBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.FieldNum)
	if err != nil {
		return errors.New("TcapdbIndexFields.FieldNum pack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TcapdbIndexFields.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 256 {
		return errors.New("TcapdbIndexFields.Fields's refer FieldNum should <= count 256")
	}
	if len(this.Fields) < int(this.FieldNum) {
		return errors.New("TcapdbIndexFields.Fields's length should > FieldNum")
	}
	if this.FieldNum > 0 {
		for i := 0; i < int(this.FieldNum); i++ {
			err = this.Fields[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TcapdbIndexFields.Fields pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TcapdbIndexFields) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TcapdbIndexFields data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TcapdbIndexFields) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapdbIndexFieldsCurrentVersion {
		cutVer = TcapdbIndexFieldsCurrentVersion
	}
	// check version
	if cutVer < TcapdbIndexFieldsBaseVersion {
		errors.New("TcapdbIndexFields cut version must large than TcapdbIndexFieldsBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum)
	if err != nil {
		return errors.New("TcapdbIndexFields.FieldNum unpack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TcapdbIndexFields.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 256 {
		return errors.New("TcapdbIndexFields.Fields's refer FieldNum should <= count 256")
	}

	if this.Fields == nil {
		this.Fields = make([]*TcapdbIndexFieldInfo, int(this.FieldNum))
		for i := 0; i < int(this.FieldNum); i++ {
			this.Fields[i] = NewTcapdbIndexFieldInfo()
		}
	}

	for i := 0; i < int(this.FieldNum); i++ {
		err = this.Fields[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TcapdbIndexFields.Fields unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	TcapdbIndexInfoBaseVersion    uint32 = 117
	TcapdbIndexInfoCurrentVersion uint32 = 117
)

// TcapdbIndexInfo
type TcapdbIndexInfo struct {
	ReplicationNum uint32 `tdr_field:"ReplicationNum"`

	ShardNum uint32 `tdr_field:"ShardNum"`

	IndexFields *TcapdbIndexFields `tdr_field:"IndexFields"`
}

func NewTcapdbIndexInfo() *TcapdbIndexInfo {
	obj := new(TcapdbIndexInfo)
	obj.Init()
	return obj
}

func (this *TcapdbIndexInfo) GetBaseVersion() uint32 {
	return TcapdbIndexInfoBaseVersion
}

func (this *TcapdbIndexInfo) GetCurrentVersion() uint32 {
	return TcapdbIndexInfoCurrentVersion
}

func (this *TcapdbIndexInfo) Init() {
	this.ReplicationNum = 1

	this.ShardNum = 0

	this.IndexFields = NewTcapdbIndexFields()

}

func (this *TcapdbIndexInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TcapdbIndexInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapdbIndexInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapdbIndexInfoCurrentVersion {
		cutVer = TcapdbIndexInfoCurrentVersion
	}
	// check cut version
	if cutVer < TcapdbIndexInfoBaseVersion {
		return errors.New("TcapdbIndexInfo cut version must large than TcapdbIndexInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ReplicationNum)
	if err != nil {
		return errors.New("TcapdbIndexInfo.ReplicationNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ShardNum)
	if err != nil {
		return errors.New("TcapdbIndexInfo.ShardNum pack error\n" + err.Error())
	}

	err = this.IndexFields.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TcapdbIndexInfo.IndexFields pack error\n" + err.Error())
	}

	return nil
}

func (this *TcapdbIndexInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TcapdbIndexInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TcapdbIndexInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapdbIndexInfoCurrentVersion {
		cutVer = TcapdbIndexInfoCurrentVersion
	}
	// check version
	if cutVer < TcapdbIndexInfoBaseVersion {
		errors.New("TcapdbIndexInfo cut version must large than TcapdbIndexInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ReplicationNum)
	if err != nil {
		return errors.New("TcapdbIndexInfo.ReplicationNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ShardNum)
	if err != nil {
		return errors.New("TcapdbIndexInfo.ShardNum unpack error\n" + err.Error())
	}

	err = this.IndexFields.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TcapdbIndexInfo.IndexFields unpack error\n" + err.Error())
	}

	return err
}

const (
	TcapdbIndexServerInfoBaseVersion    uint32 = 117
	TcapdbIndexServerInfoCurrentVersion uint32 = 117
)

// TcapdbIndexServerInfo
type TcapdbIndexServerInfo struct {
	AddressNum uint32 `tdr_field:"AddressNum"`

	AddressList []string `tdr_field:"AddressList" tdr_count:"100" tdr_refer:"AddressNum"`

	Account string `tdr_field:"Account"`

	Password string `tdr_field:"Password"`
}

func NewTcapdbIndexServerInfo() *TcapdbIndexServerInfo {
	obj := new(TcapdbIndexServerInfo)
	obj.Init()
	return obj
}

func (this *TcapdbIndexServerInfo) GetBaseVersion() uint32 {
	return TcapdbIndexServerInfoBaseVersion
}

func (this *TcapdbIndexServerInfo) GetCurrentVersion() uint32 {
	return TcapdbIndexServerInfoCurrentVersion
}

func (this *TcapdbIndexServerInfo) Init() {
	this.AddressNum = 0

}

func (this *TcapdbIndexServerInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TcapdbIndexServerInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TcapdbIndexServerInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TcapdbIndexServerInfoCurrentVersion {
		cutVer = TcapdbIndexServerInfoCurrentVersion
	}
	// check cut version
	if cutVer < TcapdbIndexServerInfoBaseVersion {
		return errors.New("TcapdbIndexServerInfo cut version must large than TcapdbIndexServerInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AddressNum)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.AddressNum pack error\n" + err.Error())
	}

	if this.AddressNum < 0 {
		return errors.New("TcapdbIndexServerInfo.AddressList's refer AddressNum should >= 0")
	}
	if this.AddressNum > 100 {
		return errors.New("TcapdbIndexServerInfo.AddressList's refer AddressNum should <= count 100")
	}
	if len(this.AddressList) < int(this.AddressNum) {
		return errors.New("TcapdbIndexServerInfo.AddressList's length should > AddressNum")
	}
	if this.AddressNum > 0 {
		for i := 0; i < int(this.AddressNum); i++ {
			err = binary.Write(w, binary.BigEndian, uint32(len(this.AddressList[i]))+1)
			if err != nil {
				return errors.New("TcapdbIndexServerInfo.AddressList string size pack error\n" + err.Error())
			}
			err = binary.Write(w, binary.BigEndian, append([]byte(this.AddressList[i]), 0))
			if err != nil {
				return errors.New("TcapdbIndexServerInfo.AddressList string content pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Account))+1)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Account string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Account), 0))
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Account string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Password))+1)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Password string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Password), 0))
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Password string content pack error\n" + err.Error())
	}

	return nil
}

func (this *TcapdbIndexServerInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TcapdbIndexServerInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TcapdbIndexServerInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TcapdbIndexServerInfoCurrentVersion {
		cutVer = TcapdbIndexServerInfoCurrentVersion
	}
	// check version
	if cutVer < TcapdbIndexServerInfoBaseVersion {
		errors.New("TcapdbIndexServerInfo cut version must large than TcapdbIndexServerInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AddressNum)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.AddressNum unpack error\n" + err.Error())
	}

	if this.AddressNum < 0 {
		return errors.New("TcapdbIndexServerInfo.AddressList's refer AddressNum should >= 0")
	}
	if this.AddressNum > 100 {
		return errors.New("TcapdbIndexServerInfo.AddressList's refer AddressNum should <= count 100")
	}

	if this.AddressList == nil {
		this.AddressList = make([]string, int(this.AddressNum))
	}

	for i := 0; i < int(this.AddressNum); i++ {
		var AddressListSize uint32
		err = binary.Read(r, binary.BigEndian, &AddressListSize)
		if err != nil {
			return errors.New("TcapdbIndexServerInfo.AddressList string size unpack error\n" + err.Error())
		}

		AddressListBytes := make([]byte, AddressListSize)
		err = binary.Read(r, binary.BigEndian, AddressListBytes)
		if err != nil {
			return errors.New("TcapdbIndexServerInfo.AddressList string content unpack error\n" + err.Error())
		}
		this.AddressList[i] = string(AddressListBytes[:len(AddressListBytes)-1])

	}

	var AccountSize uint32
	err = binary.Read(r, binary.BigEndian, &AccountSize)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Account string size unpack error\n" + err.Error())
	}

	AccountBytes := make([]byte, AccountSize)
	err = binary.Read(r, binary.BigEndian, AccountBytes)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Account string content unpack error\n" + err.Error())
	}
	this.Account = string(AccountBytes[:len(AccountBytes)-1])

	var PasswordSize uint32
	err = binary.Read(r, binary.BigEndian, &PasswordSize)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Password string size unpack error\n" + err.Error())
	}

	PasswordBytes := make([]byte, PasswordSize)
	err = binary.Read(r, binary.BigEndian, PasswordBytes)
	if err != nil {
		return errors.New("TcapdbIndexServerInfo.Password string content unpack error\n" + err.Error())
	}
	this.Password = string(PasswordBytes[:len(PasswordBytes)-1])

	return err
}

const (
	CreateIndexReqInfoBaseVersion    uint32 = 117
	CreateIndexReqInfoCurrentVersion uint32 = 117
)

// CreateIndexReqInfo
type CreateIndexReqInfo struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`

	TableType int32 `tdr_field:"TableType"`

	IndexInfo *TcapdbIndexInfo `tdr_field:"IndexInfo"`

	IndexServerInfo *TcapdbIndexServerInfo `tdr_field:"IndexServerInfo"`
}

func NewCreateIndexReqInfo() *CreateIndexReqInfo {
	obj := new(CreateIndexReqInfo)
	obj.Init()
	return obj
}

func (this *CreateIndexReqInfo) GetBaseVersion() uint32 {
	return CreateIndexReqInfoBaseVersion
}

func (this *CreateIndexReqInfo) GetCurrentVersion() uint32 {
	return CreateIndexReqInfoCurrentVersion
}

func (this *CreateIndexReqInfo) Init() {

	this.TableType = 0

	this.IndexInfo = NewTcapdbIndexInfo()

	this.IndexServerInfo = NewTcapdbIndexServerInfo()

}

func (this *CreateIndexReqInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CreateIndexReqInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CreateIndexReqInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CreateIndexReqInfoCurrentVersion {
		cutVer = CreateIndexReqInfoCurrentVersion
	}
	// check cut version
	if cutVer < CreateIndexReqInfoBaseVersion {
		return errors.New("CreateIndexReqInfo cut version must large than CreateIndexReqInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("CreateIndexReqInfo.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("CreateIndexReqInfo.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("CreateIndexReqInfo.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("CreateIndexReqInfo.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TableType)
	if err != nil {
		return errors.New("CreateIndexReqInfo.TableType pack error\n" + err.Error())
	}

	err = this.IndexInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("CreateIndexReqInfo.IndexInfo pack error\n" + err.Error())
	}

	err = this.IndexServerInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("CreateIndexReqInfo.IndexServerInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *CreateIndexReqInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CreateIndexReqInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CreateIndexReqInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CreateIndexReqInfoCurrentVersion {
		cutVer = CreateIndexReqInfoCurrentVersion
	}
	// check version
	if cutVer < CreateIndexReqInfoBaseVersion {
		errors.New("CreateIndexReqInfo cut version must large than CreateIndexReqInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("CreateIndexReqInfo.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("CreateIndexReqInfo.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("CreateIndexReqInfo.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("CreateIndexReqInfo.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.TableType)
	if err != nil {
		return errors.New("CreateIndexReqInfo.TableType unpack error\n" + err.Error())
	}

	err = this.IndexInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("CreateIndexReqInfo.IndexInfo unpack error\n" + err.Error())
	}

	err = this.IndexServerInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("CreateIndexReqInfo.IndexServerInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	CreateIndexResInfoBaseVersion    uint32 = 117
	CreateIndexResInfoCurrentVersion uint32 = 117
)

// CreateIndexResInfo
type CreateIndexResInfo struct {
	Result int32 `tdr_field:"Result"`

	OldIndexName string `tdr_field:"OldIndexName"`

	NewIndexName string `tdr_field:"NewIndexName"`
}

func NewCreateIndexResInfo() *CreateIndexResInfo {
	obj := new(CreateIndexResInfo)
	obj.Init()
	return obj
}

func (this *CreateIndexResInfo) GetBaseVersion() uint32 {
	return CreateIndexResInfoBaseVersion
}

func (this *CreateIndexResInfo) GetCurrentVersion() uint32 {
	return CreateIndexResInfoCurrentVersion
}

func (this *CreateIndexResInfo) Init() {

}

func (this *CreateIndexResInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CreateIndexResInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CreateIndexResInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CreateIndexResInfoCurrentVersion {
		cutVer = CreateIndexResInfoCurrentVersion
	}
	// check cut version
	if cutVer < CreateIndexResInfoBaseVersion {
		return errors.New("CreateIndexResInfo cut version must large than CreateIndexResInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("CreateIndexResInfo.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.OldIndexName))+1)
	if err != nil {
		return errors.New("CreateIndexResInfo.OldIndexName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.OldIndexName), 0))
	if err != nil {
		return errors.New("CreateIndexResInfo.OldIndexName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.NewIndexName))+1)
	if err != nil {
		return errors.New("CreateIndexResInfo.NewIndexName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.NewIndexName), 0))
	if err != nil {
		return errors.New("CreateIndexResInfo.NewIndexName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *CreateIndexResInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CreateIndexResInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CreateIndexResInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CreateIndexResInfoCurrentVersion {
		cutVer = CreateIndexResInfoCurrentVersion
	}
	// check version
	if cutVer < CreateIndexResInfoBaseVersion {
		errors.New("CreateIndexResInfo cut version must large than CreateIndexResInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("CreateIndexResInfo.Result unpack error\n" + err.Error())
	}

	var OldIndexNameSize uint32
	err = binary.Read(r, binary.BigEndian, &OldIndexNameSize)
	if err != nil {
		return errors.New("CreateIndexResInfo.OldIndexName string size unpack error\n" + err.Error())
	}

	OldIndexNameBytes := make([]byte, OldIndexNameSize)
	err = binary.Read(r, binary.BigEndian, OldIndexNameBytes)
	if err != nil {
		return errors.New("CreateIndexResInfo.OldIndexName string content unpack error\n" + err.Error())
	}
	this.OldIndexName = string(OldIndexNameBytes[:len(OldIndexNameBytes)-1])

	var NewIndexNameSize uint32
	err = binary.Read(r, binary.BigEndian, &NewIndexNameSize)
	if err != nil {
		return errors.New("CreateIndexResInfo.NewIndexName string size unpack error\n" + err.Error())
	}

	NewIndexNameBytes := make([]byte, NewIndexNameSize)
	err = binary.Read(r, binary.BigEndian, NewIndexNameBytes)
	if err != nil {
		return errors.New("CreateIndexResInfo.NewIndexName string content unpack error\n" + err.Error())
	}
	this.NewIndexName = string(NewIndexNameBytes[:len(NewIndexNameBytes)-1])

	return err
}

const (
	CreateIndexAliasReqInfoBaseVersion    uint32 = 117
	CreateIndexAliasReqInfoCurrentVersion uint32 = 117
)

// CreateIndexAliasReqInfo
type CreateIndexAliasReqInfo struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	TableName string `tdr_field:"TableName"`

	OldIndexName string `tdr_field:"OldIndexName"`

	NewIndexName string `tdr_field:"NewIndexName"`
}

func NewCreateIndexAliasReqInfo() *CreateIndexAliasReqInfo {
	obj := new(CreateIndexAliasReqInfo)
	obj.Init()
	return obj
}

func (this *CreateIndexAliasReqInfo) GetBaseVersion() uint32 {
	return CreateIndexAliasReqInfoBaseVersion
}

func (this *CreateIndexAliasReqInfo) GetCurrentVersion() uint32 {
	return CreateIndexAliasReqInfoCurrentVersion
}

func (this *CreateIndexAliasReqInfo) Init() {

}

func (this *CreateIndexAliasReqInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CreateIndexAliasReqInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CreateIndexAliasReqInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CreateIndexAliasReqInfoCurrentVersion {
		cutVer = CreateIndexAliasReqInfoCurrentVersion
	}
	// check cut version
	if cutVer < CreateIndexAliasReqInfoBaseVersion {
		return errors.New("CreateIndexAliasReqInfo cut version must large than CreateIndexAliasReqInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AppID)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.AppID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ZoneID)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.ZoneID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.TableName))+1)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.TableName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.TableName), 0))
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.TableName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.OldIndexName))+1)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.OldIndexName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.OldIndexName), 0))
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.OldIndexName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.NewIndexName))+1)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.NewIndexName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.NewIndexName), 0))
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.NewIndexName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *CreateIndexAliasReqInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CreateIndexAliasReqInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CreateIndexAliasReqInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CreateIndexAliasReqInfoCurrentVersion {
		cutVer = CreateIndexAliasReqInfoCurrentVersion
	}
	// check version
	if cutVer < CreateIndexAliasReqInfoBaseVersion {
		errors.New("CreateIndexAliasReqInfo cut version must large than CreateIndexAliasReqInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AppID)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.AppID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ZoneID)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.ZoneID unpack error\n" + err.Error())
	}

	var TableNameSize uint32
	err = binary.Read(r, binary.BigEndian, &TableNameSize)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.TableName string size unpack error\n" + err.Error())
	}

	TableNameBytes := make([]byte, TableNameSize)
	err = binary.Read(r, binary.BigEndian, TableNameBytes)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.TableName string content unpack error\n" + err.Error())
	}
	this.TableName = string(TableNameBytes[:len(TableNameBytes)-1])

	var OldIndexNameSize uint32
	err = binary.Read(r, binary.BigEndian, &OldIndexNameSize)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.OldIndexName string size unpack error\n" + err.Error())
	}

	OldIndexNameBytes := make([]byte, OldIndexNameSize)
	err = binary.Read(r, binary.BigEndian, OldIndexNameBytes)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.OldIndexName string content unpack error\n" + err.Error())
	}
	this.OldIndexName = string(OldIndexNameBytes[:len(OldIndexNameBytes)-1])

	var NewIndexNameSize uint32
	err = binary.Read(r, binary.BigEndian, &NewIndexNameSize)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.NewIndexName string size unpack error\n" + err.Error())
	}

	NewIndexNameBytes := make([]byte, NewIndexNameSize)
	err = binary.Read(r, binary.BigEndian, NewIndexNameBytes)
	if err != nil {
		return errors.New("CreateIndexAliasReqInfo.NewIndexName string content unpack error\n" + err.Error())
	}
	this.NewIndexName = string(NewIndexNameBytes[:len(NewIndexNameBytes)-1])

	return err
}

const (
	CreateIndexAliasResInfoBaseVersion    uint32 = 117
	CreateIndexAliasResInfoCurrentVersion uint32 = 117
)

// CreateIndexAliasResInfo
type CreateIndexAliasResInfo struct {
	Result int32 `tdr_field:"Result"`
}

func NewCreateIndexAliasResInfo() *CreateIndexAliasResInfo {
	obj := new(CreateIndexAliasResInfo)
	obj.Init()
	return obj
}

func (this *CreateIndexAliasResInfo) GetBaseVersion() uint32 {
	return CreateIndexAliasResInfoBaseVersion
}

func (this *CreateIndexAliasResInfo) GetCurrentVersion() uint32 {
	return CreateIndexAliasResInfoCurrentVersion
}

func (this *CreateIndexAliasResInfo) Init() {

}

func (this *CreateIndexAliasResInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CreateIndexAliasResInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CreateIndexAliasResInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CreateIndexAliasResInfoCurrentVersion {
		cutVer = CreateIndexAliasResInfoCurrentVersion
	}
	// check cut version
	if cutVer < CreateIndexAliasResInfoBaseVersion {
		return errors.New("CreateIndexAliasResInfo cut version must large than CreateIndexAliasResInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("CreateIndexAliasResInfo.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *CreateIndexAliasResInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CreateIndexAliasResInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CreateIndexAliasResInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CreateIndexAliasResInfoCurrentVersion {
		cutVer = CreateIndexAliasResInfoCurrentVersion
	}
	// check version
	if cutVer < CreateIndexAliasResInfoBaseVersion {
		errors.New("CreateIndexAliasResInfo cut version must large than CreateIndexAliasResInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("CreateIndexAliasResInfo.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	DeleteIndexReqInfoBaseVersion    uint32 = 117
	DeleteIndexReqInfoCurrentVersion uint32 = 117
)

// DeleteIndexReqInfo
type DeleteIndexReqInfo struct {
	IndexName string `tdr_field:"IndexName"`
}

func NewDeleteIndexReqInfo() *DeleteIndexReqInfo {
	obj := new(DeleteIndexReqInfo)
	obj.Init()
	return obj
}

func (this *DeleteIndexReqInfo) GetBaseVersion() uint32 {
	return DeleteIndexReqInfoBaseVersion
}

func (this *DeleteIndexReqInfo) GetCurrentVersion() uint32 {
	return DeleteIndexReqInfoCurrentVersion
}

func (this *DeleteIndexReqInfo) Init() {

}

func (this *DeleteIndexReqInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DeleteIndexReqInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DeleteIndexReqInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DeleteIndexReqInfoCurrentVersion {
		cutVer = DeleteIndexReqInfoCurrentVersion
	}
	// check cut version
	if cutVer < DeleteIndexReqInfoBaseVersion {
		return errors.New("DeleteIndexReqInfo cut version must large than DeleteIndexReqInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.IndexName))+1)
	if err != nil {
		return errors.New("DeleteIndexReqInfo.IndexName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.IndexName), 0))
	if err != nil {
		return errors.New("DeleteIndexReqInfo.IndexName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *DeleteIndexReqInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DeleteIndexReqInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DeleteIndexReqInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DeleteIndexReqInfoCurrentVersion {
		cutVer = DeleteIndexReqInfoCurrentVersion
	}
	// check version
	if cutVer < DeleteIndexReqInfoBaseVersion {
		errors.New("DeleteIndexReqInfo cut version must large than DeleteIndexReqInfoBaseVersion\n")
	}

	var IndexNameSize uint32
	err = binary.Read(r, binary.BigEndian, &IndexNameSize)
	if err != nil {
		return errors.New("DeleteIndexReqInfo.IndexName string size unpack error\n" + err.Error())
	}

	IndexNameBytes := make([]byte, IndexNameSize)
	err = binary.Read(r, binary.BigEndian, IndexNameBytes)
	if err != nil {
		return errors.New("DeleteIndexReqInfo.IndexName string content unpack error\n" + err.Error())
	}
	this.IndexName = string(IndexNameBytes[:len(IndexNameBytes)-1])

	return err
}

const (
	DeleteIndexResInfoBaseVersion    uint32 = 117
	DeleteIndexResInfoCurrentVersion uint32 = 117
)

// DeleteIndexResInfo
type DeleteIndexResInfo struct {
	Result int32 `tdr_field:"Result"`
}

func NewDeleteIndexResInfo() *DeleteIndexResInfo {
	obj := new(DeleteIndexResInfo)
	obj.Init()
	return obj
}

func (this *DeleteIndexResInfo) GetBaseVersion() uint32 {
	return DeleteIndexResInfoBaseVersion
}

func (this *DeleteIndexResInfo) GetCurrentVersion() uint32 {
	return DeleteIndexResInfoCurrentVersion
}

func (this *DeleteIndexResInfo) Init() {

}

func (this *DeleteIndexResInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("DeleteIndexResInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *DeleteIndexResInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > DeleteIndexResInfoCurrentVersion {
		cutVer = DeleteIndexResInfoCurrentVersion
	}
	// check cut version
	if cutVer < DeleteIndexResInfoBaseVersion {
		return errors.New("DeleteIndexResInfo cut version must large than DeleteIndexResInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("DeleteIndexResInfo.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *DeleteIndexResInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("DeleteIndexResInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *DeleteIndexResInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > DeleteIndexResInfoCurrentVersion {
		cutVer = DeleteIndexResInfoCurrentVersion
	}
	// check version
	if cutVer < DeleteIndexResInfoBaseVersion {
		errors.New("DeleteIndexResInfo cut version must large than DeleteIndexResInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("DeleteIndexResInfo.Result unpack error\n" + err.Error())
	}

	return err
}
