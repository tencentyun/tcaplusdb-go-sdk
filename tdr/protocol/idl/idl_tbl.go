// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2020-11-24 10:20:43
package idl

import (
	"encoding/binary"
	"errors"

	"github.com/tencentyun/tsf4g/tdrcom"
)

const KEY_MAX_SIZE int64 = 1022
const VALUE_MAX_SIZE int64 = 131072
const (
	Tbl_IdlBaseVersion    uint32 = 1
	Tbl_IdlCurrentVersion uint32 = 1
)

var Tbl_IdlDBFeilds = &tdrcom.TDRDBFeilds{
	SplittableKey: "Key",
	PrimaryKey:    "Key",
}

// Tbl_Idl
type Tbl_Idl struct {
	Klen int32 `tdr_field:"klen"`

	Key []byte `tdr_field:"key" tdr_count:"1022" tdr_refer:"Klen"`

	Vlen int32 `tdr_field:"vlen"`

	Value []byte `tdr_field:"value" tdr_count:"131072" tdr_refer:"Vlen"`
}

func NewTbl_Idl() *Tbl_Idl {
	obj := new(Tbl_Idl)
	obj.Init()
	return obj
}

func (this *Tbl_Idl) GetBaseVersion() uint32 {
	return Tbl_IdlBaseVersion
}

func (this *Tbl_Idl) GetCurrentVersion() uint32 {
	return Tbl_IdlCurrentVersion
}

func (this *Tbl_Idl) GetTDRDBFeilds() *tdrcom.TDRDBFeilds {
	return Tbl_IdlDBFeilds
}

func (this *Tbl_Idl) Init() {
	this.Klen = 0

	this.Vlen = 0

}

func (this *Tbl_Idl) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("Tbl_Idl Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *Tbl_Idl) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > Tbl_IdlCurrentVersion {
		cutVer = Tbl_IdlCurrentVersion
	}
	// check cut version
	if cutVer < Tbl_IdlBaseVersion {
		return errors.New("Tbl_Idl cut version must large than Tbl_IdlBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Klen)
	if err != nil {
		return errors.New("Tbl_Idl.Klen pack error\n" + err.Error())
	}

	if this.Klen < 0 {
		return errors.New("Tbl_Idl.Key's refer Klen should >= 0")
	}
	if this.Klen > 1022 {
		return errors.New("Tbl_Idl.Key's refer Klen should <= count 1022")
	}
	if len(this.Key) < int(this.Klen) {
		return errors.New("Tbl_Idl.Key's length should > Klen")
	}
	if this.Klen > 0 {
		referKey := this.Key[:this.Klen]
		err = binary.Write(w, binary.BigEndian, referKey)
		if err != nil {
			return errors.New("Tbl_Idl.Key pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.Vlen)
	if err != nil {
		return errors.New("Tbl_Idl.Vlen pack error\n" + err.Error())
	}

	if this.Vlen < 0 {
		return errors.New("Tbl_Idl.Value's refer Vlen should >= 0")
	}
	if this.Vlen > 131072 {
		return errors.New("Tbl_Idl.Value's refer Vlen should <= count 131072")
	}
	if len(this.Value) < int(this.Vlen) {
		return errors.New("Tbl_Idl.Value's length should > Vlen")
	}
	if this.Vlen > 0 {
		referValue := this.Value[:this.Vlen]
		err = binary.Write(w, binary.BigEndian, referValue)
		if err != nil {
			return errors.New("Tbl_Idl.Value pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *Tbl_Idl) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("Tbl_Idl data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *Tbl_Idl) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > Tbl_IdlCurrentVersion {
		cutVer = Tbl_IdlCurrentVersion
	}
	// check version
	if cutVer < Tbl_IdlBaseVersion {
		errors.New("Tbl_Idl cut version must large than Tbl_IdlBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Klen)
	if err != nil {
		return errors.New("Tbl_Idl.Klen unpack error\n" + err.Error())
	}

	if this.Klen < 0 {
		return errors.New("Tbl_Idl.Key's refer Klen should >= 0")
	}
	if this.Klen > 1022 {
		return errors.New("Tbl_Idl.Key's refer Klen should <= count 1022")
	}

	if this.Key == nil {
		this.Key = make([]byte, int(this.Klen))
	}

	referKey := this.Key[:this.Klen]
	err = binary.Read(r, binary.BigEndian, referKey)
	if err != nil {
		return errors.New("Tbl_Idl.Key pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Vlen)
	if err != nil {
		return errors.New("Tbl_Idl.Vlen unpack error\n" + err.Error())
	}

	if this.Vlen < 0 {
		return errors.New("Tbl_Idl.Value's refer Vlen should >= 0")
	}
	if this.Vlen > 131072 {
		return errors.New("Tbl_Idl.Value's refer Vlen should <= count 131072")
	}

	if this.Value == nil {
		this.Value = make([]byte, int(this.Vlen))
	}

	referValue := this.Value[:this.Vlen]
	err = binary.Read(r, binary.BigEndian, referValue)
	if err != nil {
		return errors.New("Tbl_Idl.Value pack error\n" + err.Error())
	}

	return err
}
