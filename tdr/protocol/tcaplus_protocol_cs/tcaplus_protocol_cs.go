// auto generated by tdr 2.7.37, don't edit!
//
//     go code compiler
//     author: cowhuang@tencent.com
//
// create time: 2020-11-12 20:10:17
package tcaplus_protocol_cs

import (
	"encoding/binary"
	"errors"
	"io"

	"git.code.oa.com/tsf4g/tdrcom"
)

const TCAPLUS_MAX_USERBUFF_LEN int64 = 1024
const TCAPLUS_MAX_PERFTEST_LEN int64 = 256
const TCAPLUS_MAX_ROUTEBUFF_LEN int64 = 1024
const TCAPLUS_MAX_LIST_ELEMENTSBUFF_LEN int64 = 10300000
const TCAPLUS_MAX_RECORD_NUM int64 = 1024
const TCAPLUS_MAX_UPDATE_FIELD_LEN int64 = 32
const TCAPLUS_MAX_SERVID_LEN int64 = 32
const TCAPLUS_MAX_FAST_BATCH_LIMIT int64 = 50
const TCAPLUS_MAX_PARTKEY_NUM_IN_ONE_REQUEST int64 = 10
const TCAPLUS_MAX_HTTP_VERSION_LEN int64 = 64
const TCAPLUS_MAX_HTTP_TARGET_LEN int64 = 64
const MAX_SWIFT_HEAD_LEN int64 = 1024

// 字符串最大长度,1MB
const MAX_STRING_LEN int64 = 1048576

// 插入数据请求
const TCAPLUS_CMD_INSERT_REQ int64 = 0x0001

// 插入数据响应
const TCAPLUS_CMD_INSERT_RES int64 = 0x0002

// 记录存在则更新数据，否则插入数据请求
const TCAPLUS_CMD_REPLACE_REQ int64 = 0x0003

// 记录存在则更新数据，否则插入数据响应
const TCAPLUS_CMD_REPLACE_RES int64 = 0x0004

// 增量更新数据请求
const TCAPLUS_CMD_INCREASE_REQ int64 = 0x0005

// 增量更新数据响应
const TCAPLUS_CMD_INCREASE_RES int64 = 0x0006

// 读取数据请求
const TCAPLUS_CMD_GET_REQ int64 = 0x0007

// 读取数据响应
const TCAPLUS_CMD_GET_RES int64 = 0x0008

// 删除记录请求
const TCAPLUS_CMD_DELETE_REQ int64 = 0x0009

// 删除记录请求
const TCAPLUS_CMD_DELETE_RES int64 = 0x000a

// 列表全部内容获取请求
const TCAPLUS_CMD_LIST_GETALL_REQ int64 = 0x000b

// 列表全部内容获取响应
const TCAPLUS_CMD_LIST_GETALL_RES int64 = 0x000c

// 全部列表内容删除请求
const TCAPLUS_CMD_LIST_DELETEALL_REQ int64 = 0x000d

// 全部列表内容删除响应
const TCAPLUS_CMD_LIST_DELETEALL_RES int64 = 0x000e

// 列表元素获取请求
const TCAPLUS_CMD_LIST_GET_REQ int64 = 0x000f

// 列表元素获取响应
const TCAPLUS_CMD_LIST_GET_RES int64 = 0x0010

// 列表元素添加请求
const TCAPLUS_CMD_LIST_ADDAFTER_REQ int64 = 0x0011

// 列表元素添加响应
const TCAPLUS_CMD_LIST_ADDAFTER_RES int64 = 0x0012

// 列表元素删除请求
const TCAPLUS_CMD_LIST_DELETE_REQ int64 = 0x0013

// 列表元素删除响应
const TCAPLUS_CMD_LIST_DELETE_RES int64 = 0x0014

// 列表元素更新请求
const TCAPLUS_CMD_LIST_REPLACE_REQ int64 = 0x0015

// 列表元素更新响应
const TCAPLUS_CMD_LIST_REPLACE_RES int64 = 0x0016

// 批量读取数据请求
const TCAPLUS_CMD_BATCH_GET_REQ int64 = 0x0017

// 批量读取数据响应
const TCAPLUS_CMD_BATCH_GET_RES int64 = 0x0018

// 部分key查询请求
const TCAPLUS_CMD_GET_BY_PARTKEY_REQ int64 = 0x0019

// 部分key查询响应
const TCAPLUS_CMD_GET_BY_PARTKEY_RES int64 = 0x001a

// 元数据信息获取请求
const TCAPLUS_CMD_METADATA_GET_REQ int64 = 0x001b

// 元数据信息获取响应
const TCAPLUS_CMD_METADATA_GET_RES int64 = 0x001c

// 更新已存在数据请求
const TCAPLUS_CMD_UPDATE_REQ int64 = 0x001d

// 更新已存在数据响应
const TCAPLUS_CMD_UPDATE_RES int64 = 0x001e

// 特殊读取数据请求
const TCAPLUS_CMD_SPECIAL_GET_REQ int64 = 0x0001f

// 特殊读取数据响应
const TCAPLUS_CMD_SPECIAL_GET_RES int64 = 0x00020

// 数据搬迁插入数据请求
const TCAPLUS_CMD_MOVE_INSERT_REQ int64 = 0x0021

// 数据搬迁插入数据响应
const TCAPLUS_CMD_MOVE_INSERT_RES int64 = 0x0022

// 插入数据请求
const TCAPLUS_CMD_MSSYNC_INSERT_REQ int64 = 0x0023

// 插入数据响应
const TCAPLUS_CMD_MSSYNC_INSERT_RES int64 = 0x0024

// 记录存在则更新数据，否则插入数据请求
const TCAPLUS_CMD_MSSYNC_REPLACE_REQ int64 = 0x0025

// 记录存在则更新数据，否则插入数据响应
const TCAPLUS_CMD_MSSYNC_REPLACE_RES int64 = 0x0026

// 删除记录请求
const TCAPLUS_CMD_MSSYNC_DELETE_REQ int64 = 0x0027

// 删除记录请求
const TCAPLUS_CMD_MSSYNC_DELETE_RES int64 = 0x0028

// 更新已存在数据请求
const TCAPLUS_CMD_MSSYNC_UPDATE_REQ int64 = 0x0029

// 更新已存在数据响应
const TCAPLUS_CMD_MSSYNC_UPDATE_RES int64 = 0x002a

// 列表元素添加请求
const TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_REQ int64 = 0x002b

// 列表元素添加响应
const TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_RES int64 = 0x002c

// 列表元素删除请求
const TCAPLUS_CMD_LIST_MSSYNC_DELETE_REQ int64 = 0x002d

// 列表元素删除响应
const TCAPLUS_CMD_LIST_MSSYNC_DELETE_RES int64 = 0x002e

// 列表元素更新请求
const TCAPLUS_CMD_LIST_MSSYNC_REPLACE_REQ int64 = 0x002f

// 列表元素更新响应
const TCAPLUS_CMD_LIST_MSSYNC_REPLACE_RES int64 = 0x0030

// 全部列表内容删除请求
const TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_REQ int64 = 0x0031

// 全部列表内容删除响应
const TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_RES int64 = 0x0032

// 服务化应用身份认证请求
const TCAPLUS_CMD_SERV_APP_SIGNUP_REQ int64 = 0x0033

// 服务化应用身份认证响应
const TCAPLUS_CMD_SERV_APP_SIGNUP_RES int64 = 0x0034

// 心跳检查请求
const TCAPLUS_CMD_SERV_HEART_BEAT_REQ int64 = 0x0035

// 心跳检查响应
const TCAPLUS_CMD_SERV_HEART_BEAT_RES int64 = 0x0036

// 准备数据搬迁请求(from src to dest)
const TCAPLUS_CMD_PREPARE_MOVE_REQ int64 = 0x0037

// 准备数据搬迁响应(from dest to src)
const TCAPLUS_CMD_PREPARE_MOVE_RES int64 = 0x0038

// 结束数据搬迁请求(from src to dest)
const TCAPLUS_CMD_FINISH_MOVE_REQ int64 = 0x0039

// 结束数据搬迁响应(from dest to src)
const TCAPLUS_CMD_FINISH_MOVE_RES int64 = 0x003a

// 检查LIST记录是否完整
const TCAPLUS_CMD_LIST_CHECK_REQ int64 = 0x003b

// 返回LIST记录是否完整
const TCAPLUS_CMD_LIST_CHECK_RES int64 = 0x003c

// 插入列表索引搬迁数据请求
const TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_REQ int64 = 0x003d

// 插入列表索引搬迁数据响应
const TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_RES int64 = 0x003e

// 插入列表元素搬迁数据请求
const TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_REQ int64 = 0x003f

// 插入列表元素搬迁数据响应
const TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_RES int64 = 0x0040

// LIST删除多个元素请求
const TCAPLUS_CMD_LIST_DELETE_BATCH_REQ int64 = 0x0041

// LIST删除多个元素响应
const TCAPLUS_CMD_LIST_DELETE_BATCH_RES int64 = 0x0042

// tcaproxy通知客户端即将停止运行
const TCAPLUS_CMD_NOTIFY_STOP_REQ int64 = 0x0043

// 客户端响应tcaproxy，表示暂时不再发送请求
const TCAPLUS_CMD_NOTIFY_STOP_RES int64 = 0x0044

// 全表遍历请求
const TCAPLUS_CMD_TABLE_TRAVERSE_REQ int64 = 0x0045

// 全表遍历响应
const TCAPLUS_CMD_TABLE_TRAVERSE_RES int64 = 0x0046

// 获取表的所有shard id请求
const TCAPLUS_CMD_GET_SHARD_LIST_REQ int64 = 0x0047

// 获取表的所有shard id响应
const TCAPLUS_CMD_GET_SHARD_LIST_RES int64 = 0x0048

// 批量部分key 查询请求
const TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_REQ int64 = 0x0049

// 批量部分key  查询响应
const TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_RES int64 = 0x004a

// document操作请求
const TCAPLUS_CMD_DOCUMENT_OPERATION_REQ int64 = 0x004b

// document操作响应
const TCAPLUS_CMD_DOCUMENT_OPERATION_RES int64 = 0x004c

// Partkey Update 请求
const TCAPLUS_CMD_UPDATE_BY_PARTKEY_REQ int64 = 0x004d

// Partkey Update 响应
const TCAPLUS_CMD_UPDATE_BY_PARTKEY_RES int64 = 0x004e

// Partkey Delete 请求
const TCAPLUS_CMD_DELETE_BY_PARTKEY_REQ int64 = 0x004f

// Partkey Delete 响应
const TCAPLUS_CMD_DELETE_BY_PARTKEY_RES int64 = 0x0050

// 带有相同Partkey的批量replace请求
const TCAPLUS_CMD_INSERT_BY_PARTKEY_REQ int64 = 0x0051

// 带有相同Partkey的批量replace响应
const TCAPLUS_CMD_INSERT_BY_PARTKEY_RES int64 = 0x0052

// table的记录总数请求
const TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_REQ int64 = 0x0053

// table的记录总数响应
const TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_RES int64 = 0x0054

// http generic req
const TCAPLUS_CMD_HTTP_GENERIC_REQ int64 = 0x0055

// http generic res
const TCAPLUS_CMD_HTTP_GENERIC_RES int64 = 0x0056

// List表全表遍历请求
const TCAPLUS_CMD_LIST_TABLE_TRAVERSE_REQ int64 = 0x0057

// List表全表遍历响应
const TCAPLUS_CMD_LIST_TABLE_TRAVERSE_RES int64 = 0x0058

// Probotuf部分字段获取请求
const TCAPLUS_CMD_PROTOBUF_FIELD_GET_REQ int64 = 0x0067

// Probotuf部分字段获取响应
const TCAPLUS_CMD_PROTOBUF_FIELD_GET_RES int64 = 0x0068

// Probotuf部分字段更新请求
const TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_REQ int64 = 0x0069

// Probotuf部分字段更新响应
const TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_RES int64 = 0x006a

// Probotuf部分字段加值请求
const TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_REQ int64 = 0x006b

// Probotuf部分字段加值响应
const TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_RES int64 = 0x006c

// 批量Probotuf部分字段获取数据请求
const TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_REQ int64 = 0x0075

// 批量Probotuf部分字段获取数据响应
const TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_RES int64 = 0x0076

// 索引查询请求
const TCAPLUS_CMD_SQL_REQ int64 = 0x0081

// 索引查询响应
const TCAPLUS_CMD_SQL_RES int64 = 0x0082

// 索引查询时，从svr获取记录请求
const TCAPLUS_CMD_GET_FOR_SQL_QUERY_REQ int64 = 0x0083

// 索引查询时，从svr获取记录响应
const TCAPLUS_CMD_GET_FOR_SQL_QUERY_RES int64 = 0x0084

// 系统内部的读取数据请求
const TCAPLUS_CMD_SYS_GET_REQ int64 = 0x1001

// 系统内部的读取数据响应
const TCAPLUS_CMD_SYS_GET_RES int64 = 0x1002

// 系统内部的删除记录请求
const TCAPLUS_CMD_SYS_DELETE_REQ int64 = 0x1003

// 系统内部的删除记录响应
const TCAPLUS_CMD_SYS_DELETE_RES int64 = 0x1004

// 系统内部的删除List记录请求
const TCAPLUS_CMD_SYS_LIST_DELETE_REQ int64 = 0x1005

// 系统内部的删除List记录响应
const TCAPLUS_CMD_SYS_LIST_DELETE_RES int64 = 0x1006

// 系统内部的读取List记录请求
const TCAPLUS_CMD_SYS_LIST_GET_REQ int64 = 0x1007

// 系统内部的读取List记录响应
const TCAPLUS_CMD_SYS_LIST_GET_RES int64 = 0x1008

// 系统内部的批量读取List记录请求
const TCAPLUS_CMD_SYS_LIST_GET_ALL_REQ int64 = 0x1009

// 系统内部的批量读取List记录响应
const TCAPLUS_CMD_SYS_LIST_GET_ALL_RES int64 = 0x100a

// 读取数据请求, 用于搬迁过程和batchget查询
const TCAPLUS_CMD_GET_DURING_MOVE_REQ int64 = 0x1051

// 读取数据响应, 用于搬迁过程和batchget查询
const TCAPLUS_CMD_GET_DURING_MOVE_RES int64 = 0x1052

// 从源端获取记录请求
const TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_REQ int64 = 0x1053

// 从源端获取记录响应
const TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_RES int64 = 0x1054

// 搬迁过程中目的端向源端协商版本请求包
const TCAPLUS_CMD_NEGOTIATE_VERSION_REQ int64 = 0x1055

// 搬迁过程中目的端向源端协商版本响应包
const TCAPLUS_CMD_NEGOTIATE_VERSION_RES int64 = 0x1056

// 搬迁过程中检测目的端到源端的连接请求包，由源端发送，并带上源端的监听地址
const TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_REQ int64 = 0x1057

// 搬迁过程中检测目的端到源端的连接响应包,由目的端回应
const TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_RES int64 = 0x1058

// 过期删除记录请求
const TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_REQ int64 = 0x0061

// 过期删除记录请求
const TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_RES int64 = 0x0062

// 搬迁删除请求
const TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_REQ int64 = 0x0063

// 搬迁删除响应
const TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_RES int64 = 0x0064

// 过期列表元素删除请求
const TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_REQ int64 = 0x0065

// 过期列表元素删除响应
const TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_RES int64 = 0x0066

// 获取数据请求
const TCAPLUS_CMD_MSSYNC_GET_REQ int64 = 0x006d

// 获取数据响应
const TCAPLUS_CMD_MSSYNC_GET_RES int64 = 0x006e

// LIST表获取数据请求
const TCAPLUS_CMD_LIST_MSSYNC_GET_REQ int64 = 0x006f

// LIST表获取数据响应
const TCAPLUS_CMD_LIST_MSSYNC_GET_RES int64 = 0x0070

// LIST表获取全部数据请求
const TCAPLUS_CMD_LIST_MSSYNC_GETALL_REQ int64 = 0x0071

// LIST表获取全部数据响应
const TCAPLUS_CMD_LIST_MSSYNC_GETALL_RES int64 = 0x0072

// 部分key获取数据请求
const TCAPLUS_CMD_MSSYNC_PARTKEY_GET_REQ int64 = 0x0073

// 部分key获取数据响应
const TCAPLUS_CMD_MSSYNC_PARTKEY_GET_RES int64 = 0x0074

// 系统内部的校正数据记录请求
const TCAPLUS_CMD_SYS_MAKE_CONSIST_REQ int64 = 0x100b

// 系统内部的校正数据记录响应
const TCAPLUS_CMD_SYS_MAKE_CONSIST_RES int64 = 0x100c

// 系统内部的校正List数据记录请求
const TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_REQ int64 = 0x100d

// 系统内部的校正List数据记录响应
const TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_RES int64 = 0x100e

// 无损搬迁插入数据请求
const TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_REQ int64 = 0x1071

// 无损搬迁插入数据响应
const TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_RES int64 = 0x1072

// 无损搬迁list表索引插入数据请求
const TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_REQ int64 = 0x1073

// 无损搬迁list表索引插入数据响应
const TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_RES int64 = 0x1074

// 无损搬迁list表元素插入数据请求
const TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_REQ int64 = 0x1075

// 无损搬迁list表元素插入数据响应
const TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_RES int64 = 0x1076

// list表索引数据搬迁replace请求
const TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_REQ int64 = 0x1077

// list表索引数据搬迁replace响应
const TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_RES int64 = 0x1078

// list表元素数据搬迁replace请求
const TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_REQ int64 = 0x1079

// list表元素数据搬迁replace响应
const TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_RES int64 = 0x107a

// 无效命令
const DOCUMENT_COMMAND_INVALID int64 = 0

// get命令
const DOCUMENT_COMMAND_GET int64 = 1

// set命令
const DOCUMENT_COMMAND_SET int64 = 2

// inc命令
const DOCUMENT_COMMAND_INC int64 = 3

// 插入记录命令
const DOCUMENT_COMMAND_INSERT int64 = 4

// 删除记录命令
const DOCUMENT_COMMAND_REMOVE int64 = 5

// 插入数组成员命令
const DOCUMENT_COMMAND_PUSH int64 = 6

// 删除数组成员命令
const DOCUMENT_COMMAND_POP int64 = 7

// 加操作
const TCAPLUS_OP_PLUS int64 = 0x0001

// 减操作
const TCAPLUS_OP_MINUS int64 = 0x0002

// 不携带返回值
const TCaplusValueFlag_NOVALUE int64 = 0x00

// 同请求一致
const TCaplusValueFlag_SAMEWITHREQUEST int64 = 0x01

// 所有字段值
const TCaplusValueFlag_ALLVALUE int64 = 0x02

// 旧值所有字段值
const TCaplusValueFlag_ALLOLDVALUE int64 = 0x03

// 插入元素位置在最后面
const TCAPLUS_LIST_LAST_INDEX int64 = -1

// 插入元素位置在最前面
const TCAPLUS_LIST_PRE_FIRST_INDEX int64 = -2

// 不移除元素
const TCAPLUS_LIST_SHIFT_NONE int64 = 0

// 移除最前面的元素
const TCAPLUS_LIST_SHIFT_HEAD int64 = 1

// 移除最后面的元素
const TCAPLUS_LIST_SHIFT_TAIL int64 = 2

// 响应包中不返回任何记录
const RETURN_NO_RECORD int64 = 0x00

// 响应包中返回所有字段
const RETURN_RECORD_WITH_ALL_VALUE_FIELDS int64 = 0x01

// 响应包中返回所指定的字段
const RETURN_RECORD_WITH_SPECIFY_VALUE_FIELDS int64 = 0x02
const (
	TCaplusNameSetBaseVersion    uint32 = 1
	TCaplusNameSetCurrentVersion uint32 = 1
)

// TCaplusNameSet
type TCaplusNameSet struct {
	FieldNum uint32 `tdr_field:"FieldNum"`

	FieldName []string `tdr_field:"FieldName" tdr_count:"256" tdr_refer:"FieldNum"`
}

func NewTCaplusNameSet() *TCaplusNameSet {
	obj := new(TCaplusNameSet)
	obj.Init()
	return obj
}

func (this *TCaplusNameSet) GetBaseVersion() uint32 {
	return TCaplusNameSetBaseVersion
}

func (this *TCaplusNameSet) GetCurrentVersion() uint32 {
	return TCaplusNameSetCurrentVersion
}

func (this *TCaplusNameSet) Init() {
	this.FieldNum = 0

}

func (this *TCaplusNameSet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusNameSet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusNameSet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusNameSetCurrentVersion {
		cutVer = TCaplusNameSetCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusNameSetBaseVersion {
		return errors.New("TCaplusNameSet cut version must large than TCaplusNameSetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.FieldNum)
	if err != nil {
		return errors.New("TCaplusNameSet.FieldNum pack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TCaplusNameSet.FieldName's refer FieldNum should >= 0")
	}
	if this.FieldNum > 256 {
		return errors.New("TCaplusNameSet.FieldName's refer FieldNum should <= count 256")
	}
	if len(this.FieldName) < int(this.FieldNum) {
		return errors.New("TCaplusNameSet.FieldName's length should > FieldNum")
	}
	if this.FieldNum > 0 {
		for i := 0; i < int(this.FieldNum); i++ {
			err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName[i]))+1)
			if err != nil {
				return errors.New("TCaplusNameSet.FieldName string size pack error\n" + err.Error())
			}
			err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName[i]), 0))
			if err != nil {
				return errors.New("TCaplusNameSet.FieldName string content pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TCaplusNameSet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusNameSet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusNameSet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusNameSetCurrentVersion {
		cutVer = TCaplusNameSetCurrentVersion
	}
	// check version
	if cutVer < TCaplusNameSetBaseVersion {
		errors.New("TCaplusNameSet cut version must large than TCaplusNameSetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum)
	if err != nil {
		return errors.New("TCaplusNameSet.FieldNum unpack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TCaplusNameSet.FieldName's refer FieldNum should >= 0")
	}
	if this.FieldNum > 256 {
		return errors.New("TCaplusNameSet.FieldName's refer FieldNum should <= count 256")
	}

	if this.FieldName == nil {
		this.FieldName = make([]string, int(this.FieldNum))
	}

	for i := 0; i < int(this.FieldNum); i++ {
		var FieldNameSize uint32
		err = binary.Read(r, binary.BigEndian, &FieldNameSize)
		if err != nil {
			return errors.New("TCaplusNameSet.FieldName string size unpack error\n" + err.Error())
		}

		FieldNameBytes := make([]byte, FieldNameSize)
		err = binary.Read(r, binary.BigEndian, FieldNameBytes)
		if err != nil {
			return errors.New("TCaplusNameSet.FieldName string content unpack error\n" + err.Error())
		}
		this.FieldName[i] = string(FieldNameBytes[:len(FieldNameBytes)-1])

	}

	return err
}

const (
	TCaplusListElementSetBaseVersion    uint32 = 1
	TCaplusListElementSetCurrentVersion uint32 = 1
)

// TCaplusListElementSet
type TCaplusListElementSet struct {
	ElementStartSubscriptOnServer int32 `tdr_field:"ElementStartSubscriptOnServer"`

	ElementNum uint32 `tdr_field:"ElementNum"`

	ElementsBuffLen uint32 `tdr_field:"ElementsBuffLen"`

	ElementsBuff []byte `tdr_field:"ElementsBuff" tdr_count:"10300000" tdr_refer:"ElementsBuffLen"`
}

func NewTCaplusListElementSet() *TCaplusListElementSet {
	obj := new(TCaplusListElementSet)
	obj.Init()
	return obj
}

func (this *TCaplusListElementSet) GetBaseVersion() uint32 {
	return TCaplusListElementSetBaseVersion
}

func (this *TCaplusListElementSet) GetCurrentVersion() uint32 {
	return TCaplusListElementSetCurrentVersion
}

func (this *TCaplusListElementSet) Init() {
	this.ElementStartSubscriptOnServer = -1

	this.ElementsBuffLen = 0

}

func (this *TCaplusListElementSet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListElementSet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListElementSet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListElementSetCurrentVersion {
		cutVer = TCaplusListElementSetCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListElementSetBaseVersion {
		return errors.New("TCaplusListElementSet cut version must large than TCaplusListElementSetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementStartSubscriptOnServer)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementStartSubscriptOnServer pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementNum)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementsBuffLen)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementsBuffLen pack error\n" + err.Error())
	}

	if this.ElementsBuffLen < 0 {
		return errors.New("TCaplusListElementSet.ElementsBuff's refer ElementsBuffLen should >= 0")
	}
	if this.ElementsBuffLen > 10300000 {
		return errors.New("TCaplusListElementSet.ElementsBuff's refer ElementsBuffLen should <= count 10300000")
	}
	if len(this.ElementsBuff) < int(this.ElementsBuffLen) {
		return errors.New("TCaplusListElementSet.ElementsBuff's length should > ElementsBuffLen")
	}
	if this.ElementsBuffLen > 0 {
		referElementsBuff := this.ElementsBuff[:this.ElementsBuffLen]
		err = binary.Write(w, binary.BigEndian, referElementsBuff)
		if err != nil {
			return errors.New("TCaplusListElementSet.ElementsBuff pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusListElementSet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListElementSet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListElementSet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListElementSetCurrentVersion {
		cutVer = TCaplusListElementSetCurrentVersion
	}
	// check version
	if cutVer < TCaplusListElementSetBaseVersion {
		errors.New("TCaplusListElementSet cut version must large than TCaplusListElementSetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementStartSubscriptOnServer)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementStartSubscriptOnServer unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementNum)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementsBuffLen)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementsBuffLen unpack error\n" + err.Error())
	}

	if this.ElementsBuffLen < 0 {
		return errors.New("TCaplusListElementSet.ElementsBuff's refer ElementsBuffLen should >= 0")
	}
	if this.ElementsBuffLen > 10300000 {
		return errors.New("TCaplusListElementSet.ElementsBuff's refer ElementsBuffLen should <= count 10300000")
	}

	if this.ElementsBuff == nil {
		this.ElementsBuff = make([]byte, int(this.ElementsBuffLen))
	}

	referElementsBuff := this.ElementsBuff[:this.ElementsBuffLen]
	err = binary.Read(r, binary.BigEndian, referElementsBuff)
	if err != nil {
		return errors.New("TCaplusListElementSet.ElementsBuff pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusUpdFieldBaseVersion       uint32 = 1
	TCaplusUpdFieldCurrentVersion    uint32 = 21
	TCaplusUpdFieldLowerLimitVersion uint32 = 21
	TCaplusUpdFieldUpperLimitVersion uint32 = 21
)

// TCaplusUpdField
type TCaplusUpdField struct {
	FieldName string `tdr_field:"FieldName"`

	FieldLen uint32 `tdr_field:"FieldLen"`

	FieldBuff []byte `tdr_field:"FieldBuff" tdr_count:"32" tdr_refer:"FieldLen"`

	FieldOperation uint32 `tdr_field:"FieldOperation"`

	LowerLimit int64 `tdr_field:"LowerLimit"`

	UpperLimit int64 `tdr_field:"UpperLimit"`
}

func NewTCaplusUpdField() *TCaplusUpdField {
	obj := new(TCaplusUpdField)
	obj.Init()
	return obj
}

func (this *TCaplusUpdField) GetBaseVersion() uint32 {
	return TCaplusUpdFieldBaseVersion
}

func (this *TCaplusUpdField) GetCurrentVersion() uint32 {
	return TCaplusUpdFieldCurrentVersion
}

func (this *TCaplusUpdField) Init() {

	this.FieldLen = 0

	this.LowerLimit = 0

	this.UpperLimit = 0

}

func (this *TCaplusUpdField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusUpdField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusUpdField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusUpdFieldCurrentVersion {
		cutVer = TCaplusUpdFieldCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusUpdFieldBaseVersion {
		return errors.New("TCaplusUpdField cut version must large than TCaplusUpdFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName))+1)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName), 0))
	if err != nil {
		return errors.New("TCaplusUpdField.FieldName string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldLen)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldLen pack error\n" + err.Error())
	}

	if this.FieldLen < 0 {
		return errors.New("TCaplusUpdField.FieldBuff's refer FieldLen should >= 0")
	}
	if this.FieldLen > 32 {
		return errors.New("TCaplusUpdField.FieldBuff's refer FieldLen should <= count 32")
	}
	if len(this.FieldBuff) < int(this.FieldLen) {
		return errors.New("TCaplusUpdField.FieldBuff's length should > FieldLen")
	}
	if this.FieldLen > 0 {
		referFieldBuff := this.FieldBuff[:this.FieldLen]
		err = binary.Write(w, binary.BigEndian, referFieldBuff)
		if err != nil {
			return errors.New("TCaplusUpdField.FieldBuff pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.FieldOperation)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldOperation pack error\n" + err.Error())
	}

	if cutVer >= TCaplusUpdFieldLowerLimitVersion {

		err = binary.Write(w, binary.BigEndian, this.LowerLimit)
		if err != nil {
			return errors.New("TCaplusUpdField.LowerLimit pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusUpdFieldUpperLimitVersion {

		err = binary.Write(w, binary.BigEndian, this.UpperLimit)
		if err != nil {
			return errors.New("TCaplusUpdField.UpperLimit pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusUpdField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusUpdField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusUpdField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusUpdFieldCurrentVersion {
		cutVer = TCaplusUpdFieldCurrentVersion
	}
	// check version
	if cutVer < TCaplusUpdFieldBaseVersion {
		errors.New("TCaplusUpdField cut version must large than TCaplusUpdFieldBaseVersion\n")
	}

	var FieldNameSize uint32
	err = binary.Read(r, binary.BigEndian, &FieldNameSize)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldName string size unpack error\n" + err.Error())
	}

	FieldNameBytes := make([]byte, FieldNameSize)
	err = binary.Read(r, binary.BigEndian, FieldNameBytes)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldName string content unpack error\n" + err.Error())
	}
	this.FieldName = string(FieldNameBytes[:len(FieldNameBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.FieldLen)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldLen unpack error\n" + err.Error())
	}

	if this.FieldLen < 0 {
		return errors.New("TCaplusUpdField.FieldBuff's refer FieldLen should >= 0")
	}
	if this.FieldLen > 32 {
		return errors.New("TCaplusUpdField.FieldBuff's refer FieldLen should <= count 32")
	}

	if this.FieldBuff == nil {
		this.FieldBuff = make([]byte, int(this.FieldLen))
	}

	referFieldBuff := this.FieldBuff[:this.FieldLen]
	err = binary.Read(r, binary.BigEndian, referFieldBuff)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldBuff pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldOperation)
	if err != nil {
		return errors.New("TCaplusUpdField.FieldOperation unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusUpdFieldLowerLimitVersion {

		err = binary.Read(r, binary.BigEndian, &this.LowerLimit)
		if err != nil {
			return errors.New("TCaplusUpdField.LowerLimit unpack error\n" + err.Error())
		}

	} else {
		this.LowerLimit = 0

	}
	if cutVer >= TCaplusUpdFieldUpperLimitVersion {

		err = binary.Read(r, binary.BigEndian, &this.UpperLimit)
		if err != nil {
			return errors.New("TCaplusUpdField.UpperLimit unpack error\n" + err.Error())
		}

	} else {
		this.UpperLimit = 0

	}
	return err
}

const (
	TCaplusUpdFieldSetBaseVersion    uint32 = 1
	TCaplusUpdFieldSetCurrentVersion uint32 = 21
)

// TCaplusUpdFieldSet
type TCaplusUpdFieldSet struct {
	Version int32 `tdr_field:"Version"`

	FieldNum uint32 `tdr_field:"FieldNum"`

	Fields []*TCaplusUpdField `tdr_field:"Fields" tdr_count:"256" tdr_refer:"FieldNum"`
}

func NewTCaplusUpdFieldSet() *TCaplusUpdFieldSet {
	obj := new(TCaplusUpdFieldSet)
	obj.Init()
	return obj
}

func (this *TCaplusUpdFieldSet) GetBaseVersion() uint32 {
	return TCaplusUpdFieldSetBaseVersion
}

func (this *TCaplusUpdFieldSet) GetCurrentVersion() uint32 {
	return TCaplusUpdFieldSetCurrentVersion
}

func (this *TCaplusUpdFieldSet) Init() {

	this.FieldNum = 0

}

func (this *TCaplusUpdFieldSet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusUpdFieldSet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusUpdFieldSet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusUpdFieldSetCurrentVersion {
		cutVer = TCaplusUpdFieldSetCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusUpdFieldSetBaseVersion {
		return errors.New("TCaplusUpdFieldSet cut version must large than TCaplusUpdFieldSetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusUpdFieldSet.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.FieldNum)
	if err != nil {
		return errors.New("TCaplusUpdFieldSet.FieldNum pack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TCaplusUpdFieldSet.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 256 {
		return errors.New("TCaplusUpdFieldSet.Fields's refer FieldNum should <= count 256")
	}
	if len(this.Fields) < int(this.FieldNum) {
		return errors.New("TCaplusUpdFieldSet.Fields's length should > FieldNum")
	}
	if this.FieldNum > 0 {
		for i := 0; i < int(this.FieldNum); i++ {
			err = this.Fields[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusUpdFieldSet.Fields pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TCaplusUpdFieldSet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusUpdFieldSet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusUpdFieldSet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusUpdFieldSetCurrentVersion {
		cutVer = TCaplusUpdFieldSetCurrentVersion
	}
	// check version
	if cutVer < TCaplusUpdFieldSetBaseVersion {
		errors.New("TCaplusUpdFieldSet cut version must large than TCaplusUpdFieldSetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusUpdFieldSet.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum)
	if err != nil {
		return errors.New("TCaplusUpdFieldSet.FieldNum unpack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("TCaplusUpdFieldSet.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 256 {
		return errors.New("TCaplusUpdFieldSet.Fields's refer FieldNum should <= count 256")
	}

	if this.Fields == nil {
		this.Fields = make([]*TCaplusUpdField, int(this.FieldNum))
		for i := 0; i < int(this.FieldNum); i++ {
			this.Fields[i] = NewTCaplusUpdField()
		}
	}

	for i := 0; i < int(this.FieldNum); i++ {
		err = this.Fields[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusUpdFieldSet.Fields unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	TCaplusInsertReqBaseVersion    uint32 = 1
	TCaplusInsertReqCurrentVersion uint32 = 109
)

// TCaplusInsertReq
type TCaplusInsertReq struct {
	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	Flag byte `tdr_field:"Flag"`
}

func NewTCaplusInsertReq() *TCaplusInsertReq {
	obj := new(TCaplusInsertReq)
	obj.Init()
	return obj
}

func (this *TCaplusInsertReq) GetBaseVersion() uint32 {
	return TCaplusInsertReqBaseVersion
}

func (this *TCaplusInsertReq) GetCurrentVersion() uint32 {
	return TCaplusInsertReqCurrentVersion
}

func (this *TCaplusInsertReq) Init() {
	this.ValueInfo = NewTCaplusValueSet_()

}

func (this *TCaplusInsertReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusInsertReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusInsertReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusInsertReqCurrentVersion {
		cutVer = TCaplusInsertReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusInsertReqBaseVersion {
		return errors.New("TCaplusInsertReq cut version must large than TCaplusInsertReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusInsertReq.ValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusInsertReq.Flag pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusInsertReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusInsertReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusInsertReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusInsertReqCurrentVersion {
		cutVer = TCaplusInsertReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusInsertReqBaseVersion {
		errors.New("TCaplusInsertReq cut version must large than TCaplusInsertReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusInsertReq.ValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusInsertReq.Flag unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusInsertResBaseVersion    uint32 = 1
	TCaplusInsertResCurrentVersion uint32 = 109
)

// TCaplusInsertRes
type TCaplusInsertRes struct {
	Result int32 `tdr_field:"Result"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusInsertRes() *TCaplusInsertRes {
	obj := new(TCaplusInsertRes)
	obj.Init()
	return obj
}

func (this *TCaplusInsertRes) GetBaseVersion() uint32 {
	return TCaplusInsertResBaseVersion
}

func (this *TCaplusInsertRes) GetCurrentVersion() uint32 {
	return TCaplusInsertResCurrentVersion
}

func (this *TCaplusInsertRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusInsertRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusInsertRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusInsertRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusInsertResCurrentVersion {
		cutVer = TCaplusInsertResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusInsertResBaseVersion {
		return errors.New("TCaplusInsertRes cut version must large than TCaplusInsertResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusInsertRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusInsertRes.Flag pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusInsertRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusInsertRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusInsertRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusInsertRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusInsertResCurrentVersion {
		cutVer = TCaplusInsertResCurrentVersion
	}
	// check version
	if cutVer < TCaplusInsertResBaseVersion {
		errors.New("TCaplusInsertRes cut version must large than TCaplusInsertResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusInsertRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusInsertRes.Flag unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusInsertRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusReplaceReqBaseVersion              uint32 = 1
	TCaplusReplaceReqCurrentVersion           uint32 = 109
	TCaplusReplaceReqCheckVersiontTypeVersion uint32 = 13
	TCaplusReplaceReqIncreaseValueInfoVersion uint32 = 36
)

// TCaplusReplaceReq
type TCaplusReplaceReq struct {
	Flag byte `tdr_field:"Flag"`

	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`

	IncreaseValueInfo *TCaplusUpdFieldSet `tdr_field:"IncreaseValueInfo"`
}

func NewTCaplusReplaceReq() *TCaplusReplaceReq {
	obj := new(TCaplusReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusReplaceReq) GetBaseVersion() uint32 {
	return TCaplusReplaceReqBaseVersion
}

func (this *TCaplusReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusReplaceReqCurrentVersion
}

func (this *TCaplusReplaceReq) Init() {

	this.ValueInfo = NewTCaplusValueSet_()

	this.CheckVersiontType = 1

	this.IncreaseValueInfo = NewTCaplusUpdFieldSet()

}

func (this *TCaplusReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusReplaceReqCurrentVersion {
		cutVer = TCaplusReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusReplaceReqBaseVersion {
		return errors.New("TCaplusReplaceReq cut version must large than TCaplusReplaceReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusReplaceReq.Flag pack error\n" + err.Error())
	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusReplaceReq.ValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusReplaceReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusReplaceReq.CheckVersiontType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusReplaceReqIncreaseValueInfoVersion {

		err = this.IncreaseValueInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusReplaceReq.IncreaseValueInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusReplaceReqCurrentVersion {
		cutVer = TCaplusReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusReplaceReqBaseVersion {
		errors.New("TCaplusReplaceReq cut version must large than TCaplusReplaceReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusReplaceReq.Flag unpack error\n" + err.Error())
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusReplaceReq.ValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusReplaceReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusReplaceReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	if cutVer >= TCaplusReplaceReqIncreaseValueInfoVersion {

		err = this.IncreaseValueInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusReplaceReq.IncreaseValueInfo unpack error\n" + err.Error())
		}

	} else {
		this.IncreaseValueInfo.Init()

	}
	return err
}

const (
	TCaplusReplaceResBaseVersion           uint32 = 1
	TCaplusReplaceResCurrentVersion        uint32 = 109
	TCaplusReplaceResLastAccessTimeVersion uint32 = 13
)

// TCaplusReplaceRes
type TCaplusReplaceRes struct {
	Result int32 `tdr_field:"Result"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusReplaceRes() *TCaplusReplaceRes {
	obj := new(TCaplusReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusReplaceRes) GetBaseVersion() uint32 {
	return TCaplusReplaceResBaseVersion
}

func (this *TCaplusReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusReplaceResCurrentVersion
}

func (this *TCaplusReplaceRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusReplaceResCurrentVersion {
		cutVer = TCaplusReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusReplaceResBaseVersion {
		return errors.New("TCaplusReplaceRes cut version must large than TCaplusReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusReplaceRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusReplaceRes.Flag pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusReplaceRes.ResultInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusReplaceResLastAccessTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusReplaceRes.LastAccessTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusReplaceResCurrentVersion {
		cutVer = TCaplusReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusReplaceResBaseVersion {
		errors.New("TCaplusReplaceRes cut version must large than TCaplusReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusReplaceRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusReplaceRes.Flag unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusReplaceRes.ResultInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusReplaceResLastAccessTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusReplaceRes.LastAccessTime unpack error\n" + err.Error())
		}

	}
	return err
}

const (
	TCaplusUpdateReqBaseVersion              uint32 = 1
	TCaplusUpdateReqCurrentVersion           uint32 = 109
	TCaplusUpdateReqCheckVersiontTypeVersion uint32 = 13
	TCaplusUpdateReqIncreaseValueInfoVersion uint32 = 36
)

// TCaplusUpdateReq
type TCaplusUpdateReq struct {
	Flag byte `tdr_field:"Flag"`

	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`

	IncreaseValueInfo *TCaplusUpdFieldSet `tdr_field:"IncreaseValueInfo"`
}

func NewTCaplusUpdateReq() *TCaplusUpdateReq {
	obj := new(TCaplusUpdateReq)
	obj.Init()
	return obj
}

func (this *TCaplusUpdateReq) GetBaseVersion() uint32 {
	return TCaplusUpdateReqBaseVersion
}

func (this *TCaplusUpdateReq) GetCurrentVersion() uint32 {
	return TCaplusUpdateReqCurrentVersion
}

func (this *TCaplusUpdateReq) Init() {

	this.ValueInfo = NewTCaplusValueSet_()

	this.CheckVersiontType = 1

	this.IncreaseValueInfo = NewTCaplusUpdFieldSet()

}

func (this *TCaplusUpdateReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusUpdateReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusUpdateReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusUpdateReqCurrentVersion {
		cutVer = TCaplusUpdateReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusUpdateReqBaseVersion {
		return errors.New("TCaplusUpdateReq cut version must large than TCaplusUpdateReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusUpdateReq.Flag pack error\n" + err.Error())
	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusUpdateReq.ValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusUpdateReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusUpdateReq.CheckVersiontType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusUpdateReqIncreaseValueInfoVersion {

		err = this.IncreaseValueInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusUpdateReq.IncreaseValueInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusUpdateReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusUpdateReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusUpdateReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusUpdateReqCurrentVersion {
		cutVer = TCaplusUpdateReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusUpdateReqBaseVersion {
		errors.New("TCaplusUpdateReq cut version must large than TCaplusUpdateReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusUpdateReq.Flag unpack error\n" + err.Error())
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusUpdateReq.ValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusUpdateReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusUpdateReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	if cutVer >= TCaplusUpdateReqIncreaseValueInfoVersion {

		err = this.IncreaseValueInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusUpdateReq.IncreaseValueInfo unpack error\n" + err.Error())
		}

	} else {
		this.IncreaseValueInfo.Init()

	}
	return err
}

const (
	TCaplusUpdateResBaseVersion    uint32 = 1
	TCaplusUpdateResCurrentVersion uint32 = 109
)

// TCaplusUpdateRes
type TCaplusUpdateRes struct {
	Result int32 `tdr_field:"Result"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusUpdateRes() *TCaplusUpdateRes {
	obj := new(TCaplusUpdateRes)
	obj.Init()
	return obj
}

func (this *TCaplusUpdateRes) GetBaseVersion() uint32 {
	return TCaplusUpdateResBaseVersion
}

func (this *TCaplusUpdateRes) GetCurrentVersion() uint32 {
	return TCaplusUpdateResCurrentVersion
}

func (this *TCaplusUpdateRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusUpdateRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusUpdateRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusUpdateRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusUpdateResCurrentVersion {
		cutVer = TCaplusUpdateResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusUpdateResBaseVersion {
		return errors.New("TCaplusUpdateRes cut version must large than TCaplusUpdateResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusUpdateRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusUpdateRes.Flag pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusUpdateRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusUpdateRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusUpdateRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusUpdateRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusUpdateResCurrentVersion {
		cutVer = TCaplusUpdateResCurrentVersion
	}
	// check version
	if cutVer < TCaplusUpdateResBaseVersion {
		errors.New("TCaplusUpdateRes cut version must large than TCaplusUpdateResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusUpdateRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusUpdateRes.Flag unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusUpdateRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusIncreaseReqBaseVersion              uint32 = 1
	TCaplusIncreaseReqCurrentVersion           uint32 = 21
	TCaplusIncreaseReqAddableIncreaseVersion   uint32 = 9
	TCaplusIncreaseReqCheckVersiontTypeVersion uint32 = 13
)

// TCaplusIncreaseReq
type TCaplusIncreaseReq struct {
	Flag byte `tdr_field:"Flag"`

	AddableIncrease byte `tdr_field:"AddableIncrease"`

	ValueInfo *TCaplusUpdFieldSet `tdr_field:"ValueInfo"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusIncreaseReq() *TCaplusIncreaseReq {
	obj := new(TCaplusIncreaseReq)
	obj.Init()
	return obj
}

func (this *TCaplusIncreaseReq) GetBaseVersion() uint32 {
	return TCaplusIncreaseReqBaseVersion
}

func (this *TCaplusIncreaseReq) GetCurrentVersion() uint32 {
	return TCaplusIncreaseReqCurrentVersion
}

func (this *TCaplusIncreaseReq) Init() {

	this.AddableIncrease = 0

	this.ValueInfo = NewTCaplusUpdFieldSet()

	this.CheckVersiontType = 1

}

func (this *TCaplusIncreaseReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusIncreaseReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusIncreaseReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusIncreaseReqCurrentVersion {
		cutVer = TCaplusIncreaseReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusIncreaseReqBaseVersion {
		return errors.New("TCaplusIncreaseReq cut version must large than TCaplusIncreaseReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusIncreaseReq.Flag pack error\n" + err.Error())
	}

	if cutVer >= TCaplusIncreaseReqAddableIncreaseVersion {

		err = binary.Write(w, binary.BigEndian, this.AddableIncrease)
		if err != nil {
			return errors.New("TCaplusIncreaseReq.AddableIncrease pack error\n" + err.Error())
		}

	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusIncreaseReq.ValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusIncreaseReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusIncreaseReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusIncreaseReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusIncreaseReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusIncreaseReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusIncreaseReqCurrentVersion {
		cutVer = TCaplusIncreaseReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusIncreaseReqBaseVersion {
		errors.New("TCaplusIncreaseReq cut version must large than TCaplusIncreaseReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusIncreaseReq.Flag unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusIncreaseReqAddableIncreaseVersion {

		err = binary.Read(r, binary.BigEndian, &this.AddableIncrease)
		if err != nil {
			return errors.New("TCaplusIncreaseReq.AddableIncrease unpack error\n" + err.Error())
		}

	} else {
		this.AddableIncrease = 0

	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusIncreaseReq.ValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusIncreaseReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusIncreaseReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusIncreaseResBaseVersion            uint32 = 1
	TCaplusIncreaseResCurrentVersion         uint32 = 109
	TCaplusIncreaseResAddableIncreaseVersion uint32 = 9
)

// TCaplusIncreaseRes
type TCaplusIncreaseRes struct {
	Result int32 `tdr_field:"Result"`

	Flag byte `tdr_field:"Flag"`

	AddableIncrease byte `tdr_field:"AddableIncrease"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusIncreaseRes() *TCaplusIncreaseRes {
	obj := new(TCaplusIncreaseRes)
	obj.Init()
	return obj
}

func (this *TCaplusIncreaseRes) GetBaseVersion() uint32 {
	return TCaplusIncreaseResBaseVersion
}

func (this *TCaplusIncreaseRes) GetCurrentVersion() uint32 {
	return TCaplusIncreaseResCurrentVersion
}

func (this *TCaplusIncreaseRes) Init() {

	this.AddableIncrease = 0

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusIncreaseRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusIncreaseRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusIncreaseRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusIncreaseResCurrentVersion {
		cutVer = TCaplusIncreaseResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusIncreaseResBaseVersion {
		return errors.New("TCaplusIncreaseRes cut version must large than TCaplusIncreaseResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusIncreaseRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusIncreaseRes.Flag pack error\n" + err.Error())
	}

	if cutVer >= TCaplusIncreaseResAddableIncreaseVersion {

		err = binary.Write(w, binary.BigEndian, this.AddableIncrease)
		if err != nil {
			return errors.New("TCaplusIncreaseRes.AddableIncrease pack error\n" + err.Error())
		}

	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusIncreaseRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusIncreaseRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusIncreaseRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusIncreaseRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusIncreaseResCurrentVersion {
		cutVer = TCaplusIncreaseResCurrentVersion
	}
	// check version
	if cutVer < TCaplusIncreaseResBaseVersion {
		errors.New("TCaplusIncreaseRes cut version must large than TCaplusIncreaseResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusIncreaseRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusIncreaseRes.Flag unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusIncreaseResAddableIncreaseVersion {

		err = binary.Read(r, binary.BigEndian, &this.AddableIncrease)
		if err != nil {
			return errors.New("TCaplusIncreaseRes.AddableIncrease unpack error\n" + err.Error())
		}

	} else {
		this.AddableIncrease = 0

	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusIncreaseRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetReqBaseVersion       uint32 = 1
	TCaplusGetReqCurrentVersion    uint32 = 109
	TCaplusGetReqExpireTimeVersion uint32 = 20
)

// TCaplusGetReq
type TCaplusGetReq struct {
	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	ExpireTime uint32 `tdr_field:"ExpireTime"`
}

func NewTCaplusGetReq() *TCaplusGetReq {
	obj := new(TCaplusGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetReq) GetBaseVersion() uint32 {
	return TCaplusGetReqBaseVersion
}

func (this *TCaplusGetReq) GetCurrentVersion() uint32 {
	return TCaplusGetReqCurrentVersion
}

func (this *TCaplusGetReq) Init() {
	this.ValueInfo = NewTCaplusValueSet_()

	this.ExpireTime = 0

}

func (this *TCaplusGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetReqCurrentVersion {
		cutVer = TCaplusGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetReqBaseVersion {
		return errors.New("TCaplusGetReq cut version must large than TCaplusGetReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetReq.ValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetReqExpireTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.ExpireTime)
		if err != nil {
			return errors.New("TCaplusGetReq.ExpireTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetReqCurrentVersion {
		cutVer = TCaplusGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetReqBaseVersion {
		errors.New("TCaplusGetReq cut version must large than TCaplusGetReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetReq.ValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetReqExpireTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ExpireTime)
		if err != nil {
			return errors.New("TCaplusGetReq.ExpireTime unpack error\n" + err.Error())
		}

	} else {
		this.ExpireTime = 0

	}
	return err
}

const (
	TCaplusGetResBaseVersion           uint32 = 1
	TCaplusGetResCurrentVersion        uint32 = 109
	TCaplusGetResLastAccessTimeVersion uint32 = 13
)

// TCaplusGetRes
type TCaplusGetRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusGetRes() *TCaplusGetRes {
	obj := new(TCaplusGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetRes) GetBaseVersion() uint32 {
	return TCaplusGetResBaseVersion
}

func (this *TCaplusGetRes) GetCurrentVersion() uint32 {
	return TCaplusGetResCurrentVersion
}

func (this *TCaplusGetRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetResCurrentVersion {
		cutVer = TCaplusGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetResBaseVersion {
		return errors.New("TCaplusGetRes cut version must large than TCaplusGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusGetRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetRes.ResultInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetResLastAccessTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusGetRes.LastAccessTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetResCurrentVersion {
		cutVer = TCaplusGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetResBaseVersion {
		errors.New("TCaplusGetRes cut version must large than TCaplusGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusGetRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetRes.ResultInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetResLastAccessTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusGetRes.LastAccessTime unpack error\n" + err.Error())
		}

	}
	return err
}

const (
	TCaplusSysGetReqBaseVersion    uint32 = 53
	TCaplusSysGetReqCurrentVersion uint32 = 109
)

// TCaplusSysGetReq
type TCaplusSysGetReq struct {
	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	ExpireTime uint32 `tdr_field:"ExpireTime"`
}

func NewTCaplusSysGetReq() *TCaplusSysGetReq {
	obj := new(TCaplusSysGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysGetReq) GetBaseVersion() uint32 {
	return TCaplusSysGetReqBaseVersion
}

func (this *TCaplusSysGetReq) GetCurrentVersion() uint32 {
	return TCaplusSysGetReqCurrentVersion
}

func (this *TCaplusSysGetReq) Init() {
	this.ValueInfo = NewTCaplusValueSet_()

	this.ExpireTime = 0

}

func (this *TCaplusSysGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysGetReqCurrentVersion {
		cutVer = TCaplusSysGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysGetReqBaseVersion {
		return errors.New("TCaplusSysGetReq cut version must large than TCaplusSysGetReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysGetReq.ValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ExpireTime)
	if err != nil {
		return errors.New("TCaplusSysGetReq.ExpireTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysGetReqCurrentVersion {
		cutVer = TCaplusSysGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysGetReqBaseVersion {
		errors.New("TCaplusSysGetReq cut version must large than TCaplusSysGetReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysGetReq.ValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ExpireTime)
	if err != nil {
		return errors.New("TCaplusSysGetReq.ExpireTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysGetResBaseVersion    uint32 = 53
	TCaplusSysGetResCurrentVersion uint32 = 109
)

// TCaplusSysGetRes
type TCaplusSysGetRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusSysGetRes() *TCaplusSysGetRes {
	obj := new(TCaplusSysGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysGetRes) GetBaseVersion() uint32 {
	return TCaplusSysGetResBaseVersion
}

func (this *TCaplusSysGetRes) GetCurrentVersion() uint32 {
	return TCaplusSysGetResCurrentVersion
}

func (this *TCaplusSysGetRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusSysGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysGetResCurrentVersion {
		cutVer = TCaplusSysGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysGetResBaseVersion {
		return errors.New("TCaplusSysGetRes cut version must large than TCaplusSysGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysGetRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysGetRes.ResultInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysGetRes.LastAccessTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysGetResCurrentVersion {
		cutVer = TCaplusSysGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysGetResBaseVersion {
		errors.New("TCaplusSysGetRes cut version must large than TCaplusSysGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysGetRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysGetRes.ResultInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysGetRes.LastAccessTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusDeleteReqBaseVersion              uint32 = 1
	TCaplusDeleteReqCurrentVersion           uint32 = 108
	TCaplusDeleteReqFlagVersion              uint32 = 6
	TCaplusDeleteReqCheckVersiontTypeVersion uint32 = 108
)

// TCaplusDeleteReq
type TCaplusDeleteReq struct {
	Flag byte `tdr_field:"Flag"`

	Reserve int32 `tdr_field:"Reserve"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusDeleteReq() *TCaplusDeleteReq {
	obj := new(TCaplusDeleteReq)
	obj.Init()
	return obj
}

func (this *TCaplusDeleteReq) GetBaseVersion() uint32 {
	return TCaplusDeleteReqBaseVersion
}

func (this *TCaplusDeleteReq) GetCurrentVersion() uint32 {
	return TCaplusDeleteReqCurrentVersion
}

func (this *TCaplusDeleteReq) Init() {

	this.CheckVersiontType = 1

}

func (this *TCaplusDeleteReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusDeleteReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusDeleteReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusDeleteReqCurrentVersion {
		cutVer = TCaplusDeleteReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusDeleteReqBaseVersion {
		return errors.New("TCaplusDeleteReq cut version must large than TCaplusDeleteReqBaseVersion\n")
	}

	var err error
	if cutVer >= TCaplusDeleteReqFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusDeleteReq.Flag pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.Reserve)
	if err != nil {
		return errors.New("TCaplusDeleteReq.Reserve pack error\n" + err.Error())
	}

	if cutVer >= TCaplusDeleteReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusDeleteReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusDeleteReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusDeleteReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusDeleteReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusDeleteReqCurrentVersion {
		cutVer = TCaplusDeleteReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusDeleteReqBaseVersion {
		errors.New("TCaplusDeleteReq cut version must large than TCaplusDeleteReqBaseVersion\n")
	}

	if cutVer >= TCaplusDeleteReqFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusDeleteReq.Flag unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.Reserve)
	if err != nil {
		return errors.New("TCaplusDeleteReq.Reserve unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusDeleteReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusDeleteReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusDeleteResBaseVersion       uint32 = 1
	TCaplusDeleteResCurrentVersion    uint32 = 109
	TCaplusDeleteResFlagVersion       uint32 = 6
	TCaplusDeleteResResultInfoVersion uint32 = 6
)

// TCaplusDeleteRes
type TCaplusDeleteRes struct {
	Result int32 `tdr_field:"Result"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusDeleteRes() *TCaplusDeleteRes {
	obj := new(TCaplusDeleteRes)
	obj.Init()
	return obj
}

func (this *TCaplusDeleteRes) GetBaseVersion() uint32 {
	return TCaplusDeleteResBaseVersion
}

func (this *TCaplusDeleteRes) GetCurrentVersion() uint32 {
	return TCaplusDeleteResCurrentVersion
}

func (this *TCaplusDeleteRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusDeleteRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusDeleteRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusDeleteRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusDeleteResCurrentVersion {
		cutVer = TCaplusDeleteResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusDeleteResBaseVersion {
		return errors.New("TCaplusDeleteRes cut version must large than TCaplusDeleteResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusDeleteRes.Result pack error\n" + err.Error())
	}

	if cutVer >= TCaplusDeleteResFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusDeleteRes.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusDeleteResResultInfoVersion {

		err = this.ResultInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusDeleteRes.ResultInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusDeleteRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusDeleteRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusDeleteRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusDeleteResCurrentVersion {
		cutVer = TCaplusDeleteResCurrentVersion
	}
	// check version
	if cutVer < TCaplusDeleteResBaseVersion {
		errors.New("TCaplusDeleteRes cut version must large than TCaplusDeleteResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusDeleteRes.Result unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusDeleteResFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusDeleteRes.Flag unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusDeleteResResultInfoVersion {

		err = this.ResultInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusDeleteRes.ResultInfo unpack error\n" + err.Error())
		}

	} else {
		this.ResultInfo.Init()

	}
	return err
}

const (
	TCaplusSysDeleteReqBaseVersion              uint32 = 53
	TCaplusSysDeleteReqCurrentVersion           uint32 = 108
	TCaplusSysDeleteReqCheckVersiontTypeVersion uint32 = 108
)

// TCaplusSysDeleteReq
type TCaplusSysDeleteReq struct {
	Flag byte `tdr_field:"Flag"`

	Reserve int32 `tdr_field:"Reserve"`

	Timestamp int32 `tdr_field:"Timestamp"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusSysDeleteReq() *TCaplusSysDeleteReq {
	obj := new(TCaplusSysDeleteReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysDeleteReq) GetBaseVersion() uint32 {
	return TCaplusSysDeleteReqBaseVersion
}

func (this *TCaplusSysDeleteReq) GetCurrentVersion() uint32 {
	return TCaplusSysDeleteReqCurrentVersion
}

func (this *TCaplusSysDeleteReq) Init() {

	this.CheckVersiontType = 1

}

func (this *TCaplusSysDeleteReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysDeleteReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysDeleteReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysDeleteReqCurrentVersion {
		cutVer = TCaplusSysDeleteReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysDeleteReqBaseVersion {
		return errors.New("TCaplusSysDeleteReq cut version must large than TCaplusSysDeleteReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusSysDeleteReq.Flag pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Reserve)
	if err != nil {
		return errors.New("TCaplusSysDeleteReq.Reserve pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Timestamp)
	if err != nil {
		return errors.New("TCaplusSysDeleteReq.Timestamp pack error\n" + err.Error())
	}

	if cutVer >= TCaplusSysDeleteReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusSysDeleteReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusSysDeleteReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysDeleteReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysDeleteReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysDeleteReqCurrentVersion {
		cutVer = TCaplusSysDeleteReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysDeleteReqBaseVersion {
		errors.New("TCaplusSysDeleteReq cut version must large than TCaplusSysDeleteReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusSysDeleteReq.Flag unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Reserve)
	if err != nil {
		return errors.New("TCaplusSysDeleteReq.Reserve unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Timestamp)
	if err != nil {
		return errors.New("TCaplusSysDeleteReq.Timestamp unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusSysDeleteReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusSysDeleteReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusSysDeleteResBaseVersion    uint32 = 53
	TCaplusSysDeleteResCurrentVersion uint32 = 109
)

// TCaplusSysDeleteRes
type TCaplusSysDeleteRes struct {
	Result int32 `tdr_field:"Result"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusSysDeleteRes() *TCaplusSysDeleteRes {
	obj := new(TCaplusSysDeleteRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysDeleteRes) GetBaseVersion() uint32 {
	return TCaplusSysDeleteResBaseVersion
}

func (this *TCaplusSysDeleteRes) GetCurrentVersion() uint32 {
	return TCaplusSysDeleteResCurrentVersion
}

func (this *TCaplusSysDeleteRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusSysDeleteRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysDeleteRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysDeleteRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysDeleteResCurrentVersion {
		cutVer = TCaplusSysDeleteResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysDeleteResBaseVersion {
		return errors.New("TCaplusSysDeleteRes cut version must large than TCaplusSysDeleteResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysDeleteRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusSysDeleteRes.Flag pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysDeleteRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysDeleteRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysDeleteRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysDeleteRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysDeleteResCurrentVersion {
		cutVer = TCaplusSysDeleteResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysDeleteResBaseVersion {
		errors.New("TCaplusSysDeleteRes cut version must large than TCaplusSysDeleteResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysDeleteRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusSysDeleteRes.Flag unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysDeleteRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	SplitTableKeyBuffBaseVersion    uint32 = 91
	SplitTableKeyBuffCurrentVersion uint32 = 91
)

// SplitTableKeyBuff
type SplitTableKeyBuff struct {
	SplitTableKeyBuffLen uint32 `tdr_field:"SplitTableKeyBuffLen"`

	SplitTableKeyBuff []byte `tdr_field:"SplitTableKeyBuff" tdr_count:"1024" tdr_refer:"SplitTableKeyBuffLen"`
}

func NewSplitTableKeyBuff() *SplitTableKeyBuff {
	obj := new(SplitTableKeyBuff)
	obj.Init()
	return obj
}

func (this *SplitTableKeyBuff) GetBaseVersion() uint32 {
	return SplitTableKeyBuffBaseVersion
}

func (this *SplitTableKeyBuff) GetCurrentVersion() uint32 {
	return SplitTableKeyBuffCurrentVersion
}

func (this *SplitTableKeyBuff) Init() {
	this.SplitTableKeyBuffLen = 0

}

func (this *SplitTableKeyBuff) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("SplitTableKeyBuff Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *SplitTableKeyBuff) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > SplitTableKeyBuffCurrentVersion {
		cutVer = SplitTableKeyBuffCurrentVersion
	}
	// check cut version
	if cutVer < SplitTableKeyBuffBaseVersion {
		return errors.New("SplitTableKeyBuff cut version must large than SplitTableKeyBuffBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.SplitTableKeyBuffLen)
	if err != nil {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuffLen pack error\n" + err.Error())
	}

	if this.SplitTableKeyBuffLen < 0 {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuff's refer SplitTableKeyBuffLen should >= 0")
	}
	if this.SplitTableKeyBuffLen > 1024 {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuff's refer SplitTableKeyBuffLen should <= count 1024")
	}
	if len(this.SplitTableKeyBuff) < int(this.SplitTableKeyBuffLen) {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuff's length should > SplitTableKeyBuffLen")
	}
	if this.SplitTableKeyBuffLen > 0 {
		referSplitTableKeyBuff := this.SplitTableKeyBuff[:this.SplitTableKeyBuffLen]
		err = binary.Write(w, binary.BigEndian, referSplitTableKeyBuff)
		if err != nil {
			return errors.New("SplitTableKeyBuff.SplitTableKeyBuff pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *SplitTableKeyBuff) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("SplitTableKeyBuff data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *SplitTableKeyBuff) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > SplitTableKeyBuffCurrentVersion {
		cutVer = SplitTableKeyBuffCurrentVersion
	}
	// check version
	if cutVer < SplitTableKeyBuffBaseVersion {
		errors.New("SplitTableKeyBuff cut version must large than SplitTableKeyBuffBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.SplitTableKeyBuffLen)
	if err != nil {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuffLen unpack error\n" + err.Error())
	}

	if this.SplitTableKeyBuffLen < 0 {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuff's refer SplitTableKeyBuffLen should >= 0")
	}
	if this.SplitTableKeyBuffLen > 1024 {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuff's refer SplitTableKeyBuffLen should <= count 1024")
	}

	if this.SplitTableKeyBuff == nil {
		this.SplitTableKeyBuff = make([]byte, int(this.SplitTableKeyBuffLen))
	}

	referSplitTableKeyBuff := this.SplitTableKeyBuff[:this.SplitTableKeyBuffLen]
	err = binary.Read(r, binary.BigEndian, referSplitTableKeyBuff)
	if err != nil {
		return errors.New("SplitTableKeyBuff.SplitTableKeyBuff pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusBatchGetReqBaseVersion               uint32 = 1
	TCaplusBatchGetReqCurrentVersion            uint32 = 91
	TCaplusBatchGetReqExpireTimeVersion         uint32 = 20
	TCaplusBatchGetReqSplitTableKeyBuffsVersion uint32 = 91
)

// TCaplusBatchGetReq
type TCaplusBatchGetReq struct {
	AllowMultiResponses byte `tdr_field:"AllowMultiResponses"`

	ExpireTime uint32 `tdr_field:"ExpireTime"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	KeyInfo []*TCaplusKeySet `tdr_field:"KeyInfo" tdr_count:"1024" tdr_refer:"RecordNum"`

	SplitTableKeyBuffs []*SplitTableKeyBuff `tdr_field:"SplitTableKeyBuffs" tdr_count:"1024" tdr_refer:"RecordNum"`

	ValueInfo *TCaplusNameSet `tdr_field:"ValueInfo"`
}

func NewTCaplusBatchGetReq() *TCaplusBatchGetReq {
	obj := new(TCaplusBatchGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusBatchGetReq) GetBaseVersion() uint32 {
	return TCaplusBatchGetReqBaseVersion
}

func (this *TCaplusBatchGetReq) GetCurrentVersion() uint32 {
	return TCaplusBatchGetReqCurrentVersion
}

func (this *TCaplusBatchGetReq) Init() {
	this.AllowMultiResponses = 0

	this.ExpireTime = 0

	this.RecordNum = 0

	this.ValueInfo = NewTCaplusNameSet()

}

func (this *TCaplusBatchGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusBatchGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusBatchGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusBatchGetReqCurrentVersion {
		cutVer = TCaplusBatchGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusBatchGetReqBaseVersion {
		return errors.New("TCaplusBatchGetReq cut version must large than TCaplusBatchGetReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusBatchGetReq.AllowMultiResponses pack error\n" + err.Error())
	}

	if cutVer >= TCaplusBatchGetReqExpireTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.ExpireTime)
		if err != nil {
			return errors.New("TCaplusBatchGetReq.ExpireTime pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusBatchGetReq.RecordNum pack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusBatchGetReq.KeyInfo's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusBatchGetReq.KeyInfo's refer RecordNum should <= count 1024")
	}
	if len(this.KeyInfo) < int(this.RecordNum) {
		return errors.New("TCaplusBatchGetReq.KeyInfo's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		for i := 0; i < int(this.RecordNum); i++ {
			err = this.KeyInfo[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusBatchGetReq.KeyInfo pack error\n" + err.Error())
			}

		}
	}

	if cutVer >= TCaplusBatchGetReqSplitTableKeyBuffsVersion {

		if this.RecordNum < 0 {
			return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs's refer RecordNum should >= 0")
		}
		if this.RecordNum > 1024 {
			return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs's refer RecordNum should <= count 1024")
		}
		if len(this.SplitTableKeyBuffs) < int(this.RecordNum) {
			return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs's length should > RecordNum")
		}
		if this.RecordNum > 0 {
			for i := 0; i < int(this.RecordNum); i++ {
				err = this.SplitTableKeyBuffs[i].PackTo(cutVer, w)
				if err != nil {
					return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs pack error\n" + err.Error())
				}

			}
		}

	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusBatchGetReq.ValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusBatchGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusBatchGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusBatchGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusBatchGetReqCurrentVersion {
		cutVer = TCaplusBatchGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusBatchGetReqBaseVersion {
		errors.New("TCaplusBatchGetReq cut version must large than TCaplusBatchGetReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusBatchGetReq.AllowMultiResponses unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusBatchGetReqExpireTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ExpireTime)
		if err != nil {
			return errors.New("TCaplusBatchGetReq.ExpireTime unpack error\n" + err.Error())
		}

	} else {
		this.ExpireTime = 0

	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusBatchGetReq.RecordNum unpack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusBatchGetReq.KeyInfo's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusBatchGetReq.KeyInfo's refer RecordNum should <= count 1024")
	}

	if this.KeyInfo == nil {
		this.KeyInfo = make([]*TCaplusKeySet, int(this.RecordNum))
		for i := 0; i < int(this.RecordNum); i++ {
			this.KeyInfo[i] = NewTCaplusKeySet()
		}
	}

	for i := 0; i < int(this.RecordNum); i++ {
		err = this.KeyInfo[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusBatchGetReq.KeyInfo unpack error\n" + err.Error())
		}

	}

	if cutVer >= TCaplusBatchGetReqSplitTableKeyBuffsVersion {

		if this.RecordNum < 0 {
			return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs's refer RecordNum should >= 0")
		}
		if this.RecordNum > 1024 {
			return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs's refer RecordNum should <= count 1024")
		}

		if this.SplitTableKeyBuffs == nil {
			this.SplitTableKeyBuffs = make([]*SplitTableKeyBuff, int(this.RecordNum))
			for i := 0; i < int(this.RecordNum); i++ {
				this.SplitTableKeyBuffs[i] = NewSplitTableKeyBuff()
			}
		}

		for i := 0; i < int(this.RecordNum); i++ {
			err = this.SplitTableKeyBuffs[i].UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusBatchGetReq.SplitTableKeyBuffs unpack error\n" + err.Error())
			}

		}

	} else {

	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusBatchGetReq.ValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusBatchGetResBaseVersion    uint32 = 1
	TCaplusBatchGetResCurrentVersion uint32 = 1
)

// TCaplusBatchGetRes
type TCaplusBatchGetRes struct {
	Result int32 `tdr_field:"Result"`

	TotalNum uint32 `tdr_field:"TotalNum"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	LeftNum uint32 `tdr_field:"LeftNum"`

	BatchValueLen int32 `tdr_field:"BatchValueLen"`

	RecordResult []int32 `tdr_field:"RecordResult" tdr_count:"1024" tdr_refer:"RecordNum"`

	BatchValueInfo []byte `tdr_field:"BatchValueInfo" tdr_count:"10300000" tdr_refer:"BatchValueLen"`
}

func NewTCaplusBatchGetRes() *TCaplusBatchGetRes {
	obj := new(TCaplusBatchGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusBatchGetRes) GetBaseVersion() uint32 {
	return TCaplusBatchGetResBaseVersion
}

func (this *TCaplusBatchGetRes) GetCurrentVersion() uint32 {
	return TCaplusBatchGetResCurrentVersion
}

func (this *TCaplusBatchGetRes) Init() {

	this.TotalNum = 0

	this.RecordNum = 0

	this.LeftNum = 0

	this.BatchValueLen = 0

}

func (this *TCaplusBatchGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusBatchGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusBatchGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusBatchGetResCurrentVersion {
		cutVer = TCaplusBatchGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusBatchGetResBaseVersion {
		return errors.New("TCaplusBatchGetRes cut version must large than TCaplusBatchGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalNum)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.TotalNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LeftNum)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.LeftNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.BatchValueLen pack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusBatchGetRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusBatchGetRes.RecordResult's refer RecordNum should <= count 1024")
	}
	if len(this.RecordResult) < int(this.RecordNum) {
		return errors.New("TCaplusBatchGetRes.RecordResult's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		referRecordResult := this.RecordResult[:this.RecordNum]
		err = binary.Write(w, binary.BigEndian, referRecordResult)
		if err != nil {
			return errors.New("TCaplusBatchGetRes.RecordResult pack error\n" + err.Error())
		}
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusBatchGetRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusBatchGetRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}
	if len(this.BatchValueInfo) < int(this.BatchValueLen) {
		return errors.New("TCaplusBatchGetRes.BatchValueInfo's length should > BatchValueLen")
	}
	if this.BatchValueLen > 0 {
		referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
		err = binary.Write(w, binary.BigEndian, referBatchValueInfo)
		if err != nil {
			return errors.New("TCaplusBatchGetRes.BatchValueInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusBatchGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusBatchGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusBatchGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusBatchGetResCurrentVersion {
		cutVer = TCaplusBatchGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusBatchGetResBaseVersion {
		errors.New("TCaplusBatchGetRes cut version must large than TCaplusBatchGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalNum)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.TotalNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LeftNum)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.LeftNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.BatchValueLen unpack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusBatchGetRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusBatchGetRes.RecordResult's refer RecordNum should <= count 1024")
	}

	if this.RecordResult == nil {
		this.RecordResult = make([]int32, int(this.RecordNum))
	}

	referRecordResult := this.RecordResult[:this.RecordNum]
	err = binary.Read(r, binary.BigEndian, referRecordResult)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.RecordResult pack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusBatchGetRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusBatchGetRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}

	if this.BatchValueInfo == nil {
		this.BatchValueInfo = make([]byte, int(this.BatchValueLen))
	}

	referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
	err = binary.Read(r, binary.BigEndian, referBatchValueInfo)
	if err != nil {
		return errors.New("TCaplusBatchGetRes.BatchValueInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusBatchGetByPartkeyReqBaseVersion               uint32 = 39
	TCaplusBatchGetByPartkeyReqCurrentVersion            uint32 = 91
	TCaplusBatchGetByPartkeyReqSplitTableKeyBuffsVersion uint32 = 91
)

// TCaplusBatchGetByPartkeyReq
type TCaplusBatchGetByPartkeyReq struct {
	AllowMultiResponses byte `tdr_field:"AllowMultiResponses"`

	PartkeyNum uint32 `tdr_field:"PartkeyNum"`

	KeyInfo []*TCaplusKeySet `tdr_field:"KeyInfo" tdr_count:"10" tdr_refer:"PartkeyNum"`

	SplitTableKeyBuffs []*SplitTableKeyBuff `tdr_field:"SplitTableKeyBuffs" tdr_count:"10" tdr_refer:"PartkeyNum"`

	ValueInfo *TCaplusNameSet `tdr_field:"ValueInfo"`
}

func NewTCaplusBatchGetByPartkeyReq() *TCaplusBatchGetByPartkeyReq {
	obj := new(TCaplusBatchGetByPartkeyReq)
	obj.Init()
	return obj
}

func (this *TCaplusBatchGetByPartkeyReq) GetBaseVersion() uint32 {
	return TCaplusBatchGetByPartkeyReqBaseVersion
}

func (this *TCaplusBatchGetByPartkeyReq) GetCurrentVersion() uint32 {
	return TCaplusBatchGetByPartkeyReqCurrentVersion
}

func (this *TCaplusBatchGetByPartkeyReq) Init() {
	this.AllowMultiResponses = 0

	this.PartkeyNum = 0

	this.ValueInfo = NewTCaplusNameSet()

}

func (this *TCaplusBatchGetByPartkeyReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusBatchGetByPartkeyReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusBatchGetByPartkeyReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusBatchGetByPartkeyReqCurrentVersion {
		cutVer = TCaplusBatchGetByPartkeyReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusBatchGetByPartkeyReqBaseVersion {
		return errors.New("TCaplusBatchGetByPartkeyReq cut version must large than TCaplusBatchGetByPartkeyReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyReq.AllowMultiResponses pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.PartkeyNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyReq.PartkeyNum pack error\n" + err.Error())
	}

	if this.PartkeyNum < 0 {
		return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo's refer PartkeyNum should >= 0")
	}
	if this.PartkeyNum > 10 {
		return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo's refer PartkeyNum should <= count 10")
	}
	if len(this.KeyInfo) < int(this.PartkeyNum) {
		return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo's length should > PartkeyNum")
	}
	if this.PartkeyNum > 0 {
		for i := 0; i < int(this.PartkeyNum); i++ {
			err = this.KeyInfo[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo pack error\n" + err.Error())
			}

		}
	}

	if cutVer >= TCaplusBatchGetByPartkeyReqSplitTableKeyBuffsVersion {

		if this.PartkeyNum < 0 {
			return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs's refer PartkeyNum should >= 0")
		}
		if this.PartkeyNum > 10 {
			return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs's refer PartkeyNum should <= count 10")
		}
		if len(this.SplitTableKeyBuffs) < int(this.PartkeyNum) {
			return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs's length should > PartkeyNum")
		}
		if this.PartkeyNum > 0 {
			for i := 0; i < int(this.PartkeyNum); i++ {
				err = this.SplitTableKeyBuffs[i].PackTo(cutVer, w)
				if err != nil {
					return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs pack error\n" + err.Error())
				}

			}
		}

	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyReq.ValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusBatchGetByPartkeyReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusBatchGetByPartkeyReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusBatchGetByPartkeyReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusBatchGetByPartkeyReqCurrentVersion {
		cutVer = TCaplusBatchGetByPartkeyReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusBatchGetByPartkeyReqBaseVersion {
		errors.New("TCaplusBatchGetByPartkeyReq cut version must large than TCaplusBatchGetByPartkeyReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyReq.AllowMultiResponses unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.PartkeyNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyReq.PartkeyNum unpack error\n" + err.Error())
	}

	if this.PartkeyNum < 0 {
		return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo's refer PartkeyNum should >= 0")
	}
	if this.PartkeyNum > 10 {
		return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo's refer PartkeyNum should <= count 10")
	}

	if this.KeyInfo == nil {
		this.KeyInfo = make([]*TCaplusKeySet, int(this.PartkeyNum))
		for i := 0; i < int(this.PartkeyNum); i++ {
			this.KeyInfo[i] = NewTCaplusKeySet()
		}
	}

	for i := 0; i < int(this.PartkeyNum); i++ {
		err = this.KeyInfo[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusBatchGetByPartkeyReq.KeyInfo unpack error\n" + err.Error())
		}

	}

	if cutVer >= TCaplusBatchGetByPartkeyReqSplitTableKeyBuffsVersion {

		if this.PartkeyNum < 0 {
			return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs's refer PartkeyNum should >= 0")
		}
		if this.PartkeyNum > 10 {
			return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs's refer PartkeyNum should <= count 10")
		}

		if this.SplitTableKeyBuffs == nil {
			this.SplitTableKeyBuffs = make([]*SplitTableKeyBuff, int(this.PartkeyNum))
			for i := 0; i < int(this.PartkeyNum); i++ {
				this.SplitTableKeyBuffs[i] = NewSplitTableKeyBuff()
			}
		}

		for i := 0; i < int(this.PartkeyNum); i++ {
			err = this.SplitTableKeyBuffs[i].UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusBatchGetByPartkeyReq.SplitTableKeyBuffs unpack error\n" + err.Error())
			}

		}

	} else {

	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyReq.ValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusBatchGetByPartkeyResBaseVersion    uint32 = 39
	TCaplusBatchGetByPartkeyResCurrentVersion uint32 = 39
)

// TCaplusBatchGetByPartkeyRes
type TCaplusBatchGetByPartkeyRes struct {
	Result int32 `tdr_field:"Result"`

	TotalNum uint32 `tdr_field:"TotalNum"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	LeftNum uint32 `tdr_field:"LeftNum"`

	BatchValueLen int32 `tdr_field:"BatchValueLen"`

	RecordResult []int32 `tdr_field:"RecordResult" tdr_count:"1024" tdr_refer:"RecordNum"`

	BatchValueInfo []byte `tdr_field:"BatchValueInfo" tdr_count:"10300000" tdr_refer:"BatchValueLen"`
}

func NewTCaplusBatchGetByPartkeyRes() *TCaplusBatchGetByPartkeyRes {
	obj := new(TCaplusBatchGetByPartkeyRes)
	obj.Init()
	return obj
}

func (this *TCaplusBatchGetByPartkeyRes) GetBaseVersion() uint32 {
	return TCaplusBatchGetByPartkeyResBaseVersion
}

func (this *TCaplusBatchGetByPartkeyRes) GetCurrentVersion() uint32 {
	return TCaplusBatchGetByPartkeyResCurrentVersion
}

func (this *TCaplusBatchGetByPartkeyRes) Init() {

	this.TotalNum = 0

	this.RecordNum = 0

	this.LeftNum = 0

	this.BatchValueLen = 0

}

func (this *TCaplusBatchGetByPartkeyRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusBatchGetByPartkeyRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusBatchGetByPartkeyRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusBatchGetByPartkeyResCurrentVersion {
		cutVer = TCaplusBatchGetByPartkeyResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusBatchGetByPartkeyResBaseVersion {
		return errors.New("TCaplusBatchGetByPartkeyRes cut version must large than TCaplusBatchGetByPartkeyResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.TotalNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LeftNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.LeftNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueLen pack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult's refer RecordNum should <= count 1024")
	}
	if len(this.RecordResult) < int(this.RecordNum) {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		referRecordResult := this.RecordResult[:this.RecordNum]
		err = binary.Write(w, binary.BigEndian, referRecordResult)
		if err != nil {
			return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult pack error\n" + err.Error())
		}
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}
	if len(this.BatchValueInfo) < int(this.BatchValueLen) {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo's length should > BatchValueLen")
	}
	if this.BatchValueLen > 0 {
		referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
		err = binary.Write(w, binary.BigEndian, referBatchValueInfo)
		if err != nil {
			return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusBatchGetByPartkeyRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusBatchGetByPartkeyRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusBatchGetByPartkeyRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusBatchGetByPartkeyResCurrentVersion {
		cutVer = TCaplusBatchGetByPartkeyResCurrentVersion
	}
	// check version
	if cutVer < TCaplusBatchGetByPartkeyResBaseVersion {
		errors.New("TCaplusBatchGetByPartkeyRes cut version must large than TCaplusBatchGetByPartkeyResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.TotalNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LeftNum)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.LeftNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueLen unpack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult's refer RecordNum should <= count 1024")
	}

	if this.RecordResult == nil {
		this.RecordResult = make([]int32, int(this.RecordNum))
	}

	referRecordResult := this.RecordResult[:this.RecordNum]
	err = binary.Read(r, binary.BigEndian, referRecordResult)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.RecordResult pack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}

	if this.BatchValueInfo == nil {
		this.BatchValueInfo = make([]byte, int(this.BatchValueLen))
	}

	referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
	err = binary.Read(r, binary.BigEndian, referBatchValueInfo)
	if err != nil {
		return errors.New("TCaplusBatchGetByPartkeyRes.BatchValueInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufBatchFieldGetReqBaseVersion    uint32 = 102
	TCaplusProtobufBatchFieldGetReqCurrentVersion uint32 = 109
)

// TCaplusProtobufBatchFieldGetReq
type TCaplusProtobufBatchFieldGetReq struct {
	RecordNum uint32 `tdr_field:"RecordNum"`

	KeyInfo []*TCaplusKeySet `tdr_field:"KeyInfo" tdr_count:"1024" tdr_refer:"RecordNum"`

	SplitTableKeyBuffs []*SplitTableKeyBuff `tdr_field:"SplitTableKeyBuffs" tdr_count:"1024" tdr_refer:"RecordNum"`

	ValueInfo *ProtobufValueSet_ `tdr_field:"ValueInfo"`
}

func NewTCaplusProtobufBatchFieldGetReq() *TCaplusProtobufBatchFieldGetReq {
	obj := new(TCaplusProtobufBatchFieldGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufBatchFieldGetReq) GetBaseVersion() uint32 {
	return TCaplusProtobufBatchFieldGetReqBaseVersion
}

func (this *TCaplusProtobufBatchFieldGetReq) GetCurrentVersion() uint32 {
	return TCaplusProtobufBatchFieldGetReqCurrentVersion
}

func (this *TCaplusProtobufBatchFieldGetReq) Init() {
	this.RecordNum = 0

	this.ValueInfo = NewProtobufValueSet_()

}

func (this *TCaplusProtobufBatchFieldGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufBatchFieldGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufBatchFieldGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufBatchFieldGetReqCurrentVersion {
		cutVer = TCaplusProtobufBatchFieldGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufBatchFieldGetReqBaseVersion {
		return errors.New("TCaplusProtobufBatchFieldGetReq cut version must large than TCaplusProtobufBatchFieldGetReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetReq.RecordNum pack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo's refer RecordNum should <= count 1024")
	}
	if len(this.KeyInfo) < int(this.RecordNum) {
		return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		for i := 0; i < int(this.RecordNum); i++ {
			err = this.KeyInfo[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo pack error\n" + err.Error())
			}

		}
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs's refer RecordNum should <= count 1024")
	}
	if len(this.SplitTableKeyBuffs) < int(this.RecordNum) {
		return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		for i := 0; i < int(this.RecordNum); i++ {
			err = this.SplitTableKeyBuffs[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs pack error\n" + err.Error())
			}

		}
	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetReq.ValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufBatchFieldGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufBatchFieldGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufBatchFieldGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufBatchFieldGetReqCurrentVersion {
		cutVer = TCaplusProtobufBatchFieldGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufBatchFieldGetReqBaseVersion {
		errors.New("TCaplusProtobufBatchFieldGetReq cut version must large than TCaplusProtobufBatchFieldGetReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetReq.RecordNum unpack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo's refer RecordNum should <= count 1024")
	}

	if this.KeyInfo == nil {
		this.KeyInfo = make([]*TCaplusKeySet, int(this.RecordNum))
		for i := 0; i < int(this.RecordNum); i++ {
			this.KeyInfo[i] = NewTCaplusKeySet()
		}
	}

	for i := 0; i < int(this.RecordNum); i++ {
		err = this.KeyInfo[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusProtobufBatchFieldGetReq.KeyInfo unpack error\n" + err.Error())
		}

	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs's refer RecordNum should <= count 1024")
	}

	if this.SplitTableKeyBuffs == nil {
		this.SplitTableKeyBuffs = make([]*SplitTableKeyBuff, int(this.RecordNum))
		for i := 0; i < int(this.RecordNum); i++ {
			this.SplitTableKeyBuffs[i] = NewSplitTableKeyBuff()
		}
	}

	for i := 0; i < int(this.RecordNum); i++ {
		err = this.SplitTableKeyBuffs[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusProtobufBatchFieldGetReq.SplitTableKeyBuffs unpack error\n" + err.Error())
		}

	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetReq.ValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufBatchFieldGetResBaseVersion    uint32 = 102
	TCaplusProtobufBatchFieldGetResCurrentVersion uint32 = 102
)

// TCaplusProtobufBatchFieldGetRes
type TCaplusProtobufBatchFieldGetRes struct {
	Result int32 `tdr_field:"Result"`

	TotalNum uint32 `tdr_field:"TotalNum"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	LeftNum uint32 `tdr_field:"LeftNum"`

	RecordResult []int32 `tdr_field:"RecordResult" tdr_count:"1024" tdr_refer:"RecordNum"`

	BatchValueLen int32 `tdr_field:"BatchValueLen"`

	BatchValueInfo []byte `tdr_field:"BatchValueInfo" tdr_count:"10300000" tdr_refer:"BatchValueLen"`
}

func NewTCaplusProtobufBatchFieldGetRes() *TCaplusProtobufBatchFieldGetRes {
	obj := new(TCaplusProtobufBatchFieldGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufBatchFieldGetRes) GetBaseVersion() uint32 {
	return TCaplusProtobufBatchFieldGetResBaseVersion
}

func (this *TCaplusProtobufBatchFieldGetRes) GetCurrentVersion() uint32 {
	return TCaplusProtobufBatchFieldGetResCurrentVersion
}

func (this *TCaplusProtobufBatchFieldGetRes) Init() {

	this.TotalNum = 0

	this.RecordNum = 0

	this.LeftNum = 0

	this.BatchValueLen = 0

}

func (this *TCaplusProtobufBatchFieldGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufBatchFieldGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufBatchFieldGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufBatchFieldGetResCurrentVersion {
		cutVer = TCaplusProtobufBatchFieldGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufBatchFieldGetResBaseVersion {
		return errors.New("TCaplusProtobufBatchFieldGetRes cut version must large than TCaplusProtobufBatchFieldGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.TotalNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LeftNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.LeftNum pack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult's refer RecordNum should <= count 1024")
	}
	if len(this.RecordResult) < int(this.RecordNum) {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		referRecordResult := this.RecordResult[:this.RecordNum]
		err = binary.Write(w, binary.BigEndian, referRecordResult)
		if err != nil {
			return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueLen pack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}
	if len(this.BatchValueInfo) < int(this.BatchValueLen) {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo's length should > BatchValueLen")
	}
	if this.BatchValueLen > 0 {
		referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
		err = binary.Write(w, binary.BigEndian, referBatchValueInfo)
		if err != nil {
			return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusProtobufBatchFieldGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufBatchFieldGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufBatchFieldGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufBatchFieldGetResCurrentVersion {
		cutVer = TCaplusProtobufBatchFieldGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufBatchFieldGetResBaseVersion {
		errors.New("TCaplusProtobufBatchFieldGetRes cut version must large than TCaplusProtobufBatchFieldGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.TotalNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LeftNum)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.LeftNum unpack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult's refer RecordNum should <= count 1024")
	}

	if this.RecordResult == nil {
		this.RecordResult = make([]int32, int(this.RecordNum))
	}

	referRecordResult := this.RecordResult[:this.RecordNum]
	err = binary.Read(r, binary.BigEndian, referRecordResult)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.RecordResult pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueLen unpack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}

	if this.BatchValueInfo == nil {
		this.BatchValueInfo = make([]byte, int(this.BatchValueLen))
	}

	referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
	err = binary.Read(r, binary.BigEndian, referBatchValueInfo)
	if err != nil {
		return errors.New("TCaplusProtobufBatchFieldGetRes.BatchValueInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListGetAllReqBaseVersion    uint32 = 1
	TCaplusListGetAllReqCurrentVersion uint32 = 1
)

// TCaplusListGetAllReq
type TCaplusListGetAllReq struct {
	AllowMultiResponses byte `tdr_field:"AllowMultiResponses"`

	ElementNum int32 `tdr_field:"ElementNum"`

	StartSubscript int32 `tdr_field:"StartSubscript"`

	ElementValueNames *TCaplusNameSet `tdr_field:"ElementValueNames"`
}

func NewTCaplusListGetAllReq() *TCaplusListGetAllReq {
	obj := new(TCaplusListGetAllReq)
	obj.Init()
	return obj
}

func (this *TCaplusListGetAllReq) GetBaseVersion() uint32 {
	return TCaplusListGetAllReqBaseVersion
}

func (this *TCaplusListGetAllReq) GetCurrentVersion() uint32 {
	return TCaplusListGetAllReqCurrentVersion
}

func (this *TCaplusListGetAllReq) Init() {
	this.AllowMultiResponses = 0

	this.ElementNum = -1

	this.StartSubscript = 0

	this.ElementValueNames = NewTCaplusNameSet()

}

func (this *TCaplusListGetAllReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListGetAllReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListGetAllReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListGetAllReqCurrentVersion {
		cutVer = TCaplusListGetAllReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListGetAllReqBaseVersion {
		return errors.New("TCaplusListGetAllReq cut version must large than TCaplusListGetAllReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.AllowMultiResponses pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementNum)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.ElementNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.StartSubscript)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.StartSubscript pack error\n" + err.Error())
	}

	err = this.ElementValueNames.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.ElementValueNames pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListGetAllReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListGetAllReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListGetAllReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListGetAllReqCurrentVersion {
		cutVer = TCaplusListGetAllReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListGetAllReqBaseVersion {
		errors.New("TCaplusListGetAllReq cut version must large than TCaplusListGetAllReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.AllowMultiResponses unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementNum)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.ElementNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.StartSubscript)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.StartSubscript unpack error\n" + err.Error())
	}

	err = this.ElementValueNames.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListGetAllReq.ElementValueNames unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListGetAllResBaseVersion           uint32 = 1
	TCaplusListGetAllResCurrentVersion        uint32 = 113
	TCaplusListGetAllResBiggestIdxVersion     uint32 = 8
	TCaplusListGetAllResEmptyIndexFlagVersion uint32 = 113
)

// TCaplusListGetAllRes
type TCaplusListGetAllRes struct {
	Result int32 `tdr_field:"Result"`

	IsCompleteFlag int32 `tdr_field:"IsCompleteFlag"`

	TotalElementNumOnServer uint32 `tdr_field:"TotalElementNumOnServer"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`

	BiggestIdx uint32 `tdr_field:"BiggestIdx"`

	EmptyIndexFlag int32 `tdr_field:"EmptyIndexFlag"`
}

func NewTCaplusListGetAllRes() *TCaplusListGetAllRes {
	obj := new(TCaplusListGetAllRes)
	obj.Init()
	return obj
}

func (this *TCaplusListGetAllRes) GetBaseVersion() uint32 {
	return TCaplusListGetAllResBaseVersion
}

func (this *TCaplusListGetAllRes) GetCurrentVersion() uint32 {
	return TCaplusListGetAllResCurrentVersion
}

func (this *TCaplusListGetAllRes) Init() {

	this.IsCompleteFlag = 1

	this.ResultInfo = NewTCaplusListElementSet()

	this.EmptyIndexFlag = 0

}

func (this *TCaplusListGetAllRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListGetAllRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListGetAllRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListGetAllResCurrentVersion {
		cutVer = TCaplusListGetAllResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListGetAllResBaseVersion {
		return errors.New("TCaplusListGetAllRes cut version must large than TCaplusListGetAllResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.IsCompleteFlag pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalElementNumOnServer)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.TotalElementNumOnServer pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.ResultInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListGetAllResBiggestIdxVersion {

		err = binary.Write(w, binary.BigEndian, this.BiggestIdx)
		if err != nil {
			return errors.New("TCaplusListGetAllRes.BiggestIdx pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListGetAllResEmptyIndexFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.EmptyIndexFlag)
		if err != nil {
			return errors.New("TCaplusListGetAllRes.EmptyIndexFlag pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListGetAllRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListGetAllRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListGetAllRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListGetAllResCurrentVersion {
		cutVer = TCaplusListGetAllResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListGetAllResBaseVersion {
		errors.New("TCaplusListGetAllRes cut version must large than TCaplusListGetAllResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.IsCompleteFlag unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalElementNumOnServer)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.TotalElementNumOnServer unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListGetAllRes.ResultInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListGetAllResBiggestIdxVersion {

		err = binary.Read(r, binary.BigEndian, &this.BiggestIdx)
		if err != nil {
			return errors.New("TCaplusListGetAllRes.BiggestIdx unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListGetAllResEmptyIndexFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.EmptyIndexFlag)
		if err != nil {
			return errors.New("TCaplusListGetAllRes.EmptyIndexFlag unpack error\n" + err.Error())
		}

	} else {
		this.EmptyIndexFlag = 0

	}
	return err
}

const (
	TCaplusListDeleteAllReqBaseVersion              uint32 = 1
	TCaplusListDeleteAllReqCurrentVersion           uint32 = 108
	TCaplusListDeleteAllReqCheckVersiontTypeVersion uint32 = 108
)

// TCaplusListDeleteAllReq
type TCaplusListDeleteAllReq struct {
	Reserve int32 `tdr_field:"Reserve"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusListDeleteAllReq() *TCaplusListDeleteAllReq {
	obj := new(TCaplusListDeleteAllReq)
	obj.Init()
	return obj
}

func (this *TCaplusListDeleteAllReq) GetBaseVersion() uint32 {
	return TCaplusListDeleteAllReqBaseVersion
}

func (this *TCaplusListDeleteAllReq) GetCurrentVersion() uint32 {
	return TCaplusListDeleteAllReqCurrentVersion
}

func (this *TCaplusListDeleteAllReq) Init() {

	this.CheckVersiontType = 1

}

func (this *TCaplusListDeleteAllReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListDeleteAllReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListDeleteAllReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListDeleteAllReqCurrentVersion {
		cutVer = TCaplusListDeleteAllReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListDeleteAllReqBaseVersion {
		return errors.New("TCaplusListDeleteAllReq cut version must large than TCaplusListDeleteAllReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Reserve)
	if err != nil {
		return errors.New("TCaplusListDeleteAllReq.Reserve pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteAllReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListDeleteAllReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListDeleteAllReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListDeleteAllReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListDeleteAllReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListDeleteAllReqCurrentVersion {
		cutVer = TCaplusListDeleteAllReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListDeleteAllReqBaseVersion {
		errors.New("TCaplusListDeleteAllReq cut version must large than TCaplusListDeleteAllReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Reserve)
	if err != nil {
		return errors.New("TCaplusListDeleteAllReq.Reserve unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteAllReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListDeleteAllReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusListDeleteAllResBaseVersion    uint32 = 1
	TCaplusListDeleteAllResCurrentVersion uint32 = 1
)

// TCaplusListDeleteAllRes
type TCaplusListDeleteAllRes struct {
	Result int32 `tdr_field:"Result"`

	AffectedElementNum int32 `tdr_field:"AffectedElementNum"`
}

func NewTCaplusListDeleteAllRes() *TCaplusListDeleteAllRes {
	obj := new(TCaplusListDeleteAllRes)
	obj.Init()
	return obj
}

func (this *TCaplusListDeleteAllRes) GetBaseVersion() uint32 {
	return TCaplusListDeleteAllResBaseVersion
}

func (this *TCaplusListDeleteAllRes) GetCurrentVersion() uint32 {
	return TCaplusListDeleteAllResCurrentVersion
}

func (this *TCaplusListDeleteAllRes) Init() {

	this.AffectedElementNum = 0

}

func (this *TCaplusListDeleteAllRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListDeleteAllRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListDeleteAllRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListDeleteAllResCurrentVersion {
		cutVer = TCaplusListDeleteAllResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListDeleteAllResBaseVersion {
		return errors.New("TCaplusListDeleteAllRes cut version must large than TCaplusListDeleteAllResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListDeleteAllRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AffectedElementNum)
	if err != nil {
		return errors.New("TCaplusListDeleteAllRes.AffectedElementNum pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListDeleteAllRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListDeleteAllRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListDeleteAllRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListDeleteAllResCurrentVersion {
		cutVer = TCaplusListDeleteAllResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListDeleteAllResBaseVersion {
		errors.New("TCaplusListDeleteAllRes cut version must large than TCaplusListDeleteAllResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListDeleteAllRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AffectedElementNum)
	if err != nil {
		return errors.New("TCaplusListDeleteAllRes.AffectedElementNum unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListDeleteBatchReqBaseVersion                uint32 = 10
	TCaplusListDeleteBatchReqCurrentVersion             uint32 = 59
	TCaplusListDeleteBatchReqAllowMultiResponsesVersion uint32 = 59
	TCaplusListDeleteBatchReqFlagVersion                uint32 = 59
	TCaplusListDeleteBatchReqCheckVersiontTypeVersion   uint32 = 13
)

// TCaplusListDeleteBatchReq
type TCaplusListDeleteBatchReq struct {
	AllowMultiResponses byte `tdr_field:"AllowMultiResponses"`

	ElementNum int32 `tdr_field:"ElementNum"`

	ElementIndexArray []int32 `tdr_field:"ElementIndexArray" tdr_count:"10240" tdr_refer:"ElementNum"`

	Flag byte `tdr_field:"Flag"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusListDeleteBatchReq() *TCaplusListDeleteBatchReq {
	obj := new(TCaplusListDeleteBatchReq)
	obj.Init()
	return obj
}

func (this *TCaplusListDeleteBatchReq) GetBaseVersion() uint32 {
	return TCaplusListDeleteBatchReqBaseVersion
}

func (this *TCaplusListDeleteBatchReq) GetCurrentVersion() uint32 {
	return TCaplusListDeleteBatchReqCurrentVersion
}

func (this *TCaplusListDeleteBatchReq) Init() {
	this.AllowMultiResponses = 0

	this.ElementNum = 0

	this.CheckVersiontType = 1

}

func (this *TCaplusListDeleteBatchReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListDeleteBatchReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListDeleteBatchReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListDeleteBatchReqCurrentVersion {
		cutVer = TCaplusListDeleteBatchReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListDeleteBatchReqBaseVersion {
		return errors.New("TCaplusListDeleteBatchReq cut version must large than TCaplusListDeleteBatchReqBaseVersion\n")
	}

	var err error
	if cutVer >= TCaplusListDeleteBatchReqAllowMultiResponsesVersion {

		err = binary.Write(w, binary.BigEndian, this.AllowMultiResponses)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.AllowMultiResponses pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.ElementNum)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchReq.ElementNum pack error\n" + err.Error())
	}

	if this.ElementNum < 0 {
		return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray's refer ElementNum should >= 0")
	}
	if this.ElementNum > 10240 {
		return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray's refer ElementNum should <= count 10240")
	}
	if len(this.ElementIndexArray) < int(this.ElementNum) {
		return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray's length should > ElementNum")
	}
	if this.ElementNum > 0 {
		referElementIndexArray := this.ElementIndexArray[:this.ElementNum]
		err = binary.Write(w, binary.BigEndian, referElementIndexArray)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusListDeleteBatchReqFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteBatchReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListDeleteBatchReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListDeleteBatchReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListDeleteBatchReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListDeleteBatchReqCurrentVersion {
		cutVer = TCaplusListDeleteBatchReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListDeleteBatchReqBaseVersion {
		errors.New("TCaplusListDeleteBatchReq cut version must large than TCaplusListDeleteBatchReqBaseVersion\n")
	}

	if cutVer >= TCaplusListDeleteBatchReqAllowMultiResponsesVersion {

		err = binary.Read(r, binary.BigEndian, &this.AllowMultiResponses)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.AllowMultiResponses unpack error\n" + err.Error())
		}

	} else {
		this.AllowMultiResponses = 0

	}

	err = binary.Read(r, binary.BigEndian, &this.ElementNum)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchReq.ElementNum unpack error\n" + err.Error())
	}

	if this.ElementNum < 0 {
		return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray's refer ElementNum should >= 0")
	}
	if this.ElementNum > 10240 {
		return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray's refer ElementNum should <= count 10240")
	}

	if this.ElementIndexArray == nil {
		this.ElementIndexArray = make([]int32, int(this.ElementNum))
	}

	referElementIndexArray := this.ElementIndexArray[:this.ElementNum]
	err = binary.Read(r, binary.BigEndian, referElementIndexArray)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchReq.ElementIndexArray pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteBatchReqFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.Flag unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteBatchReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusListDeleteBatchResBaseVersion              uint32 = 10
	TCaplusListDeleteBatchResCurrentVersion           uint32 = 59
	TCaplusListDeleteBatchResElementIndexArrayVersion uint32 = 14
	TCaplusListDeleteBatchResFlagVersion              uint32 = 59
	TCaplusListDeleteBatchResResultInfoVersion        uint32 = 59
)

// TCaplusListDeleteBatchRes
type TCaplusListDeleteBatchRes struct {
	Result int32 `tdr_field:"Result"`

	AffectedElementNum int32 `tdr_field:"AffectedElementNum"`

	ElementIndexArray []int32 `tdr_field:"ElementIndexArray" tdr_count:"10240" tdr_refer:"AffectedElementNum"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`
}

func NewTCaplusListDeleteBatchRes() *TCaplusListDeleteBatchRes {
	obj := new(TCaplusListDeleteBatchRes)
	obj.Init()
	return obj
}

func (this *TCaplusListDeleteBatchRes) GetBaseVersion() uint32 {
	return TCaplusListDeleteBatchResBaseVersion
}

func (this *TCaplusListDeleteBatchRes) GetCurrentVersion() uint32 {
	return TCaplusListDeleteBatchResCurrentVersion
}

func (this *TCaplusListDeleteBatchRes) Init() {

	this.AffectedElementNum = 0

	this.Flag = 0

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusListDeleteBatchRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListDeleteBatchRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListDeleteBatchRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListDeleteBatchResCurrentVersion {
		cutVer = TCaplusListDeleteBatchResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListDeleteBatchResBaseVersion {
		return errors.New("TCaplusListDeleteBatchRes cut version must large than TCaplusListDeleteBatchResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AffectedElementNum)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchRes.AffectedElementNum pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteBatchResElementIndexArrayVersion {

		if this.AffectedElementNum < 0 {
			return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray's refer AffectedElementNum should >= 0")
		}
		if this.AffectedElementNum > 10240 {
			return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray's refer AffectedElementNum should <= count 10240")
		}
		if len(this.ElementIndexArray) < int(this.AffectedElementNum) {
			return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray's length should > AffectedElementNum")
		}
		if this.AffectedElementNum > 0 {
			referElementIndexArray := this.ElementIndexArray[:this.AffectedElementNum]
			err = binary.Write(w, binary.BigEndian, referElementIndexArray)
			if err != nil {
				return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray pack error\n" + err.Error())
			}
		}

	}
	if cutVer >= TCaplusListDeleteBatchResFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchRes.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteBatchResResultInfoVersion {

		err = this.ResultInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchRes.ResultInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListDeleteBatchRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListDeleteBatchRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListDeleteBatchRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListDeleteBatchResCurrentVersion {
		cutVer = TCaplusListDeleteBatchResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListDeleteBatchResBaseVersion {
		errors.New("TCaplusListDeleteBatchRes cut version must large than TCaplusListDeleteBatchResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AffectedElementNum)
	if err != nil {
		return errors.New("TCaplusListDeleteBatchRes.AffectedElementNum unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteBatchResElementIndexArrayVersion {

		if this.AffectedElementNum < 0 {
			return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray's refer AffectedElementNum should >= 0")
		}
		if this.AffectedElementNum > 10240 {
			return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray's refer AffectedElementNum should <= count 10240")
		}

		if this.ElementIndexArray == nil {
			this.ElementIndexArray = make([]int32, int(this.AffectedElementNum))
		}

		referElementIndexArray := this.ElementIndexArray[:this.AffectedElementNum]
		err = binary.Read(r, binary.BigEndian, referElementIndexArray)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchRes.ElementIndexArray pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteBatchResFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchRes.Flag unpack error\n" + err.Error())
		}

	} else {
		this.Flag = 0

	}
	if cutVer >= TCaplusListDeleteBatchResResultInfoVersion {

		err = this.ResultInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListDeleteBatchRes.ResultInfo unpack error\n" + err.Error())
		}

	} else {
		this.ResultInfo.Init()

	}
	return err
}

const (
	TCaplusListCheckReqBaseVersion    uint32 = 1
	TCaplusListCheckReqCurrentVersion uint32 = 1
)

// TCaplusListCheckReq
type TCaplusListCheckReq struct {
	StartSubscript uint32 `tdr_field:"StartSubscript"`

	CheckCount uint32 `tdr_field:"CheckCount"`
}

func NewTCaplusListCheckReq() *TCaplusListCheckReq {
	obj := new(TCaplusListCheckReq)
	obj.Init()
	return obj
}

func (this *TCaplusListCheckReq) GetBaseVersion() uint32 {
	return TCaplusListCheckReqBaseVersion
}

func (this *TCaplusListCheckReq) GetCurrentVersion() uint32 {
	return TCaplusListCheckReqCurrentVersion
}

func (this *TCaplusListCheckReq) Init() {

}

func (this *TCaplusListCheckReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListCheckReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListCheckReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListCheckReqCurrentVersion {
		cutVer = TCaplusListCheckReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListCheckReqBaseVersion {
		return errors.New("TCaplusListCheckReq cut version must large than TCaplusListCheckReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.StartSubscript)
	if err != nil {
		return errors.New("TCaplusListCheckReq.StartSubscript pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CheckCount)
	if err != nil {
		return errors.New("TCaplusListCheckReq.CheckCount pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListCheckReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListCheckReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListCheckReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListCheckReqCurrentVersion {
		cutVer = TCaplusListCheckReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListCheckReqBaseVersion {
		errors.New("TCaplusListCheckReq cut version must large than TCaplusListCheckReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.StartSubscript)
	if err != nil {
		return errors.New("TCaplusListCheckReq.StartSubscript unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CheckCount)
	if err != nil {
		return errors.New("TCaplusListCheckReq.CheckCount unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListCheckResBaseVersion    uint32 = 1
	TCaplusListCheckResCurrentVersion uint32 = 1
)

// TCaplusListCheckRes
type TCaplusListCheckRes struct {
	Result int32 `tdr_field:"Result"`

	MatchCount uint32 `tdr_field:"MatchCount"`
}

func NewTCaplusListCheckRes() *TCaplusListCheckRes {
	obj := new(TCaplusListCheckRes)
	obj.Init()
	return obj
}

func (this *TCaplusListCheckRes) GetBaseVersion() uint32 {
	return TCaplusListCheckResBaseVersion
}

func (this *TCaplusListCheckRes) GetCurrentVersion() uint32 {
	return TCaplusListCheckResCurrentVersion
}

func (this *TCaplusListCheckRes) Init() {

}

func (this *TCaplusListCheckRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListCheckRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListCheckRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListCheckResCurrentVersion {
		cutVer = TCaplusListCheckResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListCheckResBaseVersion {
		return errors.New("TCaplusListCheckRes cut version must large than TCaplusListCheckResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListCheckRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MatchCount)
	if err != nil {
		return errors.New("TCaplusListCheckRes.MatchCount pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListCheckRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListCheckRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListCheckRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListCheckResCurrentVersion {
		cutVer = TCaplusListCheckResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListCheckResBaseVersion {
		errors.New("TCaplusListCheckRes cut version must large than TCaplusListCheckResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListCheckRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.MatchCount)
	if err != nil {
		return errors.New("TCaplusListCheckRes.MatchCount unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListGetReqBaseVersion    uint32 = 1
	TCaplusListGetReqCurrentVersion uint32 = 1
)

// TCaplusListGetReq
type TCaplusListGetReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	ElementValueNames *TCaplusNameSet `tdr_field:"ElementValueNames"`
}

func NewTCaplusListGetReq() *TCaplusListGetReq {
	obj := new(TCaplusListGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusListGetReq) GetBaseVersion() uint32 {
	return TCaplusListGetReqBaseVersion
}

func (this *TCaplusListGetReq) GetCurrentVersion() uint32 {
	return TCaplusListGetReqCurrentVersion
}

func (this *TCaplusListGetReq) Init() {
	this.ElementIndex = 0

	this.ElementValueNames = NewTCaplusNameSet()

}

func (this *TCaplusListGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListGetReqCurrentVersion {
		cutVer = TCaplusListGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListGetReqBaseVersion {
		return errors.New("TCaplusListGetReq cut version must large than TCaplusListGetReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListGetReq.ElementIndex pack error\n" + err.Error())
	}

	err = this.ElementValueNames.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListGetReq.ElementValueNames pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListGetReqCurrentVersion {
		cutVer = TCaplusListGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListGetReqBaseVersion {
		errors.New("TCaplusListGetReq cut version must large than TCaplusListGetReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListGetReq.ElementIndex unpack error\n" + err.Error())
	}

	err = this.ElementValueNames.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListGetReq.ElementValueNames unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListGetResBaseVersion    uint32 = 1
	TCaplusListGetResCurrentVersion uint32 = 1
)

// TCaplusListGetRes
type TCaplusListGetRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`
}

func NewTCaplusListGetRes() *TCaplusListGetRes {
	obj := new(TCaplusListGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusListGetRes) GetBaseVersion() uint32 {
	return TCaplusListGetResBaseVersion
}

func (this *TCaplusListGetRes) GetCurrentVersion() uint32 {
	return TCaplusListGetResCurrentVersion
}

func (this *TCaplusListGetRes) Init() {

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusListGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListGetResCurrentVersion {
		cutVer = TCaplusListGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListGetResBaseVersion {
		return errors.New("TCaplusListGetRes cut version must large than TCaplusListGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListGetRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListGetRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListGetResCurrentVersion {
		cutVer = TCaplusListGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListGetResBaseVersion {
		errors.New("TCaplusListGetRes cut version must large than TCaplusListGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListGetRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListGetRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListAddAfterReqBaseVersion              uint32 = 1
	TCaplusListAddAfterReqCurrentVersion           uint32 = 109
	TCaplusListAddAfterReqFlagVersion              uint32 = 59
	TCaplusListAddAfterReqShiftFlagVersion         uint32 = 11
	TCaplusListAddAfterReqCheckVersiontTypeVersion uint32 = 13
)

// TCaplusListAddAfterReq
type TCaplusListAddAfterReq struct {
	Flag byte `tdr_field:"Flag"`

	ShiftFlag byte `tdr_field:"ShiftFlag"`

	ElementIndex int32 `tdr_field:"ElementIndex"`

	ElementValueInfo *TCaplusValueSet_ `tdr_field:"ElementValueInfo"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusListAddAfterReq() *TCaplusListAddAfterReq {
	obj := new(TCaplusListAddAfterReq)
	obj.Init()
	return obj
}

func (this *TCaplusListAddAfterReq) GetBaseVersion() uint32 {
	return TCaplusListAddAfterReqBaseVersion
}

func (this *TCaplusListAddAfterReq) GetCurrentVersion() uint32 {
	return TCaplusListAddAfterReqCurrentVersion
}

func (this *TCaplusListAddAfterReq) Init() {
	this.Flag = 0

	this.ShiftFlag = 1

	this.ElementIndex = 0

	this.ElementValueInfo = NewTCaplusValueSet_()

	this.CheckVersiontType = 1

}

func (this *TCaplusListAddAfterReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListAddAfterReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListAddAfterReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListAddAfterReqCurrentVersion {
		cutVer = TCaplusListAddAfterReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListAddAfterReqBaseVersion {
		return errors.New("TCaplusListAddAfterReq cut version must large than TCaplusListAddAfterReqBaseVersion\n")
	}

	var err error
	if cutVer >= TCaplusListAddAfterReqFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListAddAfterReq.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListAddAfterReqShiftFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.ShiftFlag)
		if err != nil {
			return errors.New("TCaplusListAddAfterReq.ShiftFlag pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListAddAfterReq.ElementIndex pack error\n" + err.Error())
	}

	err = this.ElementValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListAddAfterReq.ElementValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListAddAfterReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListAddAfterReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListAddAfterReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListAddAfterReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListAddAfterReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListAddAfterReqCurrentVersion {
		cutVer = TCaplusListAddAfterReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListAddAfterReqBaseVersion {
		errors.New("TCaplusListAddAfterReq cut version must large than TCaplusListAddAfterReqBaseVersion\n")
	}

	if cutVer >= TCaplusListAddAfterReqFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListAddAfterReq.Flag unpack error\n" + err.Error())
		}

	} else {
		this.Flag = 0

	}
	if cutVer >= TCaplusListAddAfterReqShiftFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.ShiftFlag)
		if err != nil {
			return errors.New("TCaplusListAddAfterReq.ShiftFlag unpack error\n" + err.Error())
		}

	} else {
		this.ShiftFlag = 1

	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListAddAfterReq.ElementIndex unpack error\n" + err.Error())
	}

	err = this.ElementValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListAddAfterReq.ElementValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListAddAfterReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListAddAfterReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusListAddAfterResBaseVersion       uint32 = 1
	TCaplusListAddAfterResCurrentVersion    uint32 = 59
	TCaplusListAddAfterResShiftFlagVersion  uint32 = 11
	TCaplusListAddAfterResFlagVersion       uint32 = 59
	TCaplusListAddAfterResResultInfoVersion uint32 = 59
)

// TCaplusListAddAfterRes
type TCaplusListAddAfterRes struct {
	Result int32 `tdr_field:"Result"`

	ShiftFlag byte `tdr_field:"ShiftFlag"`

	ElementIndex int32 `tdr_field:"ElementIndex"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`
}

func NewTCaplusListAddAfterRes() *TCaplusListAddAfterRes {
	obj := new(TCaplusListAddAfterRes)
	obj.Init()
	return obj
}

func (this *TCaplusListAddAfterRes) GetBaseVersion() uint32 {
	return TCaplusListAddAfterResBaseVersion
}

func (this *TCaplusListAddAfterRes) GetCurrentVersion() uint32 {
	return TCaplusListAddAfterResCurrentVersion
}

func (this *TCaplusListAddAfterRes) Init() {

	this.ElementIndex = 0

	this.Flag = 0

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusListAddAfterRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListAddAfterRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListAddAfterRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListAddAfterResCurrentVersion {
		cutVer = TCaplusListAddAfterResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListAddAfterResBaseVersion {
		return errors.New("TCaplusListAddAfterRes cut version must large than TCaplusListAddAfterResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListAddAfterRes.Result pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListAddAfterResShiftFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.ShiftFlag)
		if err != nil {
			return errors.New("TCaplusListAddAfterRes.ShiftFlag pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListAddAfterRes.ElementIndex pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListAddAfterResFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListAddAfterRes.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListAddAfterResResultInfoVersion {

		err = this.ResultInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListAddAfterRes.ResultInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListAddAfterRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListAddAfterRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListAddAfterRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListAddAfterResCurrentVersion {
		cutVer = TCaplusListAddAfterResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListAddAfterResBaseVersion {
		errors.New("TCaplusListAddAfterRes cut version must large than TCaplusListAddAfterResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListAddAfterRes.Result unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListAddAfterResShiftFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.ShiftFlag)
		if err != nil {
			return errors.New("TCaplusListAddAfterRes.ShiftFlag unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListAddAfterRes.ElementIndex unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListAddAfterResFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListAddAfterRes.Flag unpack error\n" + err.Error())
		}

	} else {
		this.Flag = 0

	}
	if cutVer >= TCaplusListAddAfterResResultInfoVersion {

		err = this.ResultInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListAddAfterRes.ResultInfo unpack error\n" + err.Error())
		}

	} else {
		this.ResultInfo.Init()

	}
	return err
}

const (
	TCaplusListDeleteReqBaseVersion              uint32 = 1
	TCaplusListDeleteReqCurrentVersion           uint32 = 13
	TCaplusListDeleteReqFlagVersion              uint32 = 6
	TCaplusListDeleteReqCheckVersiontTypeVersion uint32 = 13
)

// TCaplusListDeleteReq
type TCaplusListDeleteReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	Flag byte `tdr_field:"Flag"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusListDeleteReq() *TCaplusListDeleteReq {
	obj := new(TCaplusListDeleteReq)
	obj.Init()
	return obj
}

func (this *TCaplusListDeleteReq) GetBaseVersion() uint32 {
	return TCaplusListDeleteReqBaseVersion
}

func (this *TCaplusListDeleteReq) GetCurrentVersion() uint32 {
	return TCaplusListDeleteReqCurrentVersion
}

func (this *TCaplusListDeleteReq) Init() {
	this.ElementIndex = 0

	this.CheckVersiontType = 1

}

func (this *TCaplusListDeleteReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListDeleteReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListDeleteReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListDeleteReqCurrentVersion {
		cutVer = TCaplusListDeleteReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListDeleteReqBaseVersion {
		return errors.New("TCaplusListDeleteReq cut version must large than TCaplusListDeleteReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListDeleteReq.ElementIndex pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteReqFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteReq.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListDeleteReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListDeleteReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListDeleteReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListDeleteReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListDeleteReqCurrentVersion {
		cutVer = TCaplusListDeleteReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListDeleteReqBaseVersion {
		errors.New("TCaplusListDeleteReq cut version must large than TCaplusListDeleteReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListDeleteReq.ElementIndex unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteReqFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteReq.Flag unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListDeleteReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusListDeleteResBaseVersion       uint32 = 1
	TCaplusListDeleteResCurrentVersion    uint32 = 6
	TCaplusListDeleteResFlagVersion       uint32 = 6
	TCaplusListDeleteResResultInfoVersion uint32 = 6
)

// TCaplusListDeleteRes
type TCaplusListDeleteRes struct {
	Result int32 `tdr_field:"Result"`

	ElementIndex int32 `tdr_field:"ElementIndex"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`
}

func NewTCaplusListDeleteRes() *TCaplusListDeleteRes {
	obj := new(TCaplusListDeleteRes)
	obj.Init()
	return obj
}

func (this *TCaplusListDeleteRes) GetBaseVersion() uint32 {
	return TCaplusListDeleteResBaseVersion
}

func (this *TCaplusListDeleteRes) GetCurrentVersion() uint32 {
	return TCaplusListDeleteResCurrentVersion
}

func (this *TCaplusListDeleteRes) Init() {

	this.ElementIndex = 0

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusListDeleteRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListDeleteRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListDeleteRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListDeleteResCurrentVersion {
		cutVer = TCaplusListDeleteResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListDeleteResBaseVersion {
		return errors.New("TCaplusListDeleteRes cut version must large than TCaplusListDeleteResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListDeleteRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListDeleteRes.ElementIndex pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteResFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteRes.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteResResultInfoVersion {

		err = this.ResultInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListDeleteRes.ResultInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListDeleteRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListDeleteRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListDeleteRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListDeleteResCurrentVersion {
		cutVer = TCaplusListDeleteResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListDeleteResBaseVersion {
		errors.New("TCaplusListDeleteRes cut version must large than TCaplusListDeleteResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListDeleteRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListDeleteRes.ElementIndex unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListDeleteResFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListDeleteRes.Flag unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListDeleteResResultInfoVersion {

		err = this.ResultInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListDeleteRes.ResultInfo unpack error\n" + err.Error())
		}

	} else {
		this.ResultInfo.Init()

	}
	return err
}

const (
	TCaplusSysListDeleteReqBaseVersion    uint32 = 53
	TCaplusSysListDeleteReqCurrentVersion uint32 = 53
)

// TCaplusSysListDeleteReq
type TCaplusSysListDeleteReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	Flag byte `tdr_field:"Flag"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`

	Timestamp int32 `tdr_field:"Timestamp"`
}

func NewTCaplusSysListDeleteReq() *TCaplusSysListDeleteReq {
	obj := new(TCaplusSysListDeleteReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysListDeleteReq) GetBaseVersion() uint32 {
	return TCaplusSysListDeleteReqBaseVersion
}

func (this *TCaplusSysListDeleteReq) GetCurrentVersion() uint32 {
	return TCaplusSysListDeleteReqCurrentVersion
}

func (this *TCaplusSysListDeleteReq) Init() {
	this.ElementIndex = 0

	this.CheckVersiontType = 1

}

func (this *TCaplusSysListDeleteReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListDeleteReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListDeleteReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListDeleteReqCurrentVersion {
		cutVer = TCaplusSysListDeleteReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListDeleteReqBaseVersion {
		return errors.New("TCaplusSysListDeleteReq cut version must large than TCaplusSysListDeleteReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.ElementIndex pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.Flag pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.CheckVersiontType pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Timestamp)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.Timestamp pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListDeleteReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListDeleteReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListDeleteReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListDeleteReqCurrentVersion {
		cutVer = TCaplusSysListDeleteReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListDeleteReqBaseVersion {
		errors.New("TCaplusSysListDeleteReq cut version must large than TCaplusSysListDeleteReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.ElementIndex unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.Flag unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.CheckVersiontType unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Timestamp)
	if err != nil {
		return errors.New("TCaplusSysListDeleteReq.Timestamp unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysListDeleteResBaseVersion    uint32 = 53
	TCaplusSysListDeleteResCurrentVersion uint32 = 53
)

// TCaplusSysListDeleteRes
type TCaplusSysListDeleteRes struct {
	Result int32 `tdr_field:"Result"`

	ElementIndex int32 `tdr_field:"ElementIndex"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`
}

func NewTCaplusSysListDeleteRes() *TCaplusSysListDeleteRes {
	obj := new(TCaplusSysListDeleteRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysListDeleteRes) GetBaseVersion() uint32 {
	return TCaplusSysListDeleteResBaseVersion
}

func (this *TCaplusSysListDeleteRes) GetCurrentVersion() uint32 {
	return TCaplusSysListDeleteResCurrentVersion
}

func (this *TCaplusSysListDeleteRes) Init() {

	this.ElementIndex = 0

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusSysListDeleteRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListDeleteRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListDeleteRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListDeleteResCurrentVersion {
		cutVer = TCaplusSysListDeleteResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListDeleteResBaseVersion {
		return errors.New("TCaplusSysListDeleteRes cut version must large than TCaplusSysListDeleteResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.ElementIndex pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Flag)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.Flag pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListDeleteRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListDeleteRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListDeleteRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListDeleteResCurrentVersion {
		cutVer = TCaplusSysListDeleteResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListDeleteResBaseVersion {
		errors.New("TCaplusSysListDeleteRes cut version must large than TCaplusSysListDeleteResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.ElementIndex unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Flag)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.Flag unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListDeleteRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListReplaceReqBaseVersion               uint32 = 1
	TCaplusListReplaceReqCurrentVersion            uint32 = 114
	TCaplusListReplaceReqFlagVersion               uint32 = 59
	TCaplusListReplaceReqCheckVersiontTypeVersion  uint32 = 13
	TCaplusListReplaceReqElementPbValueInfoVersion uint32 = 114
)

// TCaplusListReplaceReq
type TCaplusListReplaceReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	ElementValueInfo *TCaplusValueSet_ `tdr_field:"ElementValueInfo"`

	Flag byte `tdr_field:"Flag"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`

	ElementPbValueInfo *ProtobufValueSet_ `tdr_field:"ElementPbValueInfo"`
}

func NewTCaplusListReplaceReq() *TCaplusListReplaceReq {
	obj := new(TCaplusListReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusListReplaceReq) GetBaseVersion() uint32 {
	return TCaplusListReplaceReqBaseVersion
}

func (this *TCaplusListReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusListReplaceReqCurrentVersion
}

func (this *TCaplusListReplaceReq) Init() {
	this.ElementIndex = 0

	this.ElementValueInfo = NewTCaplusValueSet_()

	this.CheckVersiontType = 1

	this.ElementPbValueInfo = NewProtobufValueSet_()

}

func (this *TCaplusListReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListReplaceReqCurrentVersion {
		cutVer = TCaplusListReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListReplaceReqBaseVersion {
		return errors.New("TCaplusListReplaceReq cut version must large than TCaplusListReplaceReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListReplaceReq.ElementIndex pack error\n" + err.Error())
	}

	err = this.ElementValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListReplaceReq.ElementValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListReplaceReqFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListReplaceReq.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListReplaceReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListReplaceReq.CheckVersiontType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListReplaceReqElementPbValueInfoVersion {

		err = this.ElementPbValueInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListReplaceReq.ElementPbValueInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListReplaceReqCurrentVersion {
		cutVer = TCaplusListReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListReplaceReqBaseVersion {
		errors.New("TCaplusListReplaceReq cut version must large than TCaplusListReplaceReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListReplaceReq.ElementIndex unpack error\n" + err.Error())
	}

	err = this.ElementValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListReplaceReq.ElementValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListReplaceReqFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListReplaceReq.Flag unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListReplaceReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusListReplaceReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	if cutVer >= TCaplusListReplaceReqElementPbValueInfoVersion {

		err = this.ElementPbValueInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListReplaceReq.ElementPbValueInfo unpack error\n" + err.Error())
		}

	} else {
		this.ElementPbValueInfo.Init()

	}
	return err
}

const (
	TCaplusListReplaceResBaseVersion       uint32 = 1
	TCaplusListReplaceResCurrentVersion    uint32 = 59
	TCaplusListReplaceResFlagVersion       uint32 = 59
	TCaplusListReplaceResResultInfoVersion uint32 = 59
)

// TCaplusListReplaceRes
type TCaplusListReplaceRes struct {
	Result int32 `tdr_field:"Result"`

	ElementIndex int32 `tdr_field:"ElementIndex"`

	Flag byte `tdr_field:"Flag"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`
}

func NewTCaplusListReplaceRes() *TCaplusListReplaceRes {
	obj := new(TCaplusListReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusListReplaceRes) GetBaseVersion() uint32 {
	return TCaplusListReplaceResBaseVersion
}

func (this *TCaplusListReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusListReplaceResCurrentVersion
}

func (this *TCaplusListReplaceRes) Init() {

	this.ElementIndex = 0

	this.Flag = 0

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusListReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListReplaceResCurrentVersion {
		cutVer = TCaplusListReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListReplaceResBaseVersion {
		return errors.New("TCaplusListReplaceRes cut version must large than TCaplusListReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListReplaceRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListReplaceRes.ElementIndex pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListReplaceResFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.Flag)
		if err != nil {
			return errors.New("TCaplusListReplaceRes.Flag pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusListReplaceResResultInfoVersion {

		err = this.ResultInfo.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListReplaceRes.ResultInfo pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListReplaceResCurrentVersion {
		cutVer = TCaplusListReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListReplaceResBaseVersion {
		errors.New("TCaplusListReplaceRes cut version must large than TCaplusListReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListReplaceRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListReplaceRes.ElementIndex unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListReplaceResFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flag)
		if err != nil {
			return errors.New("TCaplusListReplaceRes.Flag unpack error\n" + err.Error())
		}

	} else {
		this.Flag = 0

	}
	if cutVer >= TCaplusListReplaceResResultInfoVersion {

		err = this.ResultInfo.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListReplaceRes.ResultInfo unpack error\n" + err.Error())
		}

	} else {
		this.ResultInfo.Init()

	}
	return err
}

const (
	TCaplusGetByPartKeyReqBaseVersion    uint32 = 1
	TCaplusGetByPartKeyReqCurrentVersion uint32 = 1
)

// TCaplusGetByPartKeyReq
type TCaplusGetByPartKeyReq struct {
	OffSet int32 `tdr_field:"OffSet"`

	Limit int32 `tdr_field:"Limit"`

	ValueInfo *TCaplusNameSet `tdr_field:"ValueInfo"`
}

func NewTCaplusGetByPartKeyReq() *TCaplusGetByPartKeyReq {
	obj := new(TCaplusGetByPartKeyReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetByPartKeyReq) GetBaseVersion() uint32 {
	return TCaplusGetByPartKeyReqBaseVersion
}

func (this *TCaplusGetByPartKeyReq) GetCurrentVersion() uint32 {
	return TCaplusGetByPartKeyReqCurrentVersion
}

func (this *TCaplusGetByPartKeyReq) Init() {
	this.OffSet = 0

	this.Limit = -1

	this.ValueInfo = NewTCaplusNameSet()

}

func (this *TCaplusGetByPartKeyReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetByPartKeyReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetByPartKeyReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyReqCurrentVersion {
		cutVer = TCaplusGetByPartKeyReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetByPartKeyReqBaseVersion {
		return errors.New("TCaplusGetByPartKeyReq cut version must large than TCaplusGetByPartKeyReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.OffSet)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyReq.OffSet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Limit)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyReq.Limit pack error\n" + err.Error())
	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyReq.ValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetByPartKeyReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetByPartKeyReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetByPartKeyReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyReqCurrentVersion {
		cutVer = TCaplusGetByPartKeyReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetByPartKeyReqBaseVersion {
		errors.New("TCaplusGetByPartKeyReq cut version must large than TCaplusGetByPartKeyReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.OffSet)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyReq.OffSet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Limit)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyReq.Limit unpack error\n" + err.Error())
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyReq.ValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetByPartKeyResultSuccBaseVersion           uint32 = 1
	TCaplusGetByPartKeyResultSuccCurrentVersion        uint32 = 38
	TCaplusGetByPartKeyResultSuccIsCompleteFlagVersion uint32 = 38
)

// TCaplusGetByPartKeyResultSucc
type TCaplusGetByPartKeyResultSucc struct {
	TotalNum int32 `tdr_field:"TotalNum"`

	OffSet int32 `tdr_field:"OffSet"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	BatchValueLen int32 `tdr_field:"BatchValueLen"`

	BatchValueInfo []byte `tdr_field:"BatchValueInfo" tdr_count:"10300000" tdr_refer:"BatchValueLen"`

	IsCompleteFlag int32 `tdr_field:"IsCompleteFlag"`
}

func NewTCaplusGetByPartKeyResultSucc() *TCaplusGetByPartKeyResultSucc {
	obj := new(TCaplusGetByPartKeyResultSucc)
	obj.Init()
	return obj
}

func (this *TCaplusGetByPartKeyResultSucc) GetBaseVersion() uint32 {
	return TCaplusGetByPartKeyResultSuccBaseVersion
}

func (this *TCaplusGetByPartKeyResultSucc) GetCurrentVersion() uint32 {
	return TCaplusGetByPartKeyResultSuccCurrentVersion
}

func (this *TCaplusGetByPartKeyResultSucc) Init() {

	this.RecordNum = 0

	this.BatchValueLen = 0

	this.IsCompleteFlag = 1

}

func (this *TCaplusGetByPartKeyResultSucc) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetByPartKeyResultSucc Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetByPartKeyResultSucc) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyResultSuccCurrentVersion {
		cutVer = TCaplusGetByPartKeyResultSuccCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetByPartKeyResultSuccBaseVersion {
		return errors.New("TCaplusGetByPartKeyResultSucc cut version must large than TCaplusGetByPartKeyResultSuccBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.TotalNum)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.TotalNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.OffSet)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.OffSet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueLen pack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}
	if len(this.BatchValueInfo) < int(this.BatchValueLen) {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo's length should > BatchValueLen")
	}
	if this.BatchValueLen > 0 {
		referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
		err = binary.Write(w, binary.BigEndian, referBatchValueInfo)
		if err != nil {
			return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusGetByPartKeyResultSuccIsCompleteFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.IsCompleteFlag)
		if err != nil {
			return errors.New("TCaplusGetByPartKeyResultSucc.IsCompleteFlag pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusGetByPartKeyResultSucc) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetByPartKeyResultSucc data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetByPartKeyResultSucc) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyResultSuccCurrentVersion {
		cutVer = TCaplusGetByPartKeyResultSuccCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetByPartKeyResultSuccBaseVersion {
		errors.New("TCaplusGetByPartKeyResultSucc cut version must large than TCaplusGetByPartKeyResultSuccBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalNum)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.TotalNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.OffSet)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.OffSet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueLen unpack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}

	if this.BatchValueInfo == nil {
		this.BatchValueInfo = make([]byte, int(this.BatchValueLen))
	}

	referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
	err = binary.Read(r, binary.BigEndian, referBatchValueInfo)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyResultSucc.BatchValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetByPartKeyResultSuccIsCompleteFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.IsCompleteFlag)
		if err != nil {
			return errors.New("TCaplusGetByPartKeyResultSucc.IsCompleteFlag unpack error\n" + err.Error())
		}

	} else {
		this.IsCompleteFlag = 1

	}
	return err
}

const (
	TCaplusGetByPartKeyResultBaseVersion    uint32 = 1
	TCaplusGetByPartKeyResultCurrentVersion uint32 = 38
)

// TCaplusGetByPartKeyResult
type TCaplusGetByPartKeyResult struct {
	Result *TCaplusGetByPartKeyResultSucc `tdr_field:"Result"`
}

func NewTCaplusGetByPartKeyResult(selector int64) *TCaplusGetByPartKeyResult {
	obj := new(TCaplusGetByPartKeyResult)
	obj.Init(selector)
	return obj
}

func (this *TCaplusGetByPartKeyResult) GetBaseVersion() uint32 {
	return TCaplusGetByPartKeyResultBaseVersion
}

func (this *TCaplusGetByPartKeyResult) GetCurrentVersion() uint32 {
	return TCaplusGetByPartKeyResultCurrentVersion
}

func (this *TCaplusGetByPartKeyResult) Init(selector int64) {
	switch selector {
	case 0:
		this.Result = NewTCaplusGetByPartKeyResultSucc()

	}
}

func (this *TCaplusGetByPartKeyResult) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetByPartKeyResult) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyResultCurrentVersion {
		cutVer = TCaplusGetByPartKeyResultCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetByPartKeyResultBaseVersion {
		return errors.New("TCaplusGetByPartKeyResult cut version must large than TCaplusGetByPartKeyResultBaseVersion\n")
	}

	var err error = nil
	switch selector {
	case 0:
		if this.Result == nil {
			return errors.New("TCaplusGetByPartKeyResult.Result is nil")
		}

		err = this.Result.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusGetByPartKeyResult.Result pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusGetByPartKeyResult) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("TCaplusGetByPartKeyResult data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *TCaplusGetByPartKeyResult) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyResultCurrentVersion {
		cutVer = TCaplusGetByPartKeyResultCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetByPartKeyResultBaseVersion {
		errors.New("TCaplusGetByPartKeyResult cut version must large than TCaplusGetByPartKeyResultBaseVersion\n")
	}

	switch selector {
	case 0:
		if this.Result == nil {
			this.Result = NewTCaplusGetByPartKeyResultSucc()
		}

		err = this.Result.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusGetByPartKeyResult.Result unpack error\n" + err.Error())
		}

	}

	return err
}

const (
	TCaplusGetByPartKeyResBaseVersion    uint32 = 1
	TCaplusGetByPartKeyResCurrentVersion uint32 = 38
)

// TCaplusGetByPartKeyRes
type TCaplusGetByPartKeyRes struct {
	Result int32 `tdr_field:"Result"`

	RecordResult *TCaplusGetByPartKeyResult `tdr_field:"RecordResult" tdr_select:"Result"`
}

func NewTCaplusGetByPartKeyRes() *TCaplusGetByPartKeyRes {
	obj := new(TCaplusGetByPartKeyRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetByPartKeyRes) GetBaseVersion() uint32 {
	return TCaplusGetByPartKeyResBaseVersion
}

func (this *TCaplusGetByPartKeyRes) GetCurrentVersion() uint32 {
	return TCaplusGetByPartKeyResCurrentVersion
}

func (this *TCaplusGetByPartKeyRes) Init() {

	this.RecordResult = NewTCaplusGetByPartKeyResult(int64(this.Result))

}

func (this *TCaplusGetByPartKeyRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetByPartKeyRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetByPartKeyRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyResCurrentVersion {
		cutVer = TCaplusGetByPartKeyResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetByPartKeyResBaseVersion {
		return errors.New("TCaplusGetByPartKeyRes cut version must large than TCaplusGetByPartKeyResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyRes.Result pack error\n" + err.Error())
	}

	err = this.RecordResult.PackTo(cutVer, w, int64(this.Result))
	if err != nil {
		return errors.New("TCaplusGetByPartKeyRes.RecordResult pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetByPartKeyRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetByPartKeyRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetByPartKeyRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetByPartKeyResCurrentVersion {
		cutVer = TCaplusGetByPartKeyResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetByPartKeyResBaseVersion {
		errors.New("TCaplusGetByPartKeyRes cut version must large than TCaplusGetByPartKeyResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusGetByPartKeyRes.Result unpack error\n" + err.Error())
	}

	err = this.RecordResult.UnpackFrom(cutVer, r, int64(this.Result))
	if err != nil {
		return errors.New("TCaplusGetByPartKeyRes.RecordResult unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusUpdateByPartkeyReqBaseVersion              uint32 = 41
	TCaplusUpdateByPartkeyReqCurrentVersion           uint32 = 109
	TCaplusUpdateByPartkeyReqCheckVersiontTypeVersion uint32 = 108
)

// TCaplusUpdateByPartkeyReq
type TCaplusUpdateByPartkeyReq struct {
	OffSet int32 `tdr_field:"OffSet"`

	Limit int32 `tdr_field:"Limit"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`

	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`
}

func NewTCaplusUpdateByPartkeyReq() *TCaplusUpdateByPartkeyReq {
	obj := new(TCaplusUpdateByPartkeyReq)
	obj.Init()
	return obj
}

func (this *TCaplusUpdateByPartkeyReq) GetBaseVersion() uint32 {
	return TCaplusUpdateByPartkeyReqBaseVersion
}

func (this *TCaplusUpdateByPartkeyReq) GetCurrentVersion() uint32 {
	return TCaplusUpdateByPartkeyReqCurrentVersion
}

func (this *TCaplusUpdateByPartkeyReq) Init() {
	this.OffSet = 0

	this.Limit = -1

	this.CheckVersiontType = 1

	this.ValueInfo = NewTCaplusValueSet_()

}

func (this *TCaplusUpdateByPartkeyReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusUpdateByPartkeyReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusUpdateByPartkeyReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusUpdateByPartkeyReqCurrentVersion {
		cutVer = TCaplusUpdateByPartkeyReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusUpdateByPartkeyReqBaseVersion {
		return errors.New("TCaplusUpdateByPartkeyReq cut version must large than TCaplusUpdateByPartkeyReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.OffSet)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyReq.OffSet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Limit)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyReq.Limit pack error\n" + err.Error())
	}

	if cutVer >= TCaplusUpdateByPartkeyReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusUpdateByPartkeyReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyReq.ValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusUpdateByPartkeyReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusUpdateByPartkeyReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusUpdateByPartkeyReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusUpdateByPartkeyReqCurrentVersion {
		cutVer = TCaplusUpdateByPartkeyReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusUpdateByPartkeyReqBaseVersion {
		errors.New("TCaplusUpdateByPartkeyReq cut version must large than TCaplusUpdateByPartkeyReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.OffSet)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyReq.OffSet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Limit)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyReq.Limit unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusUpdateByPartkeyReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusUpdateByPartkeyReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyReq.ValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusUpdateByPartkeyResBaseVersion    uint32 = 41
	TCaplusUpdateByPartkeyResCurrentVersion uint32 = 41
)

// TCaplusUpdateByPartkeyRes
type TCaplusUpdateByPartkeyRes struct {
	Result int32 `tdr_field:"Result"`

	TotalNum int32 `tdr_field:"TotalNum"`

	OffSet int32 `tdr_field:"OffSet"`

	SucNum int32 `tdr_field:"SucNum"`

	SucKeysBuffLen int32 `tdr_field:"SucKeysBuffLen"`

	SucKeysBuff []byte `tdr_field:"SucKeysBuff" tdr_count:"10300000" tdr_refer:"SucKeysBuffLen"`

	FailNum int32 `tdr_field:"FailNum"`

	FailKeys *TCaplusKeySet `tdr_field:"FailKeys" tdr_count:"1"`

	IsCompleteFlag int32 `tdr_field:"IsCompleteFlag"`
}

func NewTCaplusUpdateByPartkeyRes() *TCaplusUpdateByPartkeyRes {
	obj := new(TCaplusUpdateByPartkeyRes)
	obj.Init()
	return obj
}

func (this *TCaplusUpdateByPartkeyRes) GetBaseVersion() uint32 {
	return TCaplusUpdateByPartkeyResBaseVersion
}

func (this *TCaplusUpdateByPartkeyRes) GetCurrentVersion() uint32 {
	return TCaplusUpdateByPartkeyResCurrentVersion
}

func (this *TCaplusUpdateByPartkeyRes) Init() {

	this.SucKeysBuffLen = 0

	this.FailKeys = NewTCaplusKeySet()

	this.IsCompleteFlag = 1

}

func (this *TCaplusUpdateByPartkeyRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusUpdateByPartkeyRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusUpdateByPartkeyRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusUpdateByPartkeyResCurrentVersion {
		cutVer = TCaplusUpdateByPartkeyResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusUpdateByPartkeyResBaseVersion {
		return errors.New("TCaplusUpdateByPartkeyRes cut version must large than TCaplusUpdateByPartkeyResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalNum)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.TotalNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.OffSet)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.OffSet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SucNum)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.SucNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SucKeysBuffLen)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuffLen pack error\n" + err.Error())
	}

	if this.SucKeysBuffLen < 0 {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should >= 0")
	}
	if this.SucKeysBuffLen > 10300000 {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should <= count 10300000")
	}
	if len(this.SucKeysBuff) < int(this.SucKeysBuffLen) {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff's length should > SucKeysBuffLen")
	}
	if this.SucKeysBuffLen > 0 {
		referSucKeysBuff := this.SucKeysBuff[:this.SucKeysBuffLen]
		err = binary.Write(w, binary.BigEndian, referSucKeysBuff)
		if err != nil {
			return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.FailNum)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.FailNum pack error\n" + err.Error())
	}

	err = this.FailKeys.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.FailKeys pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.IsCompleteFlag pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusUpdateByPartkeyRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusUpdateByPartkeyRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusUpdateByPartkeyRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusUpdateByPartkeyResCurrentVersion {
		cutVer = TCaplusUpdateByPartkeyResCurrentVersion
	}
	// check version
	if cutVer < TCaplusUpdateByPartkeyResBaseVersion {
		errors.New("TCaplusUpdateByPartkeyRes cut version must large than TCaplusUpdateByPartkeyResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalNum)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.TotalNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.OffSet)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.OffSet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SucNum)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.SucNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SucKeysBuffLen)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuffLen unpack error\n" + err.Error())
	}

	if this.SucKeysBuffLen < 0 {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should >= 0")
	}
	if this.SucKeysBuffLen > 10300000 {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should <= count 10300000")
	}

	if this.SucKeysBuff == nil {
		this.SucKeysBuff = make([]byte, int(this.SucKeysBuffLen))
	}

	referSucKeysBuff := this.SucKeysBuff[:this.SucKeysBuffLen]
	err = binary.Read(r, binary.BigEndian, referSucKeysBuff)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.SucKeysBuff pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FailNum)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.FailNum unpack error\n" + err.Error())
	}

	err = this.FailKeys.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.FailKeys unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusUpdateByPartkeyRes.IsCompleteFlag unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusDeleteByPartkeyReqBaseVersion              uint32 = 41
	TCaplusDeleteByPartkeyReqCurrentVersion           uint32 = 108
	TCaplusDeleteByPartkeyReqCheckVersiontTypeVersion uint32 = 108
)

// TCaplusDeleteByPartkeyReq
type TCaplusDeleteByPartkeyReq struct {
	OffSet int32 `tdr_field:"OffSet"`

	Limit int32 `tdr_field:"Limit"`

	CheckVersiontType byte `tdr_field:"CheckVersiontType"`
}

func NewTCaplusDeleteByPartkeyReq() *TCaplusDeleteByPartkeyReq {
	obj := new(TCaplusDeleteByPartkeyReq)
	obj.Init()
	return obj
}

func (this *TCaplusDeleteByPartkeyReq) GetBaseVersion() uint32 {
	return TCaplusDeleteByPartkeyReqBaseVersion
}

func (this *TCaplusDeleteByPartkeyReq) GetCurrentVersion() uint32 {
	return TCaplusDeleteByPartkeyReqCurrentVersion
}

func (this *TCaplusDeleteByPartkeyReq) Init() {
	this.OffSet = 0

	this.Limit = -1

	this.CheckVersiontType = 1

}

func (this *TCaplusDeleteByPartkeyReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusDeleteByPartkeyReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusDeleteByPartkeyReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusDeleteByPartkeyReqCurrentVersion {
		cutVer = TCaplusDeleteByPartkeyReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusDeleteByPartkeyReqBaseVersion {
		return errors.New("TCaplusDeleteByPartkeyReq cut version must large than TCaplusDeleteByPartkeyReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.OffSet)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyReq.OffSet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Limit)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyReq.Limit pack error\n" + err.Error())
	}

	if cutVer >= TCaplusDeleteByPartkeyReqCheckVersiontTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusDeleteByPartkeyReq.CheckVersiontType pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusDeleteByPartkeyReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusDeleteByPartkeyReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusDeleteByPartkeyReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusDeleteByPartkeyReqCurrentVersion {
		cutVer = TCaplusDeleteByPartkeyReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusDeleteByPartkeyReqBaseVersion {
		errors.New("TCaplusDeleteByPartkeyReq cut version must large than TCaplusDeleteByPartkeyReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.OffSet)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyReq.OffSet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Limit)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyReq.Limit unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusDeleteByPartkeyReqCheckVersiontTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.CheckVersiontType)
		if err != nil {
			return errors.New("TCaplusDeleteByPartkeyReq.CheckVersiontType unpack error\n" + err.Error())
		}

	} else {
		this.CheckVersiontType = 1

	}
	return err
}

const (
	TCaplusDeleteByPartkeyResBaseVersion    uint32 = 41
	TCaplusDeleteByPartkeyResCurrentVersion uint32 = 41
)

// TCaplusDeleteByPartkeyRes
type TCaplusDeleteByPartkeyRes struct {
	Result int32 `tdr_field:"Result"`

	TotalNum int32 `tdr_field:"TotalNum"`

	OffSet int32 `tdr_field:"OffSet"`

	SucNum int32 `tdr_field:"SucNum"`

	SucKeysBuffLen int32 `tdr_field:"SucKeysBuffLen"`

	SucKeysBuff []byte `tdr_field:"SucKeysBuff" tdr_count:"10300000" tdr_refer:"SucKeysBuffLen"`

	FailNum int32 `tdr_field:"FailNum"`

	FailKeys *TCaplusKeySet `tdr_field:"FailKeys" tdr_count:"1"`

	IsCompleteFlag int32 `tdr_field:"IsCompleteFlag"`
}

func NewTCaplusDeleteByPartkeyRes() *TCaplusDeleteByPartkeyRes {
	obj := new(TCaplusDeleteByPartkeyRes)
	obj.Init()
	return obj
}

func (this *TCaplusDeleteByPartkeyRes) GetBaseVersion() uint32 {
	return TCaplusDeleteByPartkeyResBaseVersion
}

func (this *TCaplusDeleteByPartkeyRes) GetCurrentVersion() uint32 {
	return TCaplusDeleteByPartkeyResCurrentVersion
}

func (this *TCaplusDeleteByPartkeyRes) Init() {

	this.SucKeysBuffLen = 0

	this.FailKeys = NewTCaplusKeySet()

	this.IsCompleteFlag = 1

}

func (this *TCaplusDeleteByPartkeyRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusDeleteByPartkeyRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusDeleteByPartkeyRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusDeleteByPartkeyResCurrentVersion {
		cutVer = TCaplusDeleteByPartkeyResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusDeleteByPartkeyResBaseVersion {
		return errors.New("TCaplusDeleteByPartkeyRes cut version must large than TCaplusDeleteByPartkeyResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalNum)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.TotalNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.OffSet)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.OffSet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SucNum)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.SucNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SucKeysBuffLen)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuffLen pack error\n" + err.Error())
	}

	if this.SucKeysBuffLen < 0 {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should >= 0")
	}
	if this.SucKeysBuffLen > 10300000 {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should <= count 10300000")
	}
	if len(this.SucKeysBuff) < int(this.SucKeysBuffLen) {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff's length should > SucKeysBuffLen")
	}
	if this.SucKeysBuffLen > 0 {
		referSucKeysBuff := this.SucKeysBuff[:this.SucKeysBuffLen]
		err = binary.Write(w, binary.BigEndian, referSucKeysBuff)
		if err != nil {
			return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.FailNum)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.FailNum pack error\n" + err.Error())
	}

	err = this.FailKeys.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.FailKeys pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.IsCompleteFlag pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusDeleteByPartkeyRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusDeleteByPartkeyRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusDeleteByPartkeyRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusDeleteByPartkeyResCurrentVersion {
		cutVer = TCaplusDeleteByPartkeyResCurrentVersion
	}
	// check version
	if cutVer < TCaplusDeleteByPartkeyResBaseVersion {
		errors.New("TCaplusDeleteByPartkeyRes cut version must large than TCaplusDeleteByPartkeyResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalNum)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.TotalNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.OffSet)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.OffSet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SucNum)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.SucNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SucKeysBuffLen)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuffLen unpack error\n" + err.Error())
	}

	if this.SucKeysBuffLen < 0 {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should >= 0")
	}
	if this.SucKeysBuffLen > 10300000 {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff's refer SucKeysBuffLen should <= count 10300000")
	}

	if this.SucKeysBuff == nil {
		this.SucKeysBuff = make([]byte, int(this.SucKeysBuffLen))
	}

	referSucKeysBuff := this.SucKeysBuff[:this.SucKeysBuffLen]
	err = binary.Read(r, binary.BigEndian, referSucKeysBuff)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.SucKeysBuff pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.FailNum)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.FailNum unpack error\n" + err.Error())
	}

	err = this.FailKeys.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.FailKeys unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusDeleteByPartkeyRes.IsCompleteFlag unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusInsertByPartKeyReqBaseVersion    uint32 = 50
	TCaplusInsertByPartKeyReqCurrentVersion uint32 = 50
)

// TCaplusInsertByPartKeyReq
type TCaplusInsertByPartKeyReq struct {
	RecordNum uint32 `tdr_field:"RecordNum"`

	KeyInfoLen int32 `tdr_field:"KeyInfoLen"`

	KeyInfo []byte `tdr_field:"KeyInfo" tdr_count:"10300000" tdr_refer:"KeyInfoLen"`

	ValueInfoLen int32 `tdr_field:"ValueInfoLen"`

	ValueInfo []byte `tdr_field:"ValueInfo" tdr_count:"10300000" tdr_refer:"ValueInfoLen"`
}

func NewTCaplusInsertByPartKeyReq() *TCaplusInsertByPartKeyReq {
	obj := new(TCaplusInsertByPartKeyReq)
	obj.Init()
	return obj
}

func (this *TCaplusInsertByPartKeyReq) GetBaseVersion() uint32 {
	return TCaplusInsertByPartKeyReqBaseVersion
}

func (this *TCaplusInsertByPartKeyReq) GetCurrentVersion() uint32 {
	return TCaplusInsertByPartKeyReqCurrentVersion
}

func (this *TCaplusInsertByPartKeyReq) Init() {
	this.RecordNum = 0

	this.KeyInfoLen = 0

	this.ValueInfoLen = 0

}

func (this *TCaplusInsertByPartKeyReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusInsertByPartKeyReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusInsertByPartKeyReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusInsertByPartKeyReqCurrentVersion {
		cutVer = TCaplusInsertByPartKeyReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusInsertByPartKeyReqBaseVersion {
		return errors.New("TCaplusInsertByPartKeyReq cut version must large than TCaplusInsertByPartKeyReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.KeyInfoLen)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfoLen pack error\n" + err.Error())
	}

	if this.KeyInfoLen < 0 {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfo's refer KeyInfoLen should >= 0")
	}
	if this.KeyInfoLen > 10300000 {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfo's refer KeyInfoLen should <= count 10300000")
	}
	if len(this.KeyInfo) < int(this.KeyInfoLen) {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfo's length should > KeyInfoLen")
	}
	if this.KeyInfoLen > 0 {
		referKeyInfo := this.KeyInfo[:this.KeyInfoLen]
		err = binary.Write(w, binary.BigEndian, referKeyInfo)
		if err != nil {
			return errors.New("TCaplusInsertByPartKeyReq.KeyInfo pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.ValueInfoLen)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfoLen pack error\n" + err.Error())
	}

	if this.ValueInfoLen < 0 {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfo's refer ValueInfoLen should >= 0")
	}
	if this.ValueInfoLen > 10300000 {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfo's refer ValueInfoLen should <= count 10300000")
	}
	if len(this.ValueInfo) < int(this.ValueInfoLen) {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfo's length should > ValueInfoLen")
	}
	if this.ValueInfoLen > 0 {
		referValueInfo := this.ValueInfo[:this.ValueInfoLen]
		err = binary.Write(w, binary.BigEndian, referValueInfo)
		if err != nil {
			return errors.New("TCaplusInsertByPartKeyReq.ValueInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusInsertByPartKeyReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusInsertByPartKeyReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusInsertByPartKeyReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusInsertByPartKeyReqCurrentVersion {
		cutVer = TCaplusInsertByPartKeyReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusInsertByPartKeyReqBaseVersion {
		errors.New("TCaplusInsertByPartKeyReq cut version must large than TCaplusInsertByPartKeyReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyInfoLen)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfoLen unpack error\n" + err.Error())
	}

	if this.KeyInfoLen < 0 {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfo's refer KeyInfoLen should >= 0")
	}
	if this.KeyInfoLen > 10300000 {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfo's refer KeyInfoLen should <= count 10300000")
	}

	if this.KeyInfo == nil {
		this.KeyInfo = make([]byte, int(this.KeyInfoLen))
	}

	referKeyInfo := this.KeyInfo[:this.KeyInfoLen]
	err = binary.Read(r, binary.BigEndian, referKeyInfo)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.KeyInfo pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ValueInfoLen)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfoLen unpack error\n" + err.Error())
	}

	if this.ValueInfoLen < 0 {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfo's refer ValueInfoLen should >= 0")
	}
	if this.ValueInfoLen > 10300000 {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfo's refer ValueInfoLen should <= count 10300000")
	}

	if this.ValueInfo == nil {
		this.ValueInfo = make([]byte, int(this.ValueInfoLen))
	}

	referValueInfo := this.ValueInfo[:this.ValueInfoLen]
	err = binary.Read(r, binary.BigEndian, referValueInfo)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyReq.ValueInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusInsertByPartKeyResBaseVersion    uint32 = 50
	TCaplusInsertByPartKeyResCurrentVersion uint32 = 50
)

// TCaplusInsertByPartKeyRes
type TCaplusInsertByPartKeyRes struct {
	Result int32 `tdr_field:"Result"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	RecordResult []int32 `tdr_field:"RecordResult" tdr_count:"1024" tdr_refer:"RecordNum"`

	KeyInfoLen int32 `tdr_field:"KeyInfoLen"`

	KeyInfo []byte `tdr_field:"KeyInfo" tdr_count:"10300000" tdr_refer:"KeyInfoLen"`
}

func NewTCaplusInsertByPartKeyRes() *TCaplusInsertByPartKeyRes {
	obj := new(TCaplusInsertByPartKeyRes)
	obj.Init()
	return obj
}

func (this *TCaplusInsertByPartKeyRes) GetBaseVersion() uint32 {
	return TCaplusInsertByPartKeyResBaseVersion
}

func (this *TCaplusInsertByPartKeyRes) GetCurrentVersion() uint32 {
	return TCaplusInsertByPartKeyResCurrentVersion
}

func (this *TCaplusInsertByPartKeyRes) Init() {

	this.RecordNum = 0

	this.KeyInfoLen = 0

}

func (this *TCaplusInsertByPartKeyRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusInsertByPartKeyRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusInsertByPartKeyRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusInsertByPartKeyResCurrentVersion {
		cutVer = TCaplusInsertByPartKeyResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusInsertByPartKeyResBaseVersion {
		return errors.New("TCaplusInsertByPartKeyRes cut version must large than TCaplusInsertByPartKeyResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.RecordNum pack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusInsertByPartKeyRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusInsertByPartKeyRes.RecordResult's refer RecordNum should <= count 1024")
	}
	if len(this.RecordResult) < int(this.RecordNum) {
		return errors.New("TCaplusInsertByPartKeyRes.RecordResult's length should > RecordNum")
	}
	if this.RecordNum > 0 {
		referRecordResult := this.RecordResult[:this.RecordNum]
		err = binary.Write(w, binary.BigEndian, referRecordResult)
		if err != nil {
			return errors.New("TCaplusInsertByPartKeyRes.RecordResult pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.KeyInfoLen)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfoLen pack error\n" + err.Error())
	}

	if this.KeyInfoLen < 0 {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfo's refer KeyInfoLen should >= 0")
	}
	if this.KeyInfoLen > 10300000 {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfo's refer KeyInfoLen should <= count 10300000")
	}
	if len(this.KeyInfo) < int(this.KeyInfoLen) {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfo's length should > KeyInfoLen")
	}
	if this.KeyInfoLen > 0 {
		referKeyInfo := this.KeyInfo[:this.KeyInfoLen]
		err = binary.Write(w, binary.BigEndian, referKeyInfo)
		if err != nil {
			return errors.New("TCaplusInsertByPartKeyRes.KeyInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusInsertByPartKeyRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusInsertByPartKeyRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusInsertByPartKeyRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusInsertByPartKeyResCurrentVersion {
		cutVer = TCaplusInsertByPartKeyResCurrentVersion
	}
	// check version
	if cutVer < TCaplusInsertByPartKeyResBaseVersion {
		errors.New("TCaplusInsertByPartKeyRes cut version must large than TCaplusInsertByPartKeyResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.RecordNum unpack error\n" + err.Error())
	}

	if this.RecordNum < 0 {
		return errors.New("TCaplusInsertByPartKeyRes.RecordResult's refer RecordNum should >= 0")
	}
	if this.RecordNum > 1024 {
		return errors.New("TCaplusInsertByPartKeyRes.RecordResult's refer RecordNum should <= count 1024")
	}

	if this.RecordResult == nil {
		this.RecordResult = make([]int32, int(this.RecordNum))
	}

	referRecordResult := this.RecordResult[:this.RecordNum]
	err = binary.Read(r, binary.BigEndian, referRecordResult)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.RecordResult pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyInfoLen)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfoLen unpack error\n" + err.Error())
	}

	if this.KeyInfoLen < 0 {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfo's refer KeyInfoLen should >= 0")
	}
	if this.KeyInfoLen > 10300000 {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfo's refer KeyInfoLen should <= count 10300000")
	}

	if this.KeyInfo == nil {
		this.KeyInfo = make([]byte, int(this.KeyInfoLen))
	}

	referKeyInfo := this.KeyInfo[:this.KeyInfoLen]
	err = binary.Read(r, binary.BigEndian, referKeyInfo)
	if err != nil {
		return errors.New("TCaplusInsertByPartKeyRes.KeyInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMetadataGetReqBaseVersion    uint32 = 1
	TCaplusMetadataGetReqCurrentVersion uint32 = 1
)

// TCaplusMetadataGetReq
type TCaplusMetadataGetReq struct {
	MetadataVersion uint32 `tdr_field:"MetadataVersion"`
}

func NewTCaplusMetadataGetReq() *TCaplusMetadataGetReq {
	obj := new(TCaplusMetadataGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusMetadataGetReq) GetBaseVersion() uint32 {
	return TCaplusMetadataGetReqBaseVersion
}

func (this *TCaplusMetadataGetReq) GetCurrentVersion() uint32 {
	return TCaplusMetadataGetReqCurrentVersion
}

func (this *TCaplusMetadataGetReq) Init() {
	this.MetadataVersion = 0

}

func (this *TCaplusMetadataGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMetadataGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMetadataGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMetadataGetReqCurrentVersion {
		cutVer = TCaplusMetadataGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMetadataGetReqBaseVersion {
		return errors.New("TCaplusMetadataGetReq cut version must large than TCaplusMetadataGetReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.MetadataVersion)
	if err != nil {
		return errors.New("TCaplusMetadataGetReq.MetadataVersion pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMetadataGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMetadataGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMetadataGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMetadataGetReqCurrentVersion {
		cutVer = TCaplusMetadataGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMetadataGetReqBaseVersion {
		errors.New("TCaplusMetadataGetReq cut version must large than TCaplusMetadataGetReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.MetadataVersion)
	if err != nil {
		return errors.New("TCaplusMetadataGetReq.MetadataVersion unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMetadataGetResBaseVersion                  uint32 = 1
	TCaplusMetadataGetResCurrentVersion               uint32 = 78
	TCaplusMetadataGetResTdrMetaCurrentVersionVersion uint32 = 15
	TCaplusMetadataGetResIdlTypeVersion               uint32 = 78
	TCaplusMetadataGetResIdlConLenVersion             uint32 = 78
	TCaplusMetadataGetResIdlContentVersion            uint32 = 78
)

// TCaplusMetadataGetRes
type TCaplusMetadataGetRes struct {
	Result int32 `tdr_field:"Result"`

	MetadataVersion uint32 `tdr_field:"MetadataVersion"`

	TcaplusType uint32 `tdr_field:"TcaplusType"`

	ListMaxElementNum int32 `tdr_field:"ListMaxElementNum"`

	KeyMetadata *TCaplusKeyMetadataSet `tdr_field:"KeyMetadata"`

	ValueMetadata *TCaplusValueMetadataSet `tdr_field:"ValueMetadata"`

	TdrMetaCurrentVersion int32 `tdr_field:"TdrMetaCurrentVersion"`

	IdlType int32 `tdr_field:"IdlType"`

	IdlConLen int32 `tdr_field:"IdlConLen"`

	IdlContent []byte `tdr_field:"IdlContent" tdr_count:"10485760" tdr_refer:"IdlConLen"`
}

func NewTCaplusMetadataGetRes() *TCaplusMetadataGetRes {
	obj := new(TCaplusMetadataGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusMetadataGetRes) GetBaseVersion() uint32 {
	return TCaplusMetadataGetResBaseVersion
}

func (this *TCaplusMetadataGetRes) GetCurrentVersion() uint32 {
	return TCaplusMetadataGetResCurrentVersion
}

func (this *TCaplusMetadataGetRes) Init() {

	this.MetadataVersion = 0

	this.TcaplusType = 0

	this.ListMaxElementNum = 0

	this.KeyMetadata = NewTCaplusKeyMetadataSet()

	this.ValueMetadata = NewTCaplusValueMetadataSet()

	this.TdrMetaCurrentVersion = -1

	this.IdlType = 1

	this.IdlConLen = 0

}

func (this *TCaplusMetadataGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMetadataGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMetadataGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMetadataGetResCurrentVersion {
		cutVer = TCaplusMetadataGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMetadataGetResBaseVersion {
		return errors.New("TCaplusMetadataGetRes cut version must large than TCaplusMetadataGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MetadataVersion)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.MetadataVersion pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TcaplusType)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.TcaplusType pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ListMaxElementNum)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.ListMaxElementNum pack error\n" + err.Error())
	}

	err = this.KeyMetadata.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.KeyMetadata pack error\n" + err.Error())
	}

	err = this.ValueMetadata.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.ValueMetadata pack error\n" + err.Error())
	}

	if cutVer >= TCaplusMetadataGetResTdrMetaCurrentVersionVersion {

		err = binary.Write(w, binary.BigEndian, this.TdrMetaCurrentVersion)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.TdrMetaCurrentVersion pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMetadataGetResIdlTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.IdlType)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.IdlType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMetadataGetResIdlConLenVersion {

		err = binary.Write(w, binary.BigEndian, this.IdlConLen)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.IdlConLen pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMetadataGetResIdlContentVersion {

		if this.IdlConLen < 0 {
			return errors.New("TCaplusMetadataGetRes.IdlContent's refer IdlConLen should >= 0")
		}
		if this.IdlConLen > 10485760 {
			return errors.New("TCaplusMetadataGetRes.IdlContent's refer IdlConLen should <= count 10485760")
		}
		if len(this.IdlContent) < int(this.IdlConLen) {
			return errors.New("TCaplusMetadataGetRes.IdlContent's length should > IdlConLen")
		}
		if this.IdlConLen > 0 {
			referIdlContent := this.IdlContent[:this.IdlConLen]
			err = binary.Write(w, binary.BigEndian, referIdlContent)
			if err != nil {
				return errors.New("TCaplusMetadataGetRes.IdlContent pack error\n" + err.Error())
			}
		}

	}

	return nil
}

func (this *TCaplusMetadataGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMetadataGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMetadataGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMetadataGetResCurrentVersion {
		cutVer = TCaplusMetadataGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMetadataGetResBaseVersion {
		errors.New("TCaplusMetadataGetRes cut version must large than TCaplusMetadataGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.MetadataVersion)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.MetadataVersion unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TcaplusType)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.TcaplusType unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ListMaxElementNum)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.ListMaxElementNum unpack error\n" + err.Error())
	}

	err = this.KeyMetadata.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.KeyMetadata unpack error\n" + err.Error())
	}

	err = this.ValueMetadata.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMetadataGetRes.ValueMetadata unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusMetadataGetResTdrMetaCurrentVersionVersion {

		err = binary.Read(r, binary.BigEndian, &this.TdrMetaCurrentVersion)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.TdrMetaCurrentVersion unpack error\n" + err.Error())
		}

	} else {
		this.TdrMetaCurrentVersion = -1

	}
	if cutVer >= TCaplusMetadataGetResIdlTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.IdlType)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.IdlType unpack error\n" + err.Error())
		}

	} else {
		this.IdlType = 1

	}
	if cutVer >= TCaplusMetadataGetResIdlConLenVersion {

		err = binary.Read(r, binary.BigEndian, &this.IdlConLen)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.IdlConLen unpack error\n" + err.Error())
		}

	} else {
		this.IdlConLen = 0

	}
	if cutVer >= TCaplusMetadataGetResIdlContentVersion {

		if this.IdlConLen < 0 {
			return errors.New("TCaplusMetadataGetRes.IdlContent's refer IdlConLen should >= 0")
		}
		if this.IdlConLen > 10485760 {
			return errors.New("TCaplusMetadataGetRes.IdlContent's refer IdlConLen should <= count 10485760")
		}

		if this.IdlContent == nil {
			this.IdlContent = make([]byte, int(this.IdlConLen))
		}

		referIdlContent := this.IdlContent[:this.IdlConLen]
		err = binary.Read(r, binary.BigEndian, referIdlContent)
		if err != nil {
			return errors.New("TCaplusMetadataGetRes.IdlContent pack error\n" + err.Error())
		}

	}
	return err
}

const (
	TCaplusSpecialGetReqBaseVersion    uint32 = 1
	TCaplusSpecialGetReqCurrentVersion uint32 = 1
)

// TCaplusSpecialGetReq
type TCaplusSpecialGetReq struct {
	GetFlag int32 `tdr_field:"GetFlag"`
}

func NewTCaplusSpecialGetReq() *TCaplusSpecialGetReq {
	obj := new(TCaplusSpecialGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusSpecialGetReq) GetBaseVersion() uint32 {
	return TCaplusSpecialGetReqBaseVersion
}

func (this *TCaplusSpecialGetReq) GetCurrentVersion() uint32 {
	return TCaplusSpecialGetReqCurrentVersion
}

func (this *TCaplusSpecialGetReq) Init() {

}

func (this *TCaplusSpecialGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSpecialGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSpecialGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSpecialGetReqCurrentVersion {
		cutVer = TCaplusSpecialGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSpecialGetReqBaseVersion {
		return errors.New("TCaplusSpecialGetReq cut version must large than TCaplusSpecialGetReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.GetFlag)
	if err != nil {
		return errors.New("TCaplusSpecialGetReq.GetFlag pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSpecialGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSpecialGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSpecialGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSpecialGetReqCurrentVersion {
		cutVer = TCaplusSpecialGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSpecialGetReqBaseVersion {
		errors.New("TCaplusSpecialGetReq cut version must large than TCaplusSpecialGetReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.GetFlag)
	if err != nil {
		return errors.New("TCaplusSpecialGetReq.GetFlag unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusRecordPropertyBaseVersion    uint32 = 54
	TCaplusRecordPropertyCurrentVersion uint32 = 54
)

// TCaplusRecordProperty
type TCaplusRecordProperty struct {
	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusRecordProperty() *TCaplusRecordProperty {
	obj := new(TCaplusRecordProperty)
	obj.Init()
	return obj
}

func (this *TCaplusRecordProperty) GetBaseVersion() uint32 {
	return TCaplusRecordPropertyBaseVersion
}

func (this *TCaplusRecordProperty) GetCurrentVersion() uint32 {
	return TCaplusRecordPropertyCurrentVersion
}

func (this *TCaplusRecordProperty) Init() {
	this.LastAccessTime = 0

}

func (this *TCaplusRecordProperty) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusRecordProperty Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusRecordProperty) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusRecordPropertyCurrentVersion {
		cutVer = TCaplusRecordPropertyCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusRecordPropertyBaseVersion {
		return errors.New("TCaplusRecordProperty cut version must large than TCaplusRecordPropertyBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusRecordProperty.LastAccessTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusRecordProperty) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusRecordProperty data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusRecordProperty) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusRecordPropertyCurrentVersion {
		cutVer = TCaplusRecordPropertyCurrentVersion
	}
	// check version
	if cutVer < TCaplusRecordPropertyBaseVersion {
		errors.New("TCaplusRecordProperty cut version must large than TCaplusRecordPropertyBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusRecordProperty.LastAccessTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSpecialGetResBaseVersion    uint32 = 1
	TCaplusSpecialGetResCurrentVersion uint32 = 109
)

// TCaplusSpecialGetRes
type TCaplusSpecialGetRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusSpecialGetRes() *TCaplusSpecialGetRes {
	obj := new(TCaplusSpecialGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusSpecialGetRes) GetBaseVersion() uint32 {
	return TCaplusSpecialGetResBaseVersion
}

func (this *TCaplusSpecialGetRes) GetCurrentVersion() uint32 {
	return TCaplusSpecialGetResCurrentVersion
}

func (this *TCaplusSpecialGetRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusSpecialGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSpecialGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSpecialGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSpecialGetResCurrentVersion {
		cutVer = TCaplusSpecialGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSpecialGetResBaseVersion {
		return errors.New("TCaplusSpecialGetRes cut version must large than TCaplusSpecialGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSpecialGetRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSpecialGetRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSpecialGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSpecialGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSpecialGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSpecialGetResCurrentVersion {
		cutVer = TCaplusSpecialGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSpecialGetResBaseVersion {
		errors.New("TCaplusSpecialGetRes cut version must large than TCaplusSpecialGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSpecialGetRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSpecialGetRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMoveInfoBaseVersion    uint32 = 8
	TCaplusMoveInfoCurrentVersion uint32 = 8
)

// TCaplusMoveInfo
type TCaplusMoveInfo struct {
	Offset uint64 `tdr_field:"Offset"`

	CurSec uint64 `tdr_field:"CurSec"`

	CurUSec uint64 `tdr_field:"CurUSec"`

	RetryCount uint16 `tdr_field:"RetryCount"`

	InMem byte `tdr_field:"InMem"`
}

func NewTCaplusMoveInfo() *TCaplusMoveInfo {
	obj := new(TCaplusMoveInfo)
	obj.Init()
	return obj
}

func (this *TCaplusMoveInfo) GetBaseVersion() uint32 {
	return TCaplusMoveInfoBaseVersion
}

func (this *TCaplusMoveInfo) GetCurrentVersion() uint32 {
	return TCaplusMoveInfoCurrentVersion
}

func (this *TCaplusMoveInfo) Init() {

}

func (this *TCaplusMoveInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMoveInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMoveInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMoveInfoCurrentVersion {
		cutVer = TCaplusMoveInfoCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMoveInfoBaseVersion {
		return errors.New("TCaplusMoveInfo cut version must large than TCaplusMoveInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Offset)
	if err != nil {
		return errors.New("TCaplusMoveInfo.Offset pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CurSec)
	if err != nil {
		return errors.New("TCaplusMoveInfo.CurSec pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CurUSec)
	if err != nil {
		return errors.New("TCaplusMoveInfo.CurUSec pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RetryCount)
	if err != nil {
		return errors.New("TCaplusMoveInfo.RetryCount pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.InMem)
	if err != nil {
		return errors.New("TCaplusMoveInfo.InMem pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMoveInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMoveInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMoveInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMoveInfoCurrentVersion {
		cutVer = TCaplusMoveInfoCurrentVersion
	}
	// check version
	if cutVer < TCaplusMoveInfoBaseVersion {
		errors.New("TCaplusMoveInfo cut version must large than TCaplusMoveInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Offset)
	if err != nil {
		return errors.New("TCaplusMoveInfo.Offset unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CurSec)
	if err != nil {
		return errors.New("TCaplusMoveInfo.CurSec unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CurUSec)
	if err != nil {
		return errors.New("TCaplusMoveInfo.CurUSec unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RetryCount)
	if err != nil {
		return errors.New("TCaplusMoveInfo.RetryCount unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.InMem)
	if err != nil {
		return errors.New("TCaplusMoveInfo.InMem unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMoveInsertReqBaseVersion           uint32 = 1
	TCaplusMoveInsertReqCurrentVersion        uint32 = 109
	TCaplusMoveInsertReqRecordPropertyVersion uint32 = 54
)

// TCaplusMoveInsertReq
type TCaplusMoveInsertReq struct {
	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`
}

func NewTCaplusMoveInsertReq() *TCaplusMoveInsertReq {
	obj := new(TCaplusMoveInsertReq)
	obj.Init()
	return obj
}

func (this *TCaplusMoveInsertReq) GetBaseVersion() uint32 {
	return TCaplusMoveInsertReqBaseVersion
}

func (this *TCaplusMoveInsertReq) GetCurrentVersion() uint32 {
	return TCaplusMoveInsertReqCurrentVersion
}

func (this *TCaplusMoveInsertReq) Init() {
	this.ValueInfo = NewTCaplusValueSet_()

	this.RecordProperty = NewTCaplusRecordProperty()

}

func (this *TCaplusMoveInsertReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMoveInsertReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMoveInsertReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMoveInsertReqCurrentVersion {
		cutVer = TCaplusMoveInsertReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMoveInsertReqBaseVersion {
		return errors.New("TCaplusMoveInsertReq cut version must large than TCaplusMoveInsertReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMoveInsertReq.ValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusMoveInsertReqRecordPropertyVersion {

		err = this.RecordProperty.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusMoveInsertReq.RecordProperty pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusMoveInsertReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMoveInsertReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMoveInsertReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMoveInsertReqCurrentVersion {
		cutVer = TCaplusMoveInsertReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMoveInsertReqBaseVersion {
		errors.New("TCaplusMoveInsertReq cut version must large than TCaplusMoveInsertReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMoveInsertReq.ValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusMoveInsertReqRecordPropertyVersion {

		err = this.RecordProperty.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusMoveInsertReq.RecordProperty unpack error\n" + err.Error())
		}

	} else {
		this.RecordProperty.Init()

	}
	return err
}

const (
	TCaplusMoveInsertResBaseVersion    uint32 = 1
	TCaplusMoveInsertResCurrentVersion uint32 = 1
)

// TCaplusMoveInsertRes
type TCaplusMoveInsertRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMoveInsertRes() *TCaplusMoveInsertRes {
	obj := new(TCaplusMoveInsertRes)
	obj.Init()
	return obj
}

func (this *TCaplusMoveInsertRes) GetBaseVersion() uint32 {
	return TCaplusMoveInsertResBaseVersion
}

func (this *TCaplusMoveInsertRes) GetCurrentVersion() uint32 {
	return TCaplusMoveInsertResCurrentVersion
}

func (this *TCaplusMoveInsertRes) Init() {

}

func (this *TCaplusMoveInsertRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMoveInsertRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMoveInsertRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMoveInsertResCurrentVersion {
		cutVer = TCaplusMoveInsertResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMoveInsertResBaseVersion {
		return errors.New("TCaplusMoveInsertRes cut version must large than TCaplusMoveInsertResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMoveInsertRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMoveInsertRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMoveInsertRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMoveInsertRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMoveInsertResCurrentVersion {
		cutVer = TCaplusMoveInsertResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMoveInsertResBaseVersion {
		errors.New("TCaplusMoveInsertRes cut version must large than TCaplusMoveInsertResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMoveInsertRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListIndexMoveInsertReqBaseVersion           uint32 = 8
	TCaplusListIndexMoveInsertReqCurrentVersion        uint32 = 91
	TCaplusListIndexMoveInsertReqRecordPropertyVersion uint32 = 58
)

// TCaplusListIndexMoveInsertReq
type TCaplusListIndexMoveInsertReq struct {
	ListIndex *TcapListIndex `tdr_field:"ListIndex"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`
}

func NewTCaplusListIndexMoveInsertReq() *TCaplusListIndexMoveInsertReq {
	obj := new(TCaplusListIndexMoveInsertReq)
	obj.Init()
	return obj
}

func (this *TCaplusListIndexMoveInsertReq) GetBaseVersion() uint32 {
	return TCaplusListIndexMoveInsertReqBaseVersion
}

func (this *TCaplusListIndexMoveInsertReq) GetCurrentVersion() uint32 {
	return TCaplusListIndexMoveInsertReqCurrentVersion
}

func (this *TCaplusListIndexMoveInsertReq) Init() {
	this.ListIndex = NewTcapListIndex()

	this.RecordProperty = NewTCaplusRecordProperty()

}

func (this *TCaplusListIndexMoveInsertReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListIndexMoveInsertReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListIndexMoveInsertReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveInsertReqCurrentVersion {
		cutVer = TCaplusListIndexMoveInsertReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListIndexMoveInsertReqBaseVersion {
		return errors.New("TCaplusListIndexMoveInsertReq cut version must large than TCaplusListIndexMoveInsertReqBaseVersion\n")
	}

	var err error

	err = this.ListIndex.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListIndexMoveInsertReq.ListIndex pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListIndexMoveInsertReqRecordPropertyVersion {

		err = this.RecordProperty.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListIndexMoveInsertReq.RecordProperty pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListIndexMoveInsertReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListIndexMoveInsertReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListIndexMoveInsertReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveInsertReqCurrentVersion {
		cutVer = TCaplusListIndexMoveInsertReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListIndexMoveInsertReqBaseVersion {
		errors.New("TCaplusListIndexMoveInsertReq cut version must large than TCaplusListIndexMoveInsertReqBaseVersion\n")
	}

	err = this.ListIndex.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListIndexMoveInsertReq.ListIndex unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListIndexMoveInsertReqRecordPropertyVersion {

		err = this.RecordProperty.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListIndexMoveInsertReq.RecordProperty unpack error\n" + err.Error())
		}

	} else {
		this.RecordProperty.Init()

	}
	return err
}

const (
	TCaplusListIndexMoveInsertResBaseVersion    uint32 = 8
	TCaplusListIndexMoveInsertResCurrentVersion uint32 = 8
)

// TCaplusListIndexMoveInsertRes
type TCaplusListIndexMoveInsertRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListIndexMoveInsertRes() *TCaplusListIndexMoveInsertRes {
	obj := new(TCaplusListIndexMoveInsertRes)
	obj.Init()
	return obj
}

func (this *TCaplusListIndexMoveInsertRes) GetBaseVersion() uint32 {
	return TCaplusListIndexMoveInsertResBaseVersion
}

func (this *TCaplusListIndexMoveInsertRes) GetCurrentVersion() uint32 {
	return TCaplusListIndexMoveInsertResCurrentVersion
}

func (this *TCaplusListIndexMoveInsertRes) Init() {

}

func (this *TCaplusListIndexMoveInsertRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListIndexMoveInsertRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListIndexMoveInsertRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveInsertResCurrentVersion {
		cutVer = TCaplusListIndexMoveInsertResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListIndexMoveInsertResBaseVersion {
		return errors.New("TCaplusListIndexMoveInsertRes cut version must large than TCaplusListIndexMoveInsertResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListIndexMoveInsertRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListIndexMoveInsertRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListIndexMoveInsertRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListIndexMoveInsertRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveInsertResCurrentVersion {
		cutVer = TCaplusListIndexMoveInsertResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListIndexMoveInsertResBaseVersion {
		errors.New("TCaplusListIndexMoveInsertRes cut version must large than TCaplusListIndexMoveInsertResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListIndexMoveInsertRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListElemMoveInsertReqBaseVersion           uint32 = 8
	TCaplusListElemMoveInsertReqCurrentVersion        uint32 = 109
	TCaplusListElemMoveInsertReqRecordPropertyVersion uint32 = 54
)

// TCaplusListElemMoveInsertReq
type TCaplusListElemMoveInsertReq struct {
	ElementValueInfo *TCaplusValueSet_ `tdr_field:"ElementValueInfo"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`
}

func NewTCaplusListElemMoveInsertReq() *TCaplusListElemMoveInsertReq {
	obj := new(TCaplusListElemMoveInsertReq)
	obj.Init()
	return obj
}

func (this *TCaplusListElemMoveInsertReq) GetBaseVersion() uint32 {
	return TCaplusListElemMoveInsertReqBaseVersion
}

func (this *TCaplusListElemMoveInsertReq) GetCurrentVersion() uint32 {
	return TCaplusListElemMoveInsertReqCurrentVersion
}

func (this *TCaplusListElemMoveInsertReq) Init() {
	this.ElementValueInfo = NewTCaplusValueSet_()

	this.RecordProperty = NewTCaplusRecordProperty()

}

func (this *TCaplusListElemMoveInsertReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListElemMoveInsertReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListElemMoveInsertReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListElemMoveInsertReqCurrentVersion {
		cutVer = TCaplusListElemMoveInsertReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListElemMoveInsertReqBaseVersion {
		return errors.New("TCaplusListElemMoveInsertReq cut version must large than TCaplusListElemMoveInsertReqBaseVersion\n")
	}

	var err error

	err = this.ElementValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListElemMoveInsertReq.ElementValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListElemMoveInsertReqRecordPropertyVersion {

		err = this.RecordProperty.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusListElemMoveInsertReq.RecordProperty pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListElemMoveInsertReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListElemMoveInsertReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListElemMoveInsertReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListElemMoveInsertReqCurrentVersion {
		cutVer = TCaplusListElemMoveInsertReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListElemMoveInsertReqBaseVersion {
		errors.New("TCaplusListElemMoveInsertReq cut version must large than TCaplusListElemMoveInsertReqBaseVersion\n")
	}

	err = this.ElementValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListElemMoveInsertReq.ElementValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListElemMoveInsertReqRecordPropertyVersion {

		err = this.RecordProperty.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusListElemMoveInsertReq.RecordProperty unpack error\n" + err.Error())
		}

	} else {
		this.RecordProperty.Init()

	}
	return err
}

const (
	TCaplusListElemMoveInsertResBaseVersion    uint32 = 8
	TCaplusListElemMoveInsertResCurrentVersion uint32 = 8
)

// TCaplusListElemMoveInsertRes
type TCaplusListElemMoveInsertRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListElemMoveInsertRes() *TCaplusListElemMoveInsertRes {
	obj := new(TCaplusListElemMoveInsertRes)
	obj.Init()
	return obj
}

func (this *TCaplusListElemMoveInsertRes) GetBaseVersion() uint32 {
	return TCaplusListElemMoveInsertResBaseVersion
}

func (this *TCaplusListElemMoveInsertRes) GetCurrentVersion() uint32 {
	return TCaplusListElemMoveInsertResCurrentVersion
}

func (this *TCaplusListElemMoveInsertRes) Init() {

}

func (this *TCaplusListElemMoveInsertRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListElemMoveInsertRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListElemMoveInsertRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListElemMoveInsertResCurrentVersion {
		cutVer = TCaplusListElemMoveInsertResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListElemMoveInsertResBaseVersion {
		return errors.New("TCaplusListElemMoveInsertRes cut version must large than TCaplusListElemMoveInsertResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListElemMoveInsertRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListElemMoveInsertRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListElemMoveInsertRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListElemMoveInsertRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListElemMoveInsertResCurrentVersion {
		cutVer = TCaplusListElemMoveInsertResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListElemMoveInsertResBaseVersion {
		errors.New("TCaplusListElemMoveInsertRes cut version must large than TCaplusListElemMoveInsertResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListElemMoveInsertRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncRecordBaseVersion                   uint32 = 3
	TCaplusMsSyncRecordCurrentVersion                uint32 = 89
	TCaplusMsSyncRecordListElementIndexVersion       uint32 = 7
	TCaplusMsSyncRecordListIndexArrayBuffLenVersion  uint32 = 7
	TCaplusMsSyncRecordListIndexArrayBuffVersion     uint32 = 7
	TCaplusMsSyncRecordListBatchIndexArrayNumVersion uint32 = 89
	TCaplusMsSyncRecordListBatchIndexArrayVersion    uint32 = 89
	TCaplusMsSyncRecordLastAccessTimeVersion         uint32 = 56
)

// TCaplusMsSyncRecord
type TCaplusMsSyncRecord struct {
	Mode uint32 `tdr_field:"Mode"`

	KeyBuffLen uint32 `tdr_field:"KeyBuffLen"`

	KeyBuff []byte `tdr_field:"KeyBuff" tdr_count:"8192" tdr_refer:"KeyBuffLen"`

	ValueBuffLen uint32 `tdr_field:"ValueBuffLen"`

	ValueBuff []byte `tdr_field:"ValueBuff" tdr_count:"10300000" tdr_refer:"ValueBuffLen"`

	ListElementIndex int32 `tdr_field:"ListElementIndex"`

	ListIndexArrayBuffLen int32 `tdr_field:"ListIndexArrayBuffLen"`

	ListIndexArrayBuff []byte `tdr_field:"ListIndexArrayBuff" tdr_count:"1000000" tdr_refer:"ListIndexArrayBuffLen"`

	ListBatchIndexArrayNum int32 `tdr_field:"ListBatchIndexArrayNum"`

	ListBatchIndexArray []int32 `tdr_field:"ListBatchIndexArray" tdr_count:"10240" tdr_refer:"ListBatchIndexArrayNum"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusMsSyncRecord() *TCaplusMsSyncRecord {
	obj := new(TCaplusMsSyncRecord)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncRecord) GetBaseVersion() uint32 {
	return TCaplusMsSyncRecordBaseVersion
}

func (this *TCaplusMsSyncRecord) GetCurrentVersion() uint32 {
	return TCaplusMsSyncRecordCurrentVersion
}

func (this *TCaplusMsSyncRecord) Init() {

	this.KeyBuffLen = 0

	this.ValueBuffLen = 0

	this.ListElementIndex = 0

	this.ListIndexArrayBuffLen = 0

	this.ListBatchIndexArrayNum = 0

	this.LastAccessTime = 0

}

func (this *TCaplusMsSyncRecord) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncRecord Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncRecord) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncRecordCurrentVersion {
		cutVer = TCaplusMsSyncRecordCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncRecordBaseVersion {
		return errors.New("TCaplusMsSyncRecord cut version must large than TCaplusMsSyncRecordBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Mode)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.Mode pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.KeyBuffLen)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.KeyBuffLen pack error\n" + err.Error())
	}

	if this.KeyBuffLen < 0 {
		return errors.New("TCaplusMsSyncRecord.KeyBuff's refer KeyBuffLen should >= 0")
	}
	if this.KeyBuffLen > 8192 {
		return errors.New("TCaplusMsSyncRecord.KeyBuff's refer KeyBuffLen should <= count 8192")
	}
	if len(this.KeyBuff) < int(this.KeyBuffLen) {
		return errors.New("TCaplusMsSyncRecord.KeyBuff's length should > KeyBuffLen")
	}
	if this.KeyBuffLen > 0 {
		referKeyBuff := this.KeyBuff[:this.KeyBuffLen]
		err = binary.Write(w, binary.BigEndian, referKeyBuff)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.KeyBuff pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.ValueBuffLen)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.ValueBuffLen pack error\n" + err.Error())
	}

	if this.ValueBuffLen < 0 {
		return errors.New("TCaplusMsSyncRecord.ValueBuff's refer ValueBuffLen should >= 0")
	}
	if this.ValueBuffLen > 10300000 {
		return errors.New("TCaplusMsSyncRecord.ValueBuff's refer ValueBuffLen should <= count 10300000")
	}
	if len(this.ValueBuff) < int(this.ValueBuffLen) {
		return errors.New("TCaplusMsSyncRecord.ValueBuff's length should > ValueBuffLen")
	}
	if this.ValueBuffLen > 0 {
		referValueBuff := this.ValueBuff[:this.ValueBuffLen]
		err = binary.Write(w, binary.BigEndian, referValueBuff)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ValueBuff pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusMsSyncRecordListElementIndexVersion {

		err = binary.Write(w, binary.BigEndian, this.ListElementIndex)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListElementIndex pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMsSyncRecordListIndexArrayBuffLenVersion {

		err = binary.Write(w, binary.BigEndian, this.ListIndexArrayBuffLen)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuffLen pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMsSyncRecordListIndexArrayBuffVersion {

		if this.ListIndexArrayBuffLen < 0 {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff's refer ListIndexArrayBuffLen should >= 0")
		}
		if this.ListIndexArrayBuffLen > 1000000 {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff's refer ListIndexArrayBuffLen should <= count 1000000")
		}
		if len(this.ListIndexArrayBuff) < int(this.ListIndexArrayBuffLen) {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff's length should > ListIndexArrayBuffLen")
		}
		if this.ListIndexArrayBuffLen > 0 {
			referListIndexArrayBuff := this.ListIndexArrayBuff[:this.ListIndexArrayBuffLen]
			err = binary.Write(w, binary.BigEndian, referListIndexArrayBuff)
			if err != nil {
				return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff pack error\n" + err.Error())
			}
		}

	}
	if cutVer >= TCaplusMsSyncRecordListBatchIndexArrayNumVersion {

		err = binary.Write(w, binary.BigEndian, this.ListBatchIndexArrayNum)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArrayNum pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMsSyncRecordListBatchIndexArrayVersion {

		if this.ListBatchIndexArrayNum < 0 {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray's refer ListBatchIndexArrayNum should >= 0")
		}
		if this.ListBatchIndexArrayNum > 10240 {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray's refer ListBatchIndexArrayNum should <= count 10240")
		}
		if len(this.ListBatchIndexArray) < int(this.ListBatchIndexArrayNum) {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray's length should > ListBatchIndexArrayNum")
		}
		if this.ListBatchIndexArrayNum > 0 {
			referListBatchIndexArray := this.ListBatchIndexArray[:this.ListBatchIndexArrayNum]
			err = binary.Write(w, binary.BigEndian, referListBatchIndexArray)
			if err != nil {
				return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray pack error\n" + err.Error())
			}
		}

	}
	if cutVer >= TCaplusMsSyncRecordLastAccessTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.LastAccessTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusMsSyncRecord) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncRecord data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncRecord) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncRecordCurrentVersion {
		cutVer = TCaplusMsSyncRecordCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncRecordBaseVersion {
		errors.New("TCaplusMsSyncRecord cut version must large than TCaplusMsSyncRecordBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Mode)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.Mode unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyBuffLen)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.KeyBuffLen unpack error\n" + err.Error())
	}

	if this.KeyBuffLen < 0 {
		return errors.New("TCaplusMsSyncRecord.KeyBuff's refer KeyBuffLen should >= 0")
	}
	if this.KeyBuffLen > 8192 {
		return errors.New("TCaplusMsSyncRecord.KeyBuff's refer KeyBuffLen should <= count 8192")
	}

	if this.KeyBuff == nil {
		this.KeyBuff = make([]byte, int(this.KeyBuffLen))
	}

	referKeyBuff := this.KeyBuff[:this.KeyBuffLen]
	err = binary.Read(r, binary.BigEndian, referKeyBuff)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.KeyBuff pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ValueBuffLen)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.ValueBuffLen unpack error\n" + err.Error())
	}

	if this.ValueBuffLen < 0 {
		return errors.New("TCaplusMsSyncRecord.ValueBuff's refer ValueBuffLen should >= 0")
	}
	if this.ValueBuffLen > 10300000 {
		return errors.New("TCaplusMsSyncRecord.ValueBuff's refer ValueBuffLen should <= count 10300000")
	}

	if this.ValueBuff == nil {
		this.ValueBuff = make([]byte, int(this.ValueBuffLen))
	}

	referValueBuff := this.ValueBuff[:this.ValueBuffLen]
	err = binary.Read(r, binary.BigEndian, referValueBuff)
	if err != nil {
		return errors.New("TCaplusMsSyncRecord.ValueBuff pack error\n" + err.Error())
	}

	if cutVer >= TCaplusMsSyncRecordListElementIndexVersion {

		err = binary.Read(r, binary.BigEndian, &this.ListElementIndex)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListElementIndex unpack error\n" + err.Error())
		}

	} else {
		this.ListElementIndex = 0

	}
	if cutVer >= TCaplusMsSyncRecordListIndexArrayBuffLenVersion {

		err = binary.Read(r, binary.BigEndian, &this.ListIndexArrayBuffLen)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuffLen unpack error\n" + err.Error())
		}

	} else {
		this.ListIndexArrayBuffLen = 0

	}
	if cutVer >= TCaplusMsSyncRecordListIndexArrayBuffVersion {

		if this.ListIndexArrayBuffLen < 0 {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff's refer ListIndexArrayBuffLen should >= 0")
		}
		if this.ListIndexArrayBuffLen > 1000000 {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff's refer ListIndexArrayBuffLen should <= count 1000000")
		}

		if this.ListIndexArrayBuff == nil {
			this.ListIndexArrayBuff = make([]byte, int(this.ListIndexArrayBuffLen))
		}

		referListIndexArrayBuff := this.ListIndexArrayBuff[:this.ListIndexArrayBuffLen]
		err = binary.Read(r, binary.BigEndian, referListIndexArrayBuff)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListIndexArrayBuff pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMsSyncRecordListBatchIndexArrayNumVersion {

		err = binary.Read(r, binary.BigEndian, &this.ListBatchIndexArrayNum)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArrayNum unpack error\n" + err.Error())
		}

	} else {
		this.ListBatchIndexArrayNum = 0

	}
	if cutVer >= TCaplusMsSyncRecordListBatchIndexArrayVersion {

		if this.ListBatchIndexArrayNum < 0 {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray's refer ListBatchIndexArrayNum should >= 0")
		}
		if this.ListBatchIndexArrayNum > 10240 {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray's refer ListBatchIndexArrayNum should <= count 10240")
		}

		if this.ListBatchIndexArray == nil {
			this.ListBatchIndexArray = make([]int32, int(this.ListBatchIndexArrayNum))
		}

		referListBatchIndexArray := this.ListBatchIndexArray[:this.ListBatchIndexArrayNum]
		err = binary.Read(r, binary.BigEndian, referListBatchIndexArray)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.ListBatchIndexArray pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusMsSyncRecordLastAccessTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusMsSyncRecord.LastAccessTime unpack error\n" + err.Error())
		}

	} else {
		this.LastAccessTime = 0

	}
	return err
}

const (
	TCaplusMsSyncInsertReqBaseVersion    uint32 = 3
	TCaplusMsSyncInsertReqCurrentVersion uint32 = 89
)

// TCaplusMsSyncInsertReq
type TCaplusMsSyncInsertReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusMsSyncInsertReq() *TCaplusMsSyncInsertReq {
	obj := new(TCaplusMsSyncInsertReq)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncInsertReq) GetBaseVersion() uint32 {
	return TCaplusMsSyncInsertReqBaseVersion
}

func (this *TCaplusMsSyncInsertReq) GetCurrentVersion() uint32 {
	return TCaplusMsSyncInsertReqCurrentVersion
}

func (this *TCaplusMsSyncInsertReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusMsSyncInsertReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncInsertReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncInsertReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncInsertReqCurrentVersion {
		cutVer = TCaplusMsSyncInsertReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncInsertReqBaseVersion {
		return errors.New("TCaplusMsSyncInsertReq cut version must large than TCaplusMsSyncInsertReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMsSyncInsertReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncInsertReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncInsertReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncInsertReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncInsertReqCurrentVersion {
		cutVer = TCaplusMsSyncInsertReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncInsertReqBaseVersion {
		errors.New("TCaplusMsSyncInsertReq cut version must large than TCaplusMsSyncInsertReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMsSyncInsertReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncInsertResBaseVersion    uint32 = 3
	TCaplusMsSyncInsertResCurrentVersion uint32 = 3
)

// TCaplusMsSyncInsertRes
type TCaplusMsSyncInsertRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMsSyncInsertRes() *TCaplusMsSyncInsertRes {
	obj := new(TCaplusMsSyncInsertRes)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncInsertRes) GetBaseVersion() uint32 {
	return TCaplusMsSyncInsertResBaseVersion
}

func (this *TCaplusMsSyncInsertRes) GetCurrentVersion() uint32 {
	return TCaplusMsSyncInsertResCurrentVersion
}

func (this *TCaplusMsSyncInsertRes) Init() {

}

func (this *TCaplusMsSyncInsertRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncInsertRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncInsertRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncInsertResCurrentVersion {
		cutVer = TCaplusMsSyncInsertResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncInsertResBaseVersion {
		return errors.New("TCaplusMsSyncInsertRes cut version must large than TCaplusMsSyncInsertResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncInsertRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncInsertRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncInsertRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncInsertRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncInsertResCurrentVersion {
		cutVer = TCaplusMsSyncInsertResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncInsertResBaseVersion {
		errors.New("TCaplusMsSyncInsertRes cut version must large than TCaplusMsSyncInsertResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncInsertRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncReplaceReqBaseVersion    uint32 = 3
	TCaplusMsSyncReplaceReqCurrentVersion uint32 = 89
)

// TCaplusMsSyncReplaceReq
type TCaplusMsSyncReplaceReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusMsSyncReplaceReq() *TCaplusMsSyncReplaceReq {
	obj := new(TCaplusMsSyncReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncReplaceReq) GetBaseVersion() uint32 {
	return TCaplusMsSyncReplaceReqBaseVersion
}

func (this *TCaplusMsSyncReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusMsSyncReplaceReqCurrentVersion
}

func (this *TCaplusMsSyncReplaceReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusMsSyncReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncReplaceReqCurrentVersion {
		cutVer = TCaplusMsSyncReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncReplaceReqBaseVersion {
		return errors.New("TCaplusMsSyncReplaceReq cut version must large than TCaplusMsSyncReplaceReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMsSyncReplaceReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncReplaceReqCurrentVersion {
		cutVer = TCaplusMsSyncReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncReplaceReqBaseVersion {
		errors.New("TCaplusMsSyncReplaceReq cut version must large than TCaplusMsSyncReplaceReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMsSyncReplaceReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncReplaceResBaseVersion    uint32 = 3
	TCaplusMsSyncReplaceResCurrentVersion uint32 = 3
)

// TCaplusMsSyncReplaceRes
type TCaplusMsSyncReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMsSyncReplaceRes() *TCaplusMsSyncReplaceRes {
	obj := new(TCaplusMsSyncReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncReplaceRes) GetBaseVersion() uint32 {
	return TCaplusMsSyncReplaceResBaseVersion
}

func (this *TCaplusMsSyncReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusMsSyncReplaceResCurrentVersion
}

func (this *TCaplusMsSyncReplaceRes) Init() {

}

func (this *TCaplusMsSyncReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncReplaceResCurrentVersion {
		cutVer = TCaplusMsSyncReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncReplaceResBaseVersion {
		return errors.New("TCaplusMsSyncReplaceRes cut version must large than TCaplusMsSyncReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncReplaceResCurrentVersion {
		cutVer = TCaplusMsSyncReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncReplaceResBaseVersion {
		errors.New("TCaplusMsSyncReplaceRes cut version must large than TCaplusMsSyncReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncUpdateReqBaseVersion    uint32 = 3
	TCaplusMsSyncUpdateReqCurrentVersion uint32 = 89
)

// TCaplusMsSyncUpdateReq
type TCaplusMsSyncUpdateReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusMsSyncUpdateReq() *TCaplusMsSyncUpdateReq {
	obj := new(TCaplusMsSyncUpdateReq)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncUpdateReq) GetBaseVersion() uint32 {
	return TCaplusMsSyncUpdateReqBaseVersion
}

func (this *TCaplusMsSyncUpdateReq) GetCurrentVersion() uint32 {
	return TCaplusMsSyncUpdateReqCurrentVersion
}

func (this *TCaplusMsSyncUpdateReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusMsSyncUpdateReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncUpdateReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncUpdateReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncUpdateReqCurrentVersion {
		cutVer = TCaplusMsSyncUpdateReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncUpdateReqBaseVersion {
		return errors.New("TCaplusMsSyncUpdateReq cut version must large than TCaplusMsSyncUpdateReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMsSyncUpdateReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncUpdateReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncUpdateReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncUpdateReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncUpdateReqCurrentVersion {
		cutVer = TCaplusMsSyncUpdateReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncUpdateReqBaseVersion {
		errors.New("TCaplusMsSyncUpdateReq cut version must large than TCaplusMsSyncUpdateReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMsSyncUpdateReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncUpdateResBaseVersion    uint32 = 3
	TCaplusMsSyncUpdateResCurrentVersion uint32 = 3
)

// TCaplusMsSyncUpdateRes
type TCaplusMsSyncUpdateRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMsSyncUpdateRes() *TCaplusMsSyncUpdateRes {
	obj := new(TCaplusMsSyncUpdateRes)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncUpdateRes) GetBaseVersion() uint32 {
	return TCaplusMsSyncUpdateResBaseVersion
}

func (this *TCaplusMsSyncUpdateRes) GetCurrentVersion() uint32 {
	return TCaplusMsSyncUpdateResCurrentVersion
}

func (this *TCaplusMsSyncUpdateRes) Init() {

}

func (this *TCaplusMsSyncUpdateRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncUpdateRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncUpdateRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncUpdateResCurrentVersion {
		cutVer = TCaplusMsSyncUpdateResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncUpdateResBaseVersion {
		return errors.New("TCaplusMsSyncUpdateRes cut version must large than TCaplusMsSyncUpdateResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncUpdateRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncUpdateRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncUpdateRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncUpdateRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncUpdateResCurrentVersion {
		cutVer = TCaplusMsSyncUpdateResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncUpdateResBaseVersion {
		errors.New("TCaplusMsSyncUpdateRes cut version must large than TCaplusMsSyncUpdateResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncUpdateRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncDeleteReqBaseVersion           uint32 = 3
	TCaplusMsSyncDeleteReqCurrentVersion        uint32 = 58
	TCaplusMsSyncDeleteReqLastAccessTimeVersion uint32 = 58
)

// TCaplusMsSyncDeleteReq
type TCaplusMsSyncDeleteReq struct {
	KeyBuffLen uint32 `tdr_field:"KeyBuffLen"`

	KeyBuff []byte `tdr_field:"KeyBuff" tdr_count:"8192" tdr_refer:"KeyBuffLen"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusMsSyncDeleteReq() *TCaplusMsSyncDeleteReq {
	obj := new(TCaplusMsSyncDeleteReq)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncDeleteReq) GetBaseVersion() uint32 {
	return TCaplusMsSyncDeleteReqBaseVersion
}

func (this *TCaplusMsSyncDeleteReq) GetCurrentVersion() uint32 {
	return TCaplusMsSyncDeleteReqCurrentVersion
}

func (this *TCaplusMsSyncDeleteReq) Init() {
	this.KeyBuffLen = 0

	this.LastAccessTime = 0

}

func (this *TCaplusMsSyncDeleteReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncDeleteReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncDeleteReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncDeleteReqCurrentVersion {
		cutVer = TCaplusMsSyncDeleteReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncDeleteReqBaseVersion {
		return errors.New("TCaplusMsSyncDeleteReq cut version must large than TCaplusMsSyncDeleteReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.KeyBuffLen)
	if err != nil {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuffLen pack error\n" + err.Error())
	}

	if this.KeyBuffLen < 0 {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuff's refer KeyBuffLen should >= 0")
	}
	if this.KeyBuffLen > 8192 {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuff's refer KeyBuffLen should <= count 8192")
	}
	if len(this.KeyBuff) < int(this.KeyBuffLen) {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuff's length should > KeyBuffLen")
	}
	if this.KeyBuffLen > 0 {
		referKeyBuff := this.KeyBuff[:this.KeyBuffLen]
		err = binary.Write(w, binary.BigEndian, referKeyBuff)
		if err != nil {
			return errors.New("TCaplusMsSyncDeleteReq.KeyBuff pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusMsSyncDeleteReqLastAccessTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusMsSyncDeleteReq.LastAccessTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusMsSyncDeleteReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncDeleteReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncDeleteReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncDeleteReqCurrentVersion {
		cutVer = TCaplusMsSyncDeleteReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncDeleteReqBaseVersion {
		errors.New("TCaplusMsSyncDeleteReq cut version must large than TCaplusMsSyncDeleteReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyBuffLen)
	if err != nil {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuffLen unpack error\n" + err.Error())
	}

	if this.KeyBuffLen < 0 {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuff's refer KeyBuffLen should >= 0")
	}
	if this.KeyBuffLen > 8192 {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuff's refer KeyBuffLen should <= count 8192")
	}

	if this.KeyBuff == nil {
		this.KeyBuff = make([]byte, int(this.KeyBuffLen))
	}

	referKeyBuff := this.KeyBuff[:this.KeyBuffLen]
	err = binary.Read(r, binary.BigEndian, referKeyBuff)
	if err != nil {
		return errors.New("TCaplusMsSyncDeleteReq.KeyBuff pack error\n" + err.Error())
	}

	if cutVer >= TCaplusMsSyncDeleteReqLastAccessTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusMsSyncDeleteReq.LastAccessTime unpack error\n" + err.Error())
		}

	} else {
		this.LastAccessTime = 0

	}
	return err
}

const (
	TCaplusMsSyncDeleteResBaseVersion    uint32 = 3
	TCaplusMsSyncDeleteResCurrentVersion uint32 = 3
)

// TCaplusMsSyncDeleteRes
type TCaplusMsSyncDeleteRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMsSyncDeleteRes() *TCaplusMsSyncDeleteRes {
	obj := new(TCaplusMsSyncDeleteRes)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncDeleteRes) GetBaseVersion() uint32 {
	return TCaplusMsSyncDeleteResBaseVersion
}

func (this *TCaplusMsSyncDeleteRes) GetCurrentVersion() uint32 {
	return TCaplusMsSyncDeleteResCurrentVersion
}

func (this *TCaplusMsSyncDeleteRes) Init() {

}

func (this *TCaplusMsSyncDeleteRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncDeleteRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncDeleteRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncDeleteResCurrentVersion {
		cutVer = TCaplusMsSyncDeleteResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncDeleteResBaseVersion {
		return errors.New("TCaplusMsSyncDeleteRes cut version must large than TCaplusMsSyncDeleteResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncDeleteRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncDeleteRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncDeleteRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncDeleteRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncDeleteResCurrentVersion {
		cutVer = TCaplusMsSyncDeleteResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncDeleteResBaseVersion {
		errors.New("TCaplusMsSyncDeleteRes cut version must large than TCaplusMsSyncDeleteResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncDeleteRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncDeleteAllReqBaseVersion           uint32 = 3
	TCaplusListMsSyncDeleteAllReqCurrentVersion        uint32 = 58
	TCaplusListMsSyncDeleteAllReqLastAccessTimeVersion uint32 = 58
)

// TCaplusListMsSyncDeleteAllReq
type TCaplusListMsSyncDeleteAllReq struct {
	KeyBuffLen uint32 `tdr_field:"KeyBuffLen"`

	KeyBuff []byte `tdr_field:"KeyBuff" tdr_count:"8192" tdr_refer:"KeyBuffLen"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusListMsSyncDeleteAllReq() *TCaplusListMsSyncDeleteAllReq {
	obj := new(TCaplusListMsSyncDeleteAllReq)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncDeleteAllReq) GetBaseVersion() uint32 {
	return TCaplusListMsSyncDeleteAllReqBaseVersion
}

func (this *TCaplusListMsSyncDeleteAllReq) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncDeleteAllReqCurrentVersion
}

func (this *TCaplusListMsSyncDeleteAllReq) Init() {
	this.KeyBuffLen = 0

	this.LastAccessTime = 0

}

func (this *TCaplusListMsSyncDeleteAllReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncDeleteAllReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncDeleteAllReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteAllReqCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteAllReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncDeleteAllReqBaseVersion {
		return errors.New("TCaplusListMsSyncDeleteAllReq cut version must large than TCaplusListMsSyncDeleteAllReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.KeyBuffLen)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuffLen pack error\n" + err.Error())
	}

	if this.KeyBuffLen < 0 {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff's refer KeyBuffLen should >= 0")
	}
	if this.KeyBuffLen > 8192 {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff's refer KeyBuffLen should <= count 8192")
	}
	if len(this.KeyBuff) < int(this.KeyBuffLen) {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff's length should > KeyBuffLen")
	}
	if this.KeyBuffLen > 0 {
		referKeyBuff := this.KeyBuff[:this.KeyBuffLen]
		err = binary.Write(w, binary.BigEndian, referKeyBuff)
		if err != nil {
			return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusListMsSyncDeleteAllReqLastAccessTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusListMsSyncDeleteAllReq.LastAccessTime pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListMsSyncDeleteAllReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncDeleteAllReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncDeleteAllReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteAllReqCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteAllReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncDeleteAllReqBaseVersion {
		errors.New("TCaplusListMsSyncDeleteAllReq cut version must large than TCaplusListMsSyncDeleteAllReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyBuffLen)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuffLen unpack error\n" + err.Error())
	}

	if this.KeyBuffLen < 0 {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff's refer KeyBuffLen should >= 0")
	}
	if this.KeyBuffLen > 8192 {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff's refer KeyBuffLen should <= count 8192")
	}

	if this.KeyBuff == nil {
		this.KeyBuff = make([]byte, int(this.KeyBuffLen))
	}

	referKeyBuff := this.KeyBuff[:this.KeyBuffLen]
	err = binary.Read(r, binary.BigEndian, referKeyBuff)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteAllReq.KeyBuff pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListMsSyncDeleteAllReqLastAccessTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
		if err != nil {
			return errors.New("TCaplusListMsSyncDeleteAllReq.LastAccessTime unpack error\n" + err.Error())
		}

	} else {
		this.LastAccessTime = 0

	}
	return err
}

const (
	TCaplusListMsSyncDeleteAllResBaseVersion    uint32 = 3
	TCaplusListMsSyncDeleteAllResCurrentVersion uint32 = 3
)

// TCaplusListMsSyncDeleteAllRes
type TCaplusListMsSyncDeleteAllRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListMsSyncDeleteAllRes() *TCaplusListMsSyncDeleteAllRes {
	obj := new(TCaplusListMsSyncDeleteAllRes)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncDeleteAllRes) GetBaseVersion() uint32 {
	return TCaplusListMsSyncDeleteAllResBaseVersion
}

func (this *TCaplusListMsSyncDeleteAllRes) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncDeleteAllResCurrentVersion
}

func (this *TCaplusListMsSyncDeleteAllRes) Init() {

}

func (this *TCaplusListMsSyncDeleteAllRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncDeleteAllRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncDeleteAllRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteAllResCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteAllResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncDeleteAllResBaseVersion {
		return errors.New("TCaplusListMsSyncDeleteAllRes cut version must large than TCaplusListMsSyncDeleteAllResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteAllRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncDeleteAllRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncDeleteAllRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncDeleteAllRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteAllResCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteAllResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncDeleteAllResBaseVersion {
		errors.New("TCaplusListMsSyncDeleteAllRes cut version must large than TCaplusListMsSyncDeleteAllResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteAllRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncAddAfterReqBaseVersion    uint32 = 3
	TCaplusListMsSyncAddAfterReqCurrentVersion uint32 = 89
)

// TCaplusListMsSyncAddAfterReq
type TCaplusListMsSyncAddAfterReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusListMsSyncAddAfterReq() *TCaplusListMsSyncAddAfterReq {
	obj := new(TCaplusListMsSyncAddAfterReq)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncAddAfterReq) GetBaseVersion() uint32 {
	return TCaplusListMsSyncAddAfterReqBaseVersion
}

func (this *TCaplusListMsSyncAddAfterReq) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncAddAfterReqCurrentVersion
}

func (this *TCaplusListMsSyncAddAfterReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusListMsSyncAddAfterReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncAddAfterReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncAddAfterReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncAddAfterReqCurrentVersion {
		cutVer = TCaplusListMsSyncAddAfterReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncAddAfterReqBaseVersion {
		return errors.New("TCaplusListMsSyncAddAfterReq cut version must large than TCaplusListMsSyncAddAfterReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListMsSyncAddAfterReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncAddAfterReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncAddAfterReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncAddAfterReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncAddAfterReqCurrentVersion {
		cutVer = TCaplusListMsSyncAddAfterReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncAddAfterReqBaseVersion {
		errors.New("TCaplusListMsSyncAddAfterReq cut version must large than TCaplusListMsSyncAddAfterReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListMsSyncAddAfterReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncAddAfterResBaseVersion    uint32 = 3
	TCaplusListMsSyncAddAfterResCurrentVersion uint32 = 3
)

// TCaplusListMsSyncAddAfterRes
type TCaplusListMsSyncAddAfterRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListMsSyncAddAfterRes() *TCaplusListMsSyncAddAfterRes {
	obj := new(TCaplusListMsSyncAddAfterRes)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncAddAfterRes) GetBaseVersion() uint32 {
	return TCaplusListMsSyncAddAfterResBaseVersion
}

func (this *TCaplusListMsSyncAddAfterRes) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncAddAfterResCurrentVersion
}

func (this *TCaplusListMsSyncAddAfterRes) Init() {

}

func (this *TCaplusListMsSyncAddAfterRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncAddAfterRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncAddAfterRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncAddAfterResCurrentVersion {
		cutVer = TCaplusListMsSyncAddAfterResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncAddAfterResBaseVersion {
		return errors.New("TCaplusListMsSyncAddAfterRes cut version must large than TCaplusListMsSyncAddAfterResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncAddAfterRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncAddAfterRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncAddAfterRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncAddAfterRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncAddAfterResCurrentVersion {
		cutVer = TCaplusListMsSyncAddAfterResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncAddAfterResBaseVersion {
		errors.New("TCaplusListMsSyncAddAfterRes cut version must large than TCaplusListMsSyncAddAfterResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncAddAfterRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncDeleteReqBaseVersion    uint32 = 3
	TCaplusListMsSyncDeleteReqCurrentVersion uint32 = 89
)

// TCaplusListMsSyncDeleteReq
type TCaplusListMsSyncDeleteReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusListMsSyncDeleteReq() *TCaplusListMsSyncDeleteReq {
	obj := new(TCaplusListMsSyncDeleteReq)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncDeleteReq) GetBaseVersion() uint32 {
	return TCaplusListMsSyncDeleteReqBaseVersion
}

func (this *TCaplusListMsSyncDeleteReq) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncDeleteReqCurrentVersion
}

func (this *TCaplusListMsSyncDeleteReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusListMsSyncDeleteReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncDeleteReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncDeleteReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteReqCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncDeleteReqBaseVersion {
		return errors.New("TCaplusListMsSyncDeleteReq cut version must large than TCaplusListMsSyncDeleteReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncDeleteReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncDeleteReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncDeleteReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteReqCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncDeleteReqBaseVersion {
		errors.New("TCaplusListMsSyncDeleteReq cut version must large than TCaplusListMsSyncDeleteReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncDeleteResBaseVersion    uint32 = 3
	TCaplusListMsSyncDeleteResCurrentVersion uint32 = 3
)

// TCaplusListMsSyncDeleteRes
type TCaplusListMsSyncDeleteRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListMsSyncDeleteRes() *TCaplusListMsSyncDeleteRes {
	obj := new(TCaplusListMsSyncDeleteRes)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncDeleteRes) GetBaseVersion() uint32 {
	return TCaplusListMsSyncDeleteResBaseVersion
}

func (this *TCaplusListMsSyncDeleteRes) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncDeleteResCurrentVersion
}

func (this *TCaplusListMsSyncDeleteRes) Init() {

}

func (this *TCaplusListMsSyncDeleteRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncDeleteRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncDeleteRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteResCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncDeleteResBaseVersion {
		return errors.New("TCaplusListMsSyncDeleteRes cut version must large than TCaplusListMsSyncDeleteResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncDeleteRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncDeleteRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncDeleteRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncDeleteResCurrentVersion {
		cutVer = TCaplusListMsSyncDeleteResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncDeleteResBaseVersion {
		errors.New("TCaplusListMsSyncDeleteRes cut version must large than TCaplusListMsSyncDeleteResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncDeleteRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncReplaceReqBaseVersion    uint32 = 3
	TCaplusListMsSyncReplaceReqCurrentVersion uint32 = 89
)

// TCaplusListMsSyncReplaceReq
type TCaplusListMsSyncReplaceReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusListMsSyncReplaceReq() *TCaplusListMsSyncReplaceReq {
	obj := new(TCaplusListMsSyncReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncReplaceReq) GetBaseVersion() uint32 {
	return TCaplusListMsSyncReplaceReqBaseVersion
}

func (this *TCaplusListMsSyncReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncReplaceReqCurrentVersion
}

func (this *TCaplusListMsSyncReplaceReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusListMsSyncReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncReplaceReqCurrentVersion {
		cutVer = TCaplusListMsSyncReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncReplaceReqBaseVersion {
		return errors.New("TCaplusListMsSyncReplaceReq cut version must large than TCaplusListMsSyncReplaceReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListMsSyncReplaceReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncReplaceReqCurrentVersion {
		cutVer = TCaplusListMsSyncReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncReplaceReqBaseVersion {
		errors.New("TCaplusListMsSyncReplaceReq cut version must large than TCaplusListMsSyncReplaceReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListMsSyncReplaceReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncReplaceResBaseVersion    uint32 = 3
	TCaplusListMsSyncReplaceResCurrentVersion uint32 = 3
)

// TCaplusListMsSyncReplaceRes
type TCaplusListMsSyncReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListMsSyncReplaceRes() *TCaplusListMsSyncReplaceRes {
	obj := new(TCaplusListMsSyncReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncReplaceRes) GetBaseVersion() uint32 {
	return TCaplusListMsSyncReplaceResBaseVersion
}

func (this *TCaplusListMsSyncReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncReplaceResCurrentVersion
}

func (this *TCaplusListMsSyncReplaceRes) Init() {

}

func (this *TCaplusListMsSyncReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncReplaceResCurrentVersion {
		cutVer = TCaplusListMsSyncReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncReplaceResBaseVersion {
		return errors.New("TCaplusListMsSyncReplaceRes cut version must large than TCaplusListMsSyncReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncReplaceResCurrentVersion {
		cutVer = TCaplusListMsSyncReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncReplaceResBaseVersion {
		errors.New("TCaplusListMsSyncReplaceRes cut version must large than TCaplusListMsSyncReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusAppSignupReqBaseVersion    uint32 = 7
	TCaplusAppSignupReqCurrentVersion uint32 = 7
)

// TCaplusAppSignupReq
type TCaplusAppSignupReq struct {
	Signature string `tdr_field:"Signature"`

	Type int16 `tdr_field:"Type"`
}

func NewTCaplusAppSignupReq() *TCaplusAppSignupReq {
	obj := new(TCaplusAppSignupReq)
	obj.Init()
	return obj
}

func (this *TCaplusAppSignupReq) GetBaseVersion() uint32 {
	return TCaplusAppSignupReqBaseVersion
}

func (this *TCaplusAppSignupReq) GetCurrentVersion() uint32 {
	return TCaplusAppSignupReqCurrentVersion
}

func (this *TCaplusAppSignupReq) Init() {

}

func (this *TCaplusAppSignupReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusAppSignupReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusAppSignupReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusAppSignupReqCurrentVersion {
		cutVer = TCaplusAppSignupReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusAppSignupReqBaseVersion {
		return errors.New("TCaplusAppSignupReq cut version must large than TCaplusAppSignupReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Signature))+1)
	if err != nil {
		return errors.New("TCaplusAppSignupReq.Signature string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Signature), 0))
	if err != nil {
		return errors.New("TCaplusAppSignupReq.Signature string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Type)
	if err != nil {
		return errors.New("TCaplusAppSignupReq.Type pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusAppSignupReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusAppSignupReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusAppSignupReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusAppSignupReqCurrentVersion {
		cutVer = TCaplusAppSignupReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusAppSignupReqBaseVersion {
		errors.New("TCaplusAppSignupReq cut version must large than TCaplusAppSignupReqBaseVersion\n")
	}

	var SignatureSize uint32
	err = binary.Read(r, binary.BigEndian, &SignatureSize)
	if err != nil {
		return errors.New("TCaplusAppSignupReq.Signature string size unpack error\n" + err.Error())
	}

	SignatureBytes := make([]byte, SignatureSize)
	err = binary.Read(r, binary.BigEndian, SignatureBytes)
	if err != nil {
		return errors.New("TCaplusAppSignupReq.Signature string content unpack error\n" + err.Error())
	}
	this.Signature = string(SignatureBytes[:len(SignatureBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Type)
	if err != nil {
		return errors.New("TCaplusAppSignupReq.Type unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusAppSignupResBaseVersion    uint32 = 7
	TCaplusAppSignupResCurrentVersion uint32 = 7
)

// TCaplusAppSignupRes
type TCaplusAppSignupRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusAppSignupRes() *TCaplusAppSignupRes {
	obj := new(TCaplusAppSignupRes)
	obj.Init()
	return obj
}

func (this *TCaplusAppSignupRes) GetBaseVersion() uint32 {
	return TCaplusAppSignupResBaseVersion
}

func (this *TCaplusAppSignupRes) GetCurrentVersion() uint32 {
	return TCaplusAppSignupResCurrentVersion
}

func (this *TCaplusAppSignupRes) Init() {

}

func (this *TCaplusAppSignupRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusAppSignupRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusAppSignupRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusAppSignupResCurrentVersion {
		cutVer = TCaplusAppSignupResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusAppSignupResBaseVersion {
		return errors.New("TCaplusAppSignupRes cut version must large than TCaplusAppSignupResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusAppSignupRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusAppSignupRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusAppSignupRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusAppSignupRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusAppSignupResCurrentVersion {
		cutVer = TCaplusAppSignupResCurrentVersion
	}
	// check version
	if cutVer < TCaplusAppSignupResBaseVersion {
		errors.New("TCaplusAppSignupRes cut version must large than TCaplusAppSignupResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusAppSignupRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusHeartBeatReqBaseVersion      uint32 = 7
	TCaplusHeartBeatReqCurrentVersion   uint32 = 90
	TCaplusHeartBeatReqApiTimeUsVersion uint32 = 90
)

// TCaplusHeartBeatReq
type TCaplusHeartBeatReq struct {
	CurTime uint64 `tdr_field:"CurTime"`

	ApiTimeUs int64 `tdr_field:"ApiTimeUs"`
}

func NewTCaplusHeartBeatReq() *TCaplusHeartBeatReq {
	obj := new(TCaplusHeartBeatReq)
	obj.Init()
	return obj
}

func (this *TCaplusHeartBeatReq) GetBaseVersion() uint32 {
	return TCaplusHeartBeatReqBaseVersion
}

func (this *TCaplusHeartBeatReq) GetCurrentVersion() uint32 {
	return TCaplusHeartBeatReqCurrentVersion
}

func (this *TCaplusHeartBeatReq) Init() {

}

func (this *TCaplusHeartBeatReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusHeartBeatReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusHeartBeatReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusHeartBeatReqCurrentVersion {
		cutVer = TCaplusHeartBeatReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusHeartBeatReqBaseVersion {
		return errors.New("TCaplusHeartBeatReq cut version must large than TCaplusHeartBeatReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.CurTime)
	if err != nil {
		return errors.New("TCaplusHeartBeatReq.CurTime pack error\n" + err.Error())
	}

	if cutVer >= TCaplusHeartBeatReqApiTimeUsVersion {

		err = binary.Write(w, binary.BigEndian, this.ApiTimeUs)
		if err != nil {
			return errors.New("TCaplusHeartBeatReq.ApiTimeUs pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusHeartBeatReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusHeartBeatReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusHeartBeatReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusHeartBeatReqCurrentVersion {
		cutVer = TCaplusHeartBeatReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusHeartBeatReqBaseVersion {
		errors.New("TCaplusHeartBeatReq cut version must large than TCaplusHeartBeatReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.CurTime)
	if err != nil {
		return errors.New("TCaplusHeartBeatReq.CurTime unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusHeartBeatReqApiTimeUsVersion {

		err = binary.Read(r, binary.BigEndian, &this.ApiTimeUs)
		if err != nil {
			return errors.New("TCaplusHeartBeatReq.ApiTimeUs unpack error\n" + err.Error())
		}

	}
	return err
}

const (
	TCaplusHeartBeatResBaseVersion        uint32 = 7
	TCaplusHeartBeatResCurrentVersion     uint32 = 90
	TCaplusHeartBeatResApiTimeUsVersion   uint32 = 90
	TCaplusHeartBeatResProxyTimeUsVersion uint32 = 90
)

// TCaplusHeartBeatRes
type TCaplusHeartBeatRes struct {
	CurTime uint64 `tdr_field:"CurTime"`

	ApiTimeUs int64 `tdr_field:"ApiTimeUs"`

	ProxyTimeUs int64 `tdr_field:"ProxyTimeUs"`
}

func NewTCaplusHeartBeatRes() *TCaplusHeartBeatRes {
	obj := new(TCaplusHeartBeatRes)
	obj.Init()
	return obj
}

func (this *TCaplusHeartBeatRes) GetBaseVersion() uint32 {
	return TCaplusHeartBeatResBaseVersion
}

func (this *TCaplusHeartBeatRes) GetCurrentVersion() uint32 {
	return TCaplusHeartBeatResCurrentVersion
}

func (this *TCaplusHeartBeatRes) Init() {

}

func (this *TCaplusHeartBeatRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusHeartBeatRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusHeartBeatRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusHeartBeatResCurrentVersion {
		cutVer = TCaplusHeartBeatResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusHeartBeatResBaseVersion {
		return errors.New("TCaplusHeartBeatRes cut version must large than TCaplusHeartBeatResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.CurTime)
	if err != nil {
		return errors.New("TCaplusHeartBeatRes.CurTime pack error\n" + err.Error())
	}

	if cutVer >= TCaplusHeartBeatResApiTimeUsVersion {

		err = binary.Write(w, binary.BigEndian, this.ApiTimeUs)
		if err != nil {
			return errors.New("TCaplusHeartBeatRes.ApiTimeUs pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusHeartBeatResProxyTimeUsVersion {

		err = binary.Write(w, binary.BigEndian, this.ProxyTimeUs)
		if err != nil {
			return errors.New("TCaplusHeartBeatRes.ProxyTimeUs pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusHeartBeatRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusHeartBeatRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusHeartBeatRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusHeartBeatResCurrentVersion {
		cutVer = TCaplusHeartBeatResCurrentVersion
	}
	// check version
	if cutVer < TCaplusHeartBeatResBaseVersion {
		errors.New("TCaplusHeartBeatRes cut version must large than TCaplusHeartBeatResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.CurTime)
	if err != nil {
		return errors.New("TCaplusHeartBeatRes.CurTime unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusHeartBeatResApiTimeUsVersion {

		err = binary.Read(r, binary.BigEndian, &this.ApiTimeUs)
		if err != nil {
			return errors.New("TCaplusHeartBeatRes.ApiTimeUs unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusHeartBeatResProxyTimeUsVersion {

		err = binary.Read(r, binary.BigEndian, &this.ProxyTimeUs)
		if err != nil {
			return errors.New("TCaplusHeartBeatRes.ProxyTimeUs unpack error\n" + err.Error())
		}

	}
	return err
}

const (
	MoveRangeBaseVersion    uint32 = 8
	MoveRangeCurrentVersion uint32 = 8
)

// MoveRange
type MoveRange struct {
	StartIndex uint32 `tdr_field:"StartIndex"`

	EndIndex uint32 `tdr_field:"EndIndex"`
}

func NewMoveRange() *MoveRange {
	obj := new(MoveRange)
	obj.Init()
	return obj
}

func (this *MoveRange) GetBaseVersion() uint32 {
	return MoveRangeBaseVersion
}

func (this *MoveRange) GetCurrentVersion() uint32 {
	return MoveRangeCurrentVersion
}

func (this *MoveRange) Init() {

}

func (this *MoveRange) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("MoveRange Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *MoveRange) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > MoveRangeCurrentVersion {
		cutVer = MoveRangeCurrentVersion
	}
	// check cut version
	if cutVer < MoveRangeBaseVersion {
		return errors.New("MoveRange cut version must large than MoveRangeBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.StartIndex)
	if err != nil {
		return errors.New("MoveRange.StartIndex pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.EndIndex)
	if err != nil {
		return errors.New("MoveRange.EndIndex pack error\n" + err.Error())
	}

	return nil
}

func (this *MoveRange) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("MoveRange data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *MoveRange) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > MoveRangeCurrentVersion {
		cutVer = MoveRangeCurrentVersion
	}
	// check version
	if cutVer < MoveRangeBaseVersion {
		errors.New("MoveRange cut version must large than MoveRangeBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.StartIndex)
	if err != nil {
		return errors.New("MoveRange.StartIndex unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.EndIndex)
	if err != nil {
		return errors.New("MoveRange.EndIndex unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusPrepareMoveReqBaseVersion    uint32 = 8
	TCaplusPrepareMoveReqCurrentVersion uint32 = 8
)

// TCaplusPrepareMoveReq
type TCaplusPrepareMoveReq struct {
	SrcServID string `tdr_field:"SrcServID"`

	SrcShardID int32 `tdr_field:"SrcShardID"`

	MoveRange *MoveRange `tdr_field:"MoveRange"`
}

func NewTCaplusPrepareMoveReq() *TCaplusPrepareMoveReq {
	obj := new(TCaplusPrepareMoveReq)
	obj.Init()
	return obj
}

func (this *TCaplusPrepareMoveReq) GetBaseVersion() uint32 {
	return TCaplusPrepareMoveReqBaseVersion
}

func (this *TCaplusPrepareMoveReq) GetCurrentVersion() uint32 {
	return TCaplusPrepareMoveReqCurrentVersion
}

func (this *TCaplusPrepareMoveReq) Init() {

	this.MoveRange = NewMoveRange()

}

func (this *TCaplusPrepareMoveReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusPrepareMoveReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusPrepareMoveReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusPrepareMoveReqCurrentVersion {
		cutVer = TCaplusPrepareMoveReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusPrepareMoveReqBaseVersion {
		return errors.New("TCaplusPrepareMoveReq cut version must large than TCaplusPrepareMoveReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.SrcServID))+1)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.SrcServID string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.SrcServID), 0))
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.SrcServID string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.SrcShardID pack error\n" + err.Error())
	}

	err = this.MoveRange.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.MoveRange pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusPrepareMoveReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusPrepareMoveReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusPrepareMoveReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusPrepareMoveReqCurrentVersion {
		cutVer = TCaplusPrepareMoveReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusPrepareMoveReqBaseVersion {
		errors.New("TCaplusPrepareMoveReq cut version must large than TCaplusPrepareMoveReqBaseVersion\n")
	}

	var SrcServIDSize uint32
	err = binary.Read(r, binary.BigEndian, &SrcServIDSize)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.SrcServID string size unpack error\n" + err.Error())
	}

	SrcServIDBytes := make([]byte, SrcServIDSize)
	err = binary.Read(r, binary.BigEndian, SrcServIDBytes)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.SrcServID string content unpack error\n" + err.Error())
	}
	this.SrcServID = string(SrcServIDBytes[:len(SrcServIDBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.SrcShardID unpack error\n" + err.Error())
	}

	err = this.MoveRange.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusPrepareMoveReq.MoveRange unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusPrepareMoveResBaseVersion    uint32 = 8
	TCaplusPrepareMoveResCurrentVersion uint32 = 8
)

// TCaplusPrepareMoveRes
type TCaplusPrepareMoveRes struct {
	SrcServID string `tdr_field:"SrcServID"`

	SrcShardID int32 `tdr_field:"SrcShardID"`

	MoveRange *MoveRange `tdr_field:"MoveRange"`

	Result int32 `tdr_field:"Result"`
}

func NewTCaplusPrepareMoveRes() *TCaplusPrepareMoveRes {
	obj := new(TCaplusPrepareMoveRes)
	obj.Init()
	return obj
}

func (this *TCaplusPrepareMoveRes) GetBaseVersion() uint32 {
	return TCaplusPrepareMoveResBaseVersion
}

func (this *TCaplusPrepareMoveRes) GetCurrentVersion() uint32 {
	return TCaplusPrepareMoveResCurrentVersion
}

func (this *TCaplusPrepareMoveRes) Init() {

	this.MoveRange = NewMoveRange()

}

func (this *TCaplusPrepareMoveRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusPrepareMoveRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusPrepareMoveRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusPrepareMoveResCurrentVersion {
		cutVer = TCaplusPrepareMoveResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusPrepareMoveResBaseVersion {
		return errors.New("TCaplusPrepareMoveRes cut version must large than TCaplusPrepareMoveResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.SrcServID))+1)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.SrcServID string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.SrcServID), 0))
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.SrcServID string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.SrcShardID pack error\n" + err.Error())
	}

	err = this.MoveRange.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.MoveRange pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusPrepareMoveRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusPrepareMoveRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusPrepareMoveRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusPrepareMoveResCurrentVersion {
		cutVer = TCaplusPrepareMoveResCurrentVersion
	}
	// check version
	if cutVer < TCaplusPrepareMoveResBaseVersion {
		errors.New("TCaplusPrepareMoveRes cut version must large than TCaplusPrepareMoveResBaseVersion\n")
	}

	var SrcServIDSize uint32
	err = binary.Read(r, binary.BigEndian, &SrcServIDSize)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.SrcServID string size unpack error\n" + err.Error())
	}

	SrcServIDBytes := make([]byte, SrcServIDSize)
	err = binary.Read(r, binary.BigEndian, SrcServIDBytes)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.SrcServID string content unpack error\n" + err.Error())
	}
	this.SrcServID = string(SrcServIDBytes[:len(SrcServIDBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.SrcShardID unpack error\n" + err.Error())
	}

	err = this.MoveRange.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.MoveRange unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusPrepareMoveRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusFinishMoveReqBaseVersion    uint32 = 8
	TCaplusFinishMoveReqCurrentVersion uint32 = 8
)

// TCaplusFinishMoveReq
type TCaplusFinishMoveReq struct {
	SrcServID string `tdr_field:"SrcServID"`

	SrcShardID int32 `tdr_field:"SrcShardID"`

	MoveRange *MoveRange `tdr_field:"MoveRange"`

	Reason int32 `tdr_field:"Reason"`
}

func NewTCaplusFinishMoveReq() *TCaplusFinishMoveReq {
	obj := new(TCaplusFinishMoveReq)
	obj.Init()
	return obj
}

func (this *TCaplusFinishMoveReq) GetBaseVersion() uint32 {
	return TCaplusFinishMoveReqBaseVersion
}

func (this *TCaplusFinishMoveReq) GetCurrentVersion() uint32 {
	return TCaplusFinishMoveReqCurrentVersion
}

func (this *TCaplusFinishMoveReq) Init() {

	this.MoveRange = NewMoveRange()

}

func (this *TCaplusFinishMoveReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusFinishMoveReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusFinishMoveReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusFinishMoveReqCurrentVersion {
		cutVer = TCaplusFinishMoveReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusFinishMoveReqBaseVersion {
		return errors.New("TCaplusFinishMoveReq cut version must large than TCaplusFinishMoveReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.SrcServID))+1)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.SrcServID string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.SrcServID), 0))
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.SrcServID string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.SrcShardID pack error\n" + err.Error())
	}

	err = this.MoveRange.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.MoveRange pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Reason)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.Reason pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusFinishMoveReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusFinishMoveReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusFinishMoveReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusFinishMoveReqCurrentVersion {
		cutVer = TCaplusFinishMoveReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusFinishMoveReqBaseVersion {
		errors.New("TCaplusFinishMoveReq cut version must large than TCaplusFinishMoveReqBaseVersion\n")
	}

	var SrcServIDSize uint32
	err = binary.Read(r, binary.BigEndian, &SrcServIDSize)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.SrcServID string size unpack error\n" + err.Error())
	}

	SrcServIDBytes := make([]byte, SrcServIDSize)
	err = binary.Read(r, binary.BigEndian, SrcServIDBytes)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.SrcServID string content unpack error\n" + err.Error())
	}
	this.SrcServID = string(SrcServIDBytes[:len(SrcServIDBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.SrcShardID unpack error\n" + err.Error())
	}

	err = this.MoveRange.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.MoveRange unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Reason)
	if err != nil {
		return errors.New("TCaplusFinishMoveReq.Reason unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusFinishMoveResBaseVersion    uint32 = 8
	TCaplusFinishMoveResCurrentVersion uint32 = 8
)

// TCaplusFinishMoveRes
type TCaplusFinishMoveRes struct {
	SrcServID string `tdr_field:"SrcServID"`

	SrcShardID int32 `tdr_field:"SrcShardID"`

	MoveRange *MoveRange `tdr_field:"MoveRange"`

	Result int32 `tdr_field:"Result"`
}

func NewTCaplusFinishMoveRes() *TCaplusFinishMoveRes {
	obj := new(TCaplusFinishMoveRes)
	obj.Init()
	return obj
}

func (this *TCaplusFinishMoveRes) GetBaseVersion() uint32 {
	return TCaplusFinishMoveResBaseVersion
}

func (this *TCaplusFinishMoveRes) GetCurrentVersion() uint32 {
	return TCaplusFinishMoveResCurrentVersion
}

func (this *TCaplusFinishMoveRes) Init() {

	this.MoveRange = NewMoveRange()

}

func (this *TCaplusFinishMoveRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusFinishMoveRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusFinishMoveRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusFinishMoveResCurrentVersion {
		cutVer = TCaplusFinishMoveResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusFinishMoveResBaseVersion {
		return errors.New("TCaplusFinishMoveRes cut version must large than TCaplusFinishMoveResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.SrcServID))+1)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.SrcServID string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.SrcServID), 0))
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.SrcServID string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.SrcShardID pack error\n" + err.Error())
	}

	err = this.MoveRange.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.MoveRange pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusFinishMoveRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusFinishMoveRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusFinishMoveRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusFinishMoveResCurrentVersion {
		cutVer = TCaplusFinishMoveResCurrentVersion
	}
	// check version
	if cutVer < TCaplusFinishMoveResBaseVersion {
		errors.New("TCaplusFinishMoveRes cut version must large than TCaplusFinishMoveResBaseVersion\n")
	}

	var SrcServIDSize uint32
	err = binary.Read(r, binary.BigEndian, &SrcServIDSize)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.SrcServID string size unpack error\n" + err.Error())
	}

	SrcServIDBytes := make([]byte, SrcServIDSize)
	err = binary.Read(r, binary.BigEndian, SrcServIDBytes)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.SrcServID string content unpack error\n" + err.Error())
	}
	this.SrcServID = string(SrcServIDBytes[:len(SrcServIDBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.SrcShardID unpack error\n" + err.Error())
	}

	err = this.MoveRange.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.MoveRange unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusFinishMoveRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	RouteKeyFieldBaseVersion    uint32 = 17
	RouteKeyFieldCurrentVersion uint32 = 17
)

// RouteKeyField
type RouteKeyField struct {
	FieldName string `tdr_field:"FieldName"`
}

func NewRouteKeyField() *RouteKeyField {
	obj := new(RouteKeyField)
	obj.Init()
	return obj
}

func (this *RouteKeyField) GetBaseVersion() uint32 {
	return RouteKeyFieldBaseVersion
}

func (this *RouteKeyField) GetCurrentVersion() uint32 {
	return RouteKeyFieldCurrentVersion
}

func (this *RouteKeyField) Init() {

}

func (this *RouteKeyField) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("RouteKeyField Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *RouteKeyField) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > RouteKeyFieldCurrentVersion {
		cutVer = RouteKeyFieldCurrentVersion
	}
	// check cut version
	if cutVer < RouteKeyFieldBaseVersion {
		return errors.New("RouteKeyField cut version must large than RouteKeyFieldBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.FieldName))+1)
	if err != nil {
		return errors.New("RouteKeyField.FieldName string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.FieldName), 0))
	if err != nil {
		return errors.New("RouteKeyField.FieldName string content pack error\n" + err.Error())
	}

	return nil
}

func (this *RouteKeyField) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("RouteKeyField data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *RouteKeyField) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > RouteKeyFieldCurrentVersion {
		cutVer = RouteKeyFieldCurrentVersion
	}
	// check version
	if cutVer < RouteKeyFieldBaseVersion {
		errors.New("RouteKeyField cut version must large than RouteKeyFieldBaseVersion\n")
	}

	var FieldNameSize uint32
	err = binary.Read(r, binary.BigEndian, &FieldNameSize)
	if err != nil {
		return errors.New("RouteKeyField.FieldName string size unpack error\n" + err.Error())
	}

	FieldNameBytes := make([]byte, FieldNameSize)
	err = binary.Read(r, binary.BigEndian, FieldNameBytes)
	if err != nil {
		return errors.New("RouteKeyField.FieldName string content unpack error\n" + err.Error())
	}
	this.FieldName = string(FieldNameBytes[:len(FieldNameBytes)-1])

	return err
}

const (
	RouteKeySetBaseVersion    uint32 = 17
	RouteKeySetCurrentVersion uint32 = 17
)

// RouteKeySet
type RouteKeySet struct {
	FieldNum uint32 `tdr_field:"FieldNum"`

	Fields []*RouteKeyField `tdr_field:"Fields" tdr_count:"8" tdr_refer:"FieldNum"`

	HashFlag int32 `tdr_field:"HashFlag"`

	ModNum int32 `tdr_field:"ModNum"`
}

func NewRouteKeySet() *RouteKeySet {
	obj := new(RouteKeySet)
	obj.Init()
	return obj
}

func (this *RouteKeySet) GetBaseVersion() uint32 {
	return RouteKeySetBaseVersion
}

func (this *RouteKeySet) GetCurrentVersion() uint32 {
	return RouteKeySetCurrentVersion
}

func (this *RouteKeySet) Init() {
	this.FieldNum = 0

}

func (this *RouteKeySet) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("RouteKeySet Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *RouteKeySet) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > RouteKeySetCurrentVersion {
		cutVer = RouteKeySetCurrentVersion
	}
	// check cut version
	if cutVer < RouteKeySetBaseVersion {
		return errors.New("RouteKeySet cut version must large than RouteKeySetBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.FieldNum)
	if err != nil {
		return errors.New("RouteKeySet.FieldNum pack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("RouteKeySet.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 8 {
		return errors.New("RouteKeySet.Fields's refer FieldNum should <= count 8")
	}
	if len(this.Fields) < int(this.FieldNum) {
		return errors.New("RouteKeySet.Fields's length should > FieldNum")
	}
	if this.FieldNum > 0 {
		for i := 0; i < int(this.FieldNum); i++ {
			err = this.Fields[i].PackTo(cutVer, w)
			if err != nil {
				return errors.New("RouteKeySet.Fields pack error\n" + err.Error())
			}

		}
	}

	err = binary.Write(w, binary.BigEndian, this.HashFlag)
	if err != nil {
		return errors.New("RouteKeySet.HashFlag pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ModNum)
	if err != nil {
		return errors.New("RouteKeySet.ModNum pack error\n" + err.Error())
	}

	return nil
}

func (this *RouteKeySet) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("RouteKeySet data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *RouteKeySet) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > RouteKeySetCurrentVersion {
		cutVer = RouteKeySetCurrentVersion
	}
	// check version
	if cutVer < RouteKeySetBaseVersion {
		errors.New("RouteKeySet cut version must large than RouteKeySetBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.FieldNum)
	if err != nil {
		return errors.New("RouteKeySet.FieldNum unpack error\n" + err.Error())
	}

	if this.FieldNum < 0 {
		return errors.New("RouteKeySet.Fields's refer FieldNum should >= 0")
	}
	if this.FieldNum > 8 {
		return errors.New("RouteKeySet.Fields's refer FieldNum should <= count 8")
	}

	if this.Fields == nil {
		this.Fields = make([]*RouteKeyField, int(this.FieldNum))
		for i := 0; i < int(this.FieldNum); i++ {
			this.Fields[i] = NewRouteKeyField()
		}
	}

	for i := 0; i < int(this.FieldNum); i++ {
		err = this.Fields[i].UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("RouteKeySet.Fields unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.HashFlag)
	if err != nil {
		return errors.New("RouteKeySet.HashFlag unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ModNum)
	if err != nil {
		return errors.New("RouteKeySet.ModNum unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusTableTraverseReqBaseVersion         uint32 = 12
	TCaplusTableTraverseReqCurrentVersion      uint32 = 19
	TCaplusTableTraverseReqResNumPerReqVersion uint32 = 17
	TCaplusTableTraverseReqMaxSpeedVersion     uint32 = 17
	TCaplusTableTraverseReqRouteKeySetVersion  uint32 = 17
	TCaplusTableTraverseReqBeginIndexVersion   uint32 = 17
	TCaplusTableTraverseReqEndIndexVersion     uint32 = 17
	TCaplusTableTraverseReqSequenceVersion     uint32 = 18
	TCaplusTableTraverseReqToTalLimitVersion   uint32 = 19
	TCaplusTableTraverseReqTraversedCntVersion uint32 = 19
)

// TCaplusTableTraverseReq
type TCaplusTableTraverseReq struct {
	Offset uint64 `tdr_field:"Offset"`

	BatchLimit int32 `tdr_field:"BatchLimit"`

	ValueInfo *TCaplusNameSet `tdr_field:"ValueInfo"`

	ResNumPerReq uint32 `tdr_field:"ResNumPerReq"`

	MaxSpeed uint32 `tdr_field:"MaxSpeed"`

	RouteKeySet *RouteKeySet `tdr_field:"RouteKeySet"`

	BeginIndex int32 `tdr_field:"BeginIndex"`

	EndIndex int32 `tdr_field:"EndIndex"`

	Sequence uint64 `tdr_field:"Sequence"`

	ToTalLimit int64 `tdr_field:"ToTalLimit"`

	TraversedCnt int64 `tdr_field:"TraversedCnt"`
}

func NewTCaplusTableTraverseReq() *TCaplusTableTraverseReq {
	obj := new(TCaplusTableTraverseReq)
	obj.Init()
	return obj
}

func (this *TCaplusTableTraverseReq) GetBaseVersion() uint32 {
	return TCaplusTableTraverseReqBaseVersion
}

func (this *TCaplusTableTraverseReq) GetCurrentVersion() uint32 {
	return TCaplusTableTraverseReqCurrentVersion
}

func (this *TCaplusTableTraverseReq) Init() {
	this.Offset = 0

	this.BatchLimit = -1

	this.ValueInfo = NewTCaplusNameSet()

	this.ResNumPerReq = 1

	this.MaxSpeed = 20

	this.RouteKeySet = NewRouteKeySet()

	this.BeginIndex = -1

	this.EndIndex = -1

	this.Sequence = 0

	this.ToTalLimit = 0

	this.TraversedCnt = 0

}

func (this *TCaplusTableTraverseReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusTableTraverseReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusTableTraverseReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusTableTraverseReqCurrentVersion {
		cutVer = TCaplusTableTraverseReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusTableTraverseReqBaseVersion {
		return errors.New("TCaplusTableTraverseReq cut version must large than TCaplusTableTraverseReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Offset)
	if err != nil {
		return errors.New("TCaplusTableTraverseReq.Offset pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BatchLimit)
	if err != nil {
		return errors.New("TCaplusTableTraverseReq.BatchLimit pack error\n" + err.Error())
	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusTableTraverseReq.ValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusTableTraverseReqResNumPerReqVersion {

		err = binary.Write(w, binary.BigEndian, this.ResNumPerReq)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.ResNumPerReq pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqMaxSpeedVersion {

		err = binary.Write(w, binary.BigEndian, this.MaxSpeed)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.MaxSpeed pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqRouteKeySetVersion {

		err = this.RouteKeySet.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.RouteKeySet pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqBeginIndexVersion {

		err = binary.Write(w, binary.BigEndian, this.BeginIndex)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.BeginIndex pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqEndIndexVersion {

		err = binary.Write(w, binary.BigEndian, this.EndIndex)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.EndIndex pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqSequenceVersion {

		err = binary.Write(w, binary.BigEndian, this.Sequence)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.Sequence pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqToTalLimitVersion {

		err = binary.Write(w, binary.BigEndian, this.ToTalLimit)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.ToTalLimit pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseReqTraversedCntVersion {

		err = binary.Write(w, binary.BigEndian, this.TraversedCnt)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.TraversedCnt pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusTableTraverseReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusTableTraverseReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusTableTraverseReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusTableTraverseReqCurrentVersion {
		cutVer = TCaplusTableTraverseReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusTableTraverseReqBaseVersion {
		errors.New("TCaplusTableTraverseReq cut version must large than TCaplusTableTraverseReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Offset)
	if err != nil {
		return errors.New("TCaplusTableTraverseReq.Offset unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BatchLimit)
	if err != nil {
		return errors.New("TCaplusTableTraverseReq.BatchLimit unpack error\n" + err.Error())
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusTableTraverseReq.ValueInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusTableTraverseReqResNumPerReqVersion {

		err = binary.Read(r, binary.BigEndian, &this.ResNumPerReq)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.ResNumPerReq unpack error\n" + err.Error())
		}

	} else {
		this.ResNumPerReq = 1

	}
	if cutVer >= TCaplusTableTraverseReqMaxSpeedVersion {

		err = binary.Read(r, binary.BigEndian, &this.MaxSpeed)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.MaxSpeed unpack error\n" + err.Error())
		}

	} else {
		this.MaxSpeed = 20

	}
	if cutVer >= TCaplusTableTraverseReqRouteKeySetVersion {

		err = this.RouteKeySet.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.RouteKeySet unpack error\n" + err.Error())
		}

	} else {
		this.RouteKeySet.Init()

	}
	if cutVer >= TCaplusTableTraverseReqBeginIndexVersion {

		err = binary.Read(r, binary.BigEndian, &this.BeginIndex)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.BeginIndex unpack error\n" + err.Error())
		}

	} else {
		this.BeginIndex = -1

	}
	if cutVer >= TCaplusTableTraverseReqEndIndexVersion {

		err = binary.Read(r, binary.BigEndian, &this.EndIndex)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.EndIndex unpack error\n" + err.Error())
		}

	} else {
		this.EndIndex = -1

	}
	if cutVer >= TCaplusTableTraverseReqSequenceVersion {

		err = binary.Read(r, binary.BigEndian, &this.Sequence)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.Sequence unpack error\n" + err.Error())
		}

	} else {
		this.Sequence = 0

	}
	if cutVer >= TCaplusTableTraverseReqToTalLimitVersion {

		err = binary.Read(r, binary.BigEndian, &this.ToTalLimit)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.ToTalLimit unpack error\n" + err.Error())
		}

	} else {
		this.ToTalLimit = 0

	}
	if cutVer >= TCaplusTableTraverseReqTraversedCntVersion {

		err = binary.Read(r, binary.BigEndian, &this.TraversedCnt)
		if err != nil {
			return errors.New("TCaplusTableTraverseReq.TraversedCnt unpack error\n" + err.Error())
		}

	} else {
		this.TraversedCnt = 0

	}
	return err
}

const (
	TCaplusTableTraverseResBaseVersion         uint32 = 12
	TCaplusTableTraverseResCurrentVersion      uint32 = 88
	TCaplusTableTraverseResSequenceVersion     uint32 = 18
	TCaplusTableTraverseResTraversedCntVersion uint32 = 19
	TCaplusTableTraverseResCurSrvIDVersion     uint32 = 88
)

// TCaplusTableTraverseRes
type TCaplusTableTraverseRes struct {
	Result int32 `tdr_field:"Result"`

	Offset uint64 `tdr_field:"Offset"`

	Completed int32 `tdr_field:"Completed"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	BatchValueLen int32 `tdr_field:"BatchValueLen"`

	BatchValueInfo []byte `tdr_field:"BatchValueInfo" tdr_count:"10300000" tdr_refer:"BatchValueLen"`

	Sequence uint64 `tdr_field:"Sequence"`

	TraversedCnt int64 `tdr_field:"TraversedCnt"`

	CurSrvID string `tdr_field:"CurSrvID"`
}

func NewTCaplusTableTraverseRes() *TCaplusTableTraverseRes {
	obj := new(TCaplusTableTraverseRes)
	obj.Init()
	return obj
}

func (this *TCaplusTableTraverseRes) GetBaseVersion() uint32 {
	return TCaplusTableTraverseResBaseVersion
}

func (this *TCaplusTableTraverseRes) GetCurrentVersion() uint32 {
	return TCaplusTableTraverseResCurrentVersion
}

func (this *TCaplusTableTraverseRes) Init() {

	this.BatchValueLen = 0

	this.Sequence = 0

	this.TraversedCnt = 0

}

func (this *TCaplusTableTraverseRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusTableTraverseRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusTableTraverseRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusTableTraverseResCurrentVersion {
		cutVer = TCaplusTableTraverseResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusTableTraverseResBaseVersion {
		return errors.New("TCaplusTableTraverseRes cut version must large than TCaplusTableTraverseResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Offset)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.Offset pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Completed)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.Completed pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.BatchValueLen pack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusTableTraverseRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusTableTraverseRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}
	if len(this.BatchValueInfo) < int(this.BatchValueLen) {
		return errors.New("TCaplusTableTraverseRes.BatchValueInfo's length should > BatchValueLen")
	}
	if this.BatchValueLen > 0 {
		referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
		err = binary.Write(w, binary.BigEndian, referBatchValueInfo)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.BatchValueInfo pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusTableTraverseResSequenceVersion {

		err = binary.Write(w, binary.BigEndian, this.Sequence)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.Sequence pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseResTraversedCntVersion {

		err = binary.Write(w, binary.BigEndian, this.TraversedCnt)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.TraversedCnt pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusTableTraverseResCurSrvIDVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.CurSrvID))+1)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.CurSrvID string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.CurSrvID), 0))
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.CurSrvID string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusTableTraverseRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusTableTraverseRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusTableTraverseRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusTableTraverseResCurrentVersion {
		cutVer = TCaplusTableTraverseResCurrentVersion
	}
	// check version
	if cutVer < TCaplusTableTraverseResBaseVersion {
		errors.New("TCaplusTableTraverseRes cut version must large than TCaplusTableTraverseResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Offset)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.Offset unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Completed)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.Completed unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BatchValueLen)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.BatchValueLen unpack error\n" + err.Error())
	}

	if this.BatchValueLen < 0 {
		return errors.New("TCaplusTableTraverseRes.BatchValueInfo's refer BatchValueLen should >= 0")
	}
	if this.BatchValueLen > 10300000 {
		return errors.New("TCaplusTableTraverseRes.BatchValueInfo's refer BatchValueLen should <= count 10300000")
	}

	if this.BatchValueInfo == nil {
		this.BatchValueInfo = make([]byte, int(this.BatchValueLen))
	}

	referBatchValueInfo := this.BatchValueInfo[:this.BatchValueLen]
	err = binary.Read(r, binary.BigEndian, referBatchValueInfo)
	if err != nil {
		return errors.New("TCaplusTableTraverseRes.BatchValueInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusTableTraverseResSequenceVersion {

		err = binary.Read(r, binary.BigEndian, &this.Sequence)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.Sequence unpack error\n" + err.Error())
		}

	} else {
		this.Sequence = 0

	}
	if cutVer >= TCaplusTableTraverseResTraversedCntVersion {

		err = binary.Read(r, binary.BigEndian, &this.TraversedCnt)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.TraversedCnt unpack error\n" + err.Error())
		}

	} else {
		this.TraversedCnt = 0

	}
	if cutVer >= TCaplusTableTraverseResCurSrvIDVersion {

		var CurSrvIDSize uint32
		err = binary.Read(r, binary.BigEndian, &CurSrvIDSize)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.CurSrvID string size unpack error\n" + err.Error())
		}

		CurSrvIDBytes := make([]byte, CurSrvIDSize)
		err = binary.Read(r, binary.BigEndian, CurSrvIDBytes)
		if err != nil {
			return errors.New("TCaplusTableTraverseRes.CurSrvID string content unpack error\n" + err.Error())
		}
		this.CurSrvID = string(CurSrvIDBytes[:len(CurSrvIDBytes)-1])

	}
	return err
}

const (
	TCaplusListTableTraverseReqBaseVersion    uint32 = 55
	TCaplusListTableTraverseReqCurrentVersion uint32 = 55
)

// TCaplusListTableTraverseReq
type TCaplusListTableTraverseReq struct {
	Offset uint64 `tdr_field:"Offset"`

	KeyLimit int32 `tdr_field:"KeyLimit"`

	ValueInfo *TCaplusNameSet `tdr_field:"ValueInfo"`

	MaxSpeed uint32 `tdr_field:"MaxSpeed"`

	RouteKeySet *RouteKeySet `tdr_field:"RouteKeySet"`

	BeginIndex int32 `tdr_field:"BeginIndex"`

	EndIndex int32 `tdr_field:"EndIndex"`

	Sequence uint64 `tdr_field:"Sequence"`

	ToTalLimit int64 `tdr_field:"ToTalLimit"`

	TraversedCnt int64 `tdr_field:"TraversedCnt"`
}

func NewTCaplusListTableTraverseReq() *TCaplusListTableTraverseReq {
	obj := new(TCaplusListTableTraverseReq)
	obj.Init()
	return obj
}

func (this *TCaplusListTableTraverseReq) GetBaseVersion() uint32 {
	return TCaplusListTableTraverseReqBaseVersion
}

func (this *TCaplusListTableTraverseReq) GetCurrentVersion() uint32 {
	return TCaplusListTableTraverseReqCurrentVersion
}

func (this *TCaplusListTableTraverseReq) Init() {
	this.Offset = 0

	this.KeyLimit = 1

	this.ValueInfo = NewTCaplusNameSet()

	this.MaxSpeed = 20

	this.RouteKeySet = NewRouteKeySet()

	this.BeginIndex = -1

	this.EndIndex = -1

	this.Sequence = 0

	this.ToTalLimit = 0

	this.TraversedCnt = 0

}

func (this *TCaplusListTableTraverseReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListTableTraverseReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListTableTraverseReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListTableTraverseReqCurrentVersion {
		cutVer = TCaplusListTableTraverseReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListTableTraverseReqBaseVersion {
		return errors.New("TCaplusListTableTraverseReq cut version must large than TCaplusListTableTraverseReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Offset)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.Offset pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.KeyLimit)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.KeyLimit pack error\n" + err.Error())
	}

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.ValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.MaxSpeed)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.MaxSpeed pack error\n" + err.Error())
	}

	err = this.RouteKeySet.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.RouteKeySet pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BeginIndex)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.BeginIndex pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.EndIndex)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.EndIndex pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Sequence)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.Sequence pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ToTalLimit)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.ToTalLimit pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TraversedCnt)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.TraversedCnt pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListTableTraverseReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListTableTraverseReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListTableTraverseReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListTableTraverseReqCurrentVersion {
		cutVer = TCaplusListTableTraverseReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListTableTraverseReqBaseVersion {
		errors.New("TCaplusListTableTraverseReq cut version must large than TCaplusListTableTraverseReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Offset)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.Offset unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyLimit)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.KeyLimit unpack error\n" + err.Error())
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.ValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.MaxSpeed)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.MaxSpeed unpack error\n" + err.Error())
	}

	err = this.RouteKeySet.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.RouteKeySet unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BeginIndex)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.BeginIndex unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.EndIndex)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.EndIndex unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Sequence)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.Sequence unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ToTalLimit)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.ToTalLimit unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TraversedCnt)
	if err != nil {
		return errors.New("TCaplusListTableTraverseReq.TraversedCnt unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListTableTraverseResBaseVersion     uint32 = 55
	TCaplusListTableTraverseResCurrentVersion  uint32 = 88
	TCaplusListTableTraverseResCurSrvIDVersion uint32 = 88
)

// TCaplusListTableTraverseRes
type TCaplusListTableTraverseRes struct {
	Result int32 `tdr_field:"Result"`

	Offset uint64 `tdr_field:"Offset"`

	Completed int32 `tdr_field:"Completed"`

	KeyCompleted int32 `tdr_field:"KeyCompleted"`

	ResultKeyInfo *TCaplusKeySet `tdr_field:"ResultKeyInfo"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	ResultValueInfo *TCaplusListElementSet `tdr_field:"ResultValueInfo"`

	Sequence uint64 `tdr_field:"Sequence"`

	TraversedCnt int64 `tdr_field:"TraversedCnt"`

	CurSrvID string `tdr_field:"CurSrvID"`
}

func NewTCaplusListTableTraverseRes() *TCaplusListTableTraverseRes {
	obj := new(TCaplusListTableTraverseRes)
	obj.Init()
	return obj
}

func (this *TCaplusListTableTraverseRes) GetBaseVersion() uint32 {
	return TCaplusListTableTraverseResBaseVersion
}

func (this *TCaplusListTableTraverseRes) GetCurrentVersion() uint32 {
	return TCaplusListTableTraverseResCurrentVersion
}

func (this *TCaplusListTableTraverseRes) Init() {

	this.ResultKeyInfo = NewTCaplusKeySet()

	this.ResultValueInfo = NewTCaplusListElementSet()

	this.Sequence = 0

	this.TraversedCnt = 0

}

func (this *TCaplusListTableTraverseRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListTableTraverseRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListTableTraverseRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListTableTraverseResCurrentVersion {
		cutVer = TCaplusListTableTraverseResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListTableTraverseResBaseVersion {
		return errors.New("TCaplusListTableTraverseRes cut version must large than TCaplusListTableTraverseResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Offset)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Offset pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Completed)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Completed pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.KeyCompleted)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.KeyCompleted pack error\n" + err.Error())
	}

	err = this.ResultKeyInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.ResultKeyInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.RecordNum pack error\n" + err.Error())
	}

	err = this.ResultValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.ResultValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Sequence)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Sequence pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TraversedCnt)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.TraversedCnt pack error\n" + err.Error())
	}

	if cutVer >= TCaplusListTableTraverseResCurSrvIDVersion {

		err = binary.Write(w, binary.BigEndian, uint32(len(this.CurSrvID))+1)
		if err != nil {
			return errors.New("TCaplusListTableTraverseRes.CurSrvID string size pack error\n" + err.Error())
		}
		err = binary.Write(w, binary.BigEndian, append([]byte(this.CurSrvID), 0))
		if err != nil {
			return errors.New("TCaplusListTableTraverseRes.CurSrvID string content pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusListTableTraverseRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListTableTraverseRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListTableTraverseRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListTableTraverseResCurrentVersion {
		cutVer = TCaplusListTableTraverseResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListTableTraverseResBaseVersion {
		errors.New("TCaplusListTableTraverseRes cut version must large than TCaplusListTableTraverseResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Offset)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Offset unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Completed)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Completed unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyCompleted)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.KeyCompleted unpack error\n" + err.Error())
	}

	err = this.ResultKeyInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.ResultKeyInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.RecordNum unpack error\n" + err.Error())
	}

	err = this.ResultValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.ResultValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Sequence)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.Sequence unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TraversedCnt)
	if err != nil {
		return errors.New("TCaplusListTableTraverseRes.TraversedCnt unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusListTableTraverseResCurSrvIDVersion {

		var CurSrvIDSize uint32
		err = binary.Read(r, binary.BigEndian, &CurSrvIDSize)
		if err != nil {
			return errors.New("TCaplusListTableTraverseRes.CurSrvID string size unpack error\n" + err.Error())
		}

		CurSrvIDBytes := make([]byte, CurSrvIDSize)
		err = binary.Read(r, binary.BigEndian, CurSrvIDBytes)
		if err != nil {
			return errors.New("TCaplusListTableTraverseRes.CurSrvID string content unpack error\n" + err.Error())
		}
		this.CurSrvID = string(CurSrvIDBytes[:len(CurSrvIDBytes)-1])

	}
	return err
}

const (
	TCaplusSysListGetReqBaseVersion    uint32 = 55
	TCaplusSysListGetReqCurrentVersion uint32 = 55
)

// TCaplusSysListGetReq
type TCaplusSysListGetReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	ElementValueNames *TCaplusNameSet `tdr_field:"ElementValueNames"`
}

func NewTCaplusSysListGetReq() *TCaplusSysListGetReq {
	obj := new(TCaplusSysListGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysListGetReq) GetBaseVersion() uint32 {
	return TCaplusSysListGetReqBaseVersion
}

func (this *TCaplusSysListGetReq) GetCurrentVersion() uint32 {
	return TCaplusSysListGetReqCurrentVersion
}

func (this *TCaplusSysListGetReq) Init() {
	this.ElementIndex = 0

	this.ElementValueNames = NewTCaplusNameSet()

}

func (this *TCaplusSysListGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListGetReqCurrentVersion {
		cutVer = TCaplusSysListGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListGetReqBaseVersion {
		return errors.New("TCaplusSysListGetReq cut version must large than TCaplusSysListGetReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListGetReq.ElementIndex pack error\n" + err.Error())
	}

	err = this.ElementValueNames.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListGetReq.ElementValueNames pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListGetReqCurrentVersion {
		cutVer = TCaplusSysListGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListGetReqBaseVersion {
		errors.New("TCaplusSysListGetReq cut version must large than TCaplusSysListGetReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListGetReq.ElementIndex unpack error\n" + err.Error())
	}

	err = this.ElementValueNames.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListGetReq.ElementValueNames unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysListGetResBaseVersion    uint32 = 55
	TCaplusSysListGetResCurrentVersion uint32 = 55
)

// TCaplusSysListGetRes
type TCaplusSysListGetRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusSysListGetRes() *TCaplusSysListGetRes {
	obj := new(TCaplusSysListGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysListGetRes) GetBaseVersion() uint32 {
	return TCaplusSysListGetResBaseVersion
}

func (this *TCaplusSysListGetRes) GetCurrentVersion() uint32 {
	return TCaplusSysListGetResCurrentVersion
}

func (this *TCaplusSysListGetRes) Init() {

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusSysListGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListGetResCurrentVersion {
		cutVer = TCaplusSysListGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListGetResBaseVersion {
		return errors.New("TCaplusSysListGetRes cut version must large than TCaplusSysListGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysListGetRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListGetRes.ResultInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysListGetRes.LastAccessTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListGetResCurrentVersion {
		cutVer = TCaplusSysListGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListGetResBaseVersion {
		errors.New("TCaplusSysListGetRes cut version must large than TCaplusSysListGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysListGetRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListGetRes.ResultInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysListGetRes.LastAccessTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysListGetAllReqBaseVersion    uint32 = 55
	TCaplusSysListGetAllReqCurrentVersion uint32 = 55
)

// TCaplusSysListGetAllReq
type TCaplusSysListGetAllReq struct {
	AllowMultiResponses byte `tdr_field:"AllowMultiResponses"`

	ElementNum int32 `tdr_field:"ElementNum"`

	StartSubscript int32 `tdr_field:"StartSubscript"`

	ElementValueNames *TCaplusNameSet `tdr_field:"ElementValueNames"`
}

func NewTCaplusSysListGetAllReq() *TCaplusSysListGetAllReq {
	obj := new(TCaplusSysListGetAllReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysListGetAllReq) GetBaseVersion() uint32 {
	return TCaplusSysListGetAllReqBaseVersion
}

func (this *TCaplusSysListGetAllReq) GetCurrentVersion() uint32 {
	return TCaplusSysListGetAllReqCurrentVersion
}

func (this *TCaplusSysListGetAllReq) Init() {
	this.AllowMultiResponses = 0

	this.ElementNum = -1

	this.StartSubscript = 0

	this.ElementValueNames = NewTCaplusNameSet()

}

func (this *TCaplusSysListGetAllReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListGetAllReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListGetAllReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListGetAllReqCurrentVersion {
		cutVer = TCaplusSysListGetAllReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListGetAllReqBaseVersion {
		return errors.New("TCaplusSysListGetAllReq cut version must large than TCaplusSysListGetAllReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.AllowMultiResponses pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ElementNum)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.ElementNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.StartSubscript)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.StartSubscript pack error\n" + err.Error())
	}

	err = this.ElementValueNames.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.ElementValueNames pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListGetAllReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListGetAllReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListGetAllReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListGetAllReqCurrentVersion {
		cutVer = TCaplusSysListGetAllReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListGetAllReqBaseVersion {
		errors.New("TCaplusSysListGetAllReq cut version must large than TCaplusSysListGetAllReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.AllowMultiResponses)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.AllowMultiResponses unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementNum)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.ElementNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.StartSubscript)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.StartSubscript unpack error\n" + err.Error())
	}

	err = this.ElementValueNames.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListGetAllReq.ElementValueNames unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysListGetAllResBaseVersion           uint32 = 55
	TCaplusSysListGetAllResCurrentVersion        uint32 = 113
	TCaplusSysListGetAllResEmptyIndexFlagVersion uint32 = 113
)

// TCaplusSysListGetAllRes
type TCaplusSysListGetAllRes struct {
	Result int32 `tdr_field:"Result"`

	IsCompleteFlag int32 `tdr_field:"IsCompleteFlag"`

	TotalElementNumOnServer uint32 `tdr_field:"TotalElementNumOnServer"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`

	BiggestIdx uint32 `tdr_field:"BiggestIdx"`

	EmptyIndexFlag int32 `tdr_field:"EmptyIndexFlag"`
}

func NewTCaplusSysListGetAllRes() *TCaplusSysListGetAllRes {
	obj := new(TCaplusSysListGetAllRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysListGetAllRes) GetBaseVersion() uint32 {
	return TCaplusSysListGetAllResBaseVersion
}

func (this *TCaplusSysListGetAllRes) GetCurrentVersion() uint32 {
	return TCaplusSysListGetAllResCurrentVersion
}

func (this *TCaplusSysListGetAllRes) Init() {

	this.IsCompleteFlag = 1

	this.ResultInfo = NewTCaplusListElementSet()

	this.EmptyIndexFlag = 0

}

func (this *TCaplusSysListGetAllRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListGetAllRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListGetAllRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListGetAllResCurrentVersion {
		cutVer = TCaplusSysListGetAllResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListGetAllResBaseVersion {
		return errors.New("TCaplusSysListGetAllRes cut version must large than TCaplusSysListGetAllResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.IsCompleteFlag pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TotalElementNumOnServer)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.TotalElementNumOnServer pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.ResultInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BiggestIdx)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.BiggestIdx pack error\n" + err.Error())
	}

	if cutVer >= TCaplusSysListGetAllResEmptyIndexFlagVersion {

		err = binary.Write(w, binary.BigEndian, this.EmptyIndexFlag)
		if err != nil {
			return errors.New("TCaplusSysListGetAllRes.EmptyIndexFlag pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusSysListGetAllRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListGetAllRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListGetAllRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListGetAllResCurrentVersion {
		cutVer = TCaplusSysListGetAllResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListGetAllResBaseVersion {
		errors.New("TCaplusSysListGetAllRes cut version must large than TCaplusSysListGetAllResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.IsCompleteFlag unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.TotalElementNumOnServer)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.TotalElementNumOnServer unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.ResultInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BiggestIdx)
	if err != nil {
		return errors.New("TCaplusSysListGetAllRes.BiggestIdx unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusSysListGetAllResEmptyIndexFlagVersion {

		err = binary.Read(r, binary.BigEndian, &this.EmptyIndexFlag)
		if err != nil {
			return errors.New("TCaplusSysListGetAllRes.EmptyIndexFlag unpack error\n" + err.Error())
		}

	} else {
		this.EmptyIndexFlag = 0

	}
	return err
}

const (
	TCaplusGetShardListReqBaseVersion       uint32 = 12
	TCaplusGetShardListReqCurrentVersion    uint32 = 17
	TCaplusGetShardListReqBeginIndexVersion uint32 = 17
	TCaplusGetShardListReqEndIndexVersion   uint32 = 17
)

// TCaplusGetShardListReq
type TCaplusGetShardListReq struct {
	Reserve int32 `tdr_field:"Reserve"`

	BeginIndex int32 `tdr_field:"BeginIndex"`

	EndIndex int32 `tdr_field:"EndIndex"`
}

func NewTCaplusGetShardListReq() *TCaplusGetShardListReq {
	obj := new(TCaplusGetShardListReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetShardListReq) GetBaseVersion() uint32 {
	return TCaplusGetShardListReqBaseVersion
}

func (this *TCaplusGetShardListReq) GetCurrentVersion() uint32 {
	return TCaplusGetShardListReqCurrentVersion
}

func (this *TCaplusGetShardListReq) Init() {

	this.BeginIndex = -1

	this.EndIndex = -1

}

func (this *TCaplusGetShardListReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetShardListReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetShardListReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetShardListReqCurrentVersion {
		cutVer = TCaplusGetShardListReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetShardListReqBaseVersion {
		return errors.New("TCaplusGetShardListReq cut version must large than TCaplusGetShardListReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Reserve)
	if err != nil {
		return errors.New("TCaplusGetShardListReq.Reserve pack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetShardListReqBeginIndexVersion {

		err = binary.Write(w, binary.BigEndian, this.BeginIndex)
		if err != nil {
			return errors.New("TCaplusGetShardListReq.BeginIndex pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusGetShardListReqEndIndexVersion {

		err = binary.Write(w, binary.BigEndian, this.EndIndex)
		if err != nil {
			return errors.New("TCaplusGetShardListReq.EndIndex pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusGetShardListReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetShardListReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetShardListReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetShardListReqCurrentVersion {
		cutVer = TCaplusGetShardListReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetShardListReqBaseVersion {
		errors.New("TCaplusGetShardListReq cut version must large than TCaplusGetShardListReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Reserve)
	if err != nil {
		return errors.New("TCaplusGetShardListReq.Reserve unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetShardListReqBeginIndexVersion {

		err = binary.Read(r, binary.BigEndian, &this.BeginIndex)
		if err != nil {
			return errors.New("TCaplusGetShardListReq.BeginIndex unpack error\n" + err.Error())
		}

	} else {
		this.BeginIndex = -1

	}
	if cutVer >= TCaplusGetShardListReqEndIndexVersion {

		err = binary.Read(r, binary.BigEndian, &this.EndIndex)
		if err != nil {
			return errors.New("TCaplusGetShardListReq.EndIndex unpack error\n" + err.Error())
		}

	} else {
		this.EndIndex = -1

	}
	return err
}

const (
	TCaplusGetShardListResBaseVersion        uint32 = 12
	TCaplusGetShardListResCurrentVersion     uint32 = 17
	TCaplusGetShardListResRouteKeySetVersion uint32 = 17
)

// TCaplusGetShardListRes
type TCaplusGetShardListRes struct {
	Result int32 `tdr_field:"Result"`

	ShardNum int32 `tdr_field:"ShardNum"`

	ShardList []int32 `tdr_field:"ShardList" tdr_count:"10000" tdr_refer:"ShardNum"`

	RouteKeySet *RouteKeySet `tdr_field:"RouteKeySet"`
}

func NewTCaplusGetShardListRes() *TCaplusGetShardListRes {
	obj := new(TCaplusGetShardListRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetShardListRes) GetBaseVersion() uint32 {
	return TCaplusGetShardListResBaseVersion
}

func (this *TCaplusGetShardListRes) GetCurrentVersion() uint32 {
	return TCaplusGetShardListResCurrentVersion
}

func (this *TCaplusGetShardListRes) Init() {

	this.ShardNum = 0

	this.RouteKeySet = NewRouteKeySet()

}

func (this *TCaplusGetShardListRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetShardListRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetShardListRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetShardListResCurrentVersion {
		cutVer = TCaplusGetShardListResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetShardListResBaseVersion {
		return errors.New("TCaplusGetShardListRes cut version must large than TCaplusGetShardListResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusGetShardListRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ShardNum)
	if err != nil {
		return errors.New("TCaplusGetShardListRes.ShardNum pack error\n" + err.Error())
	}

	if this.ShardNum < 0 {
		return errors.New("TCaplusGetShardListRes.ShardList's refer ShardNum should >= 0")
	}
	if this.ShardNum > 10000 {
		return errors.New("TCaplusGetShardListRes.ShardList's refer ShardNum should <= count 10000")
	}
	if len(this.ShardList) < int(this.ShardNum) {
		return errors.New("TCaplusGetShardListRes.ShardList's length should > ShardNum")
	}
	if this.ShardNum > 0 {
		referShardList := this.ShardList[:this.ShardNum]
		err = binary.Write(w, binary.BigEndian, referShardList)
		if err != nil {
			return errors.New("TCaplusGetShardListRes.ShardList pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusGetShardListResRouteKeySetVersion {

		err = this.RouteKeySet.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusGetShardListRes.RouteKeySet pack error\n" + err.Error())
		}

	}

	return nil
}

func (this *TCaplusGetShardListRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetShardListRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetShardListRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetShardListResCurrentVersion {
		cutVer = TCaplusGetShardListResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetShardListResBaseVersion {
		errors.New("TCaplusGetShardListRes cut version must large than TCaplusGetShardListResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusGetShardListRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ShardNum)
	if err != nil {
		return errors.New("TCaplusGetShardListRes.ShardNum unpack error\n" + err.Error())
	}

	if this.ShardNum < 0 {
		return errors.New("TCaplusGetShardListRes.ShardList's refer ShardNum should >= 0")
	}
	if this.ShardNum > 10000 {
		return errors.New("TCaplusGetShardListRes.ShardList's refer ShardNum should <= count 10000")
	}

	if this.ShardList == nil {
		this.ShardList = make([]int32, int(this.ShardNum))
	}

	referShardList := this.ShardList[:this.ShardNum]
	err = binary.Read(r, binary.BigEndian, referShardList)
	if err != nil {
		return errors.New("TCaplusGetShardListRes.ShardList pack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetShardListResRouteKeySetVersion {

		err = this.RouteKeySet.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusGetShardListRes.RouteKeySet unpack error\n" + err.Error())
		}

	} else {
		this.RouteKeySet.Init()

	}
	return err
}

const (
	TCaplusRouterInfoBaseVersion    uint32 = 1
	TCaplusRouterInfoCurrentVersion uint32 = 2
	TCaplusRouterInfoAppIDVersion   uint32 = 2
	TCaplusRouterInfoZoneIDVersion  uint32 = 2
	TCaplusRouterInfoShardIDVersion uint32 = 2
)

// TCaplusRouterInfo
type TCaplusRouterInfo struct {
	AppID int32 `tdr_field:"AppID"`

	ZoneID int32 `tdr_field:"ZoneID"`

	ShardID int32 `tdr_field:"ShardID"`

	TableNameLen uint32 `tdr_field:"TableNameLen"`

	TableName []byte `tdr_field:"TableName" tdr_count:"32" tdr_refer:"TableNameLen"`
}

func NewTCaplusRouterInfo() *TCaplusRouterInfo {
	obj := new(TCaplusRouterInfo)
	obj.Init()
	return obj
}

func (this *TCaplusRouterInfo) GetBaseVersion() uint32 {
	return TCaplusRouterInfoBaseVersion
}

func (this *TCaplusRouterInfo) GetCurrentVersion() uint32 {
	return TCaplusRouterInfoCurrentVersion
}

func (this *TCaplusRouterInfo) Init() {

	this.TableNameLen = 0

}

func (this *TCaplusRouterInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusRouterInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusRouterInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusRouterInfoCurrentVersion {
		cutVer = TCaplusRouterInfoCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusRouterInfoBaseVersion {
		return errors.New("TCaplusRouterInfo cut version must large than TCaplusRouterInfoBaseVersion\n")
	}

	var err error
	if cutVer >= TCaplusRouterInfoAppIDVersion {

		err = binary.Write(w, binary.BigEndian, this.AppID)
		if err != nil {
			return errors.New("TCaplusRouterInfo.AppID pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusRouterInfoZoneIDVersion {

		err = binary.Write(w, binary.BigEndian, this.ZoneID)
		if err != nil {
			return errors.New("TCaplusRouterInfo.ZoneID pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusRouterInfoShardIDVersion {

		err = binary.Write(w, binary.BigEndian, this.ShardID)
		if err != nil {
			return errors.New("TCaplusRouterInfo.ShardID pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.TableNameLen)
	if err != nil {
		return errors.New("TCaplusRouterInfo.TableNameLen pack error\n" + err.Error())
	}

	if this.TableNameLen < 0 {
		return errors.New("TCaplusRouterInfo.TableName's refer TableNameLen should >= 0")
	}
	if this.TableNameLen > 32 {
		return errors.New("TCaplusRouterInfo.TableName's refer TableNameLen should <= count 32")
	}
	if len(this.TableName) < int(this.TableNameLen) {
		return errors.New("TCaplusRouterInfo.TableName's length should > TableNameLen")
	}
	if this.TableNameLen > 0 {
		referTableName := this.TableName[:this.TableNameLen]
		err = binary.Write(w, binary.BigEndian, referTableName)
		if err != nil {
			return errors.New("TCaplusRouterInfo.TableName pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusRouterInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusRouterInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusRouterInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusRouterInfoCurrentVersion {
		cutVer = TCaplusRouterInfoCurrentVersion
	}
	// check version
	if cutVer < TCaplusRouterInfoBaseVersion {
		errors.New("TCaplusRouterInfo cut version must large than TCaplusRouterInfoBaseVersion\n")
	}

	if cutVer >= TCaplusRouterInfoAppIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.AppID)
		if err != nil {
			return errors.New("TCaplusRouterInfo.AppID unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusRouterInfoZoneIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.ZoneID)
		if err != nil {
			return errors.New("TCaplusRouterInfo.ZoneID unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusRouterInfoShardIDVersion {

		err = binary.Read(r, binary.BigEndian, &this.ShardID)
		if err != nil {
			return errors.New("TCaplusRouterInfo.ShardID unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.TableNameLen)
	if err != nil {
		return errors.New("TCaplusRouterInfo.TableNameLen unpack error\n" + err.Error())
	}

	if this.TableNameLen < 0 {
		return errors.New("TCaplusRouterInfo.TableName's refer TableNameLen should >= 0")
	}
	if this.TableNameLen > 32 {
		return errors.New("TCaplusRouterInfo.TableName's refer TableNameLen should <= count 32")
	}

	if this.TableName == nil {
		this.TableName = make([]byte, int(this.TableNameLen))
	}

	referTableName := this.TableName[:this.TableNameLen]
	err = binary.Read(r, binary.BigEndian, referTableName)
	if err != nil {
		return errors.New("TCaplusRouterInfo.TableName pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusDocumentOperationReqBaseVersion        uint32 = 40
	TCaplusDocumentOperationReqCurrentVersion     uint32 = 52
	TCaplusDocumentOperationReqSubCommandVersion  uint32 = 51
	TCaplusDocumentOperationReqPackVersionVersion uint32 = 52
)

// TCaplusDocumentOperationReq
type TCaplusDocumentOperationReq struct {
	SubCommand int32 `tdr_field:"SubCommand"`

	PackVersion int32 `tdr_field:"PackVersion"`

	ValueLen int32 `tdr_field:"ValueLen"`

	ValueInfo []byte `tdr_field:"ValueInfo" tdr_count:"10300000" tdr_refer:"ValueLen"`
}

func NewTCaplusDocumentOperationReq() *TCaplusDocumentOperationReq {
	obj := new(TCaplusDocumentOperationReq)
	obj.Init()
	return obj
}

func (this *TCaplusDocumentOperationReq) GetBaseVersion() uint32 {
	return TCaplusDocumentOperationReqBaseVersion
}

func (this *TCaplusDocumentOperationReq) GetCurrentVersion() uint32 {
	return TCaplusDocumentOperationReqCurrentVersion
}

func (this *TCaplusDocumentOperationReq) Init() {
	this.SubCommand = 0

	this.ValueLen = 0

}

func (this *TCaplusDocumentOperationReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusDocumentOperationReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusDocumentOperationReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusDocumentOperationReqCurrentVersion {
		cutVer = TCaplusDocumentOperationReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusDocumentOperationReqBaseVersion {
		return errors.New("TCaplusDocumentOperationReq cut version must large than TCaplusDocumentOperationReqBaseVersion\n")
	}

	var err error
	if cutVer >= TCaplusDocumentOperationReqSubCommandVersion {

		err = binary.Write(w, binary.BigEndian, this.SubCommand)
		if err != nil {
			return errors.New("TCaplusDocumentOperationReq.SubCommand pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusDocumentOperationReqPackVersionVersion {

		err = binary.Write(w, binary.BigEndian, this.PackVersion)
		if err != nil {
			return errors.New("TCaplusDocumentOperationReq.PackVersion pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.ValueLen)
	if err != nil {
		return errors.New("TCaplusDocumentOperationReq.ValueLen pack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusDocumentOperationReq.ValueInfo's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusDocumentOperationReq.ValueInfo's refer ValueLen should <= count 10300000")
	}
	if len(this.ValueInfo) < int(this.ValueLen) {
		return errors.New("TCaplusDocumentOperationReq.ValueInfo's length should > ValueLen")
	}
	if this.ValueLen > 0 {
		referValueInfo := this.ValueInfo[:this.ValueLen]
		err = binary.Write(w, binary.BigEndian, referValueInfo)
		if err != nil {
			return errors.New("TCaplusDocumentOperationReq.ValueInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusDocumentOperationReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusDocumentOperationReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusDocumentOperationReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusDocumentOperationReqCurrentVersion {
		cutVer = TCaplusDocumentOperationReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusDocumentOperationReqBaseVersion {
		errors.New("TCaplusDocumentOperationReq cut version must large than TCaplusDocumentOperationReqBaseVersion\n")
	}

	if cutVer >= TCaplusDocumentOperationReqSubCommandVersion {

		err = binary.Read(r, binary.BigEndian, &this.SubCommand)
		if err != nil {
			return errors.New("TCaplusDocumentOperationReq.SubCommand unpack error\n" + err.Error())
		}

	} else {
		this.SubCommand = 0

	}
	if cutVer >= TCaplusDocumentOperationReqPackVersionVersion {

		err = binary.Read(r, binary.BigEndian, &this.PackVersion)
		if err != nil {
			return errors.New("TCaplusDocumentOperationReq.PackVersion unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.ValueLen)
	if err != nil {
		return errors.New("TCaplusDocumentOperationReq.ValueLen unpack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusDocumentOperationReq.ValueInfo's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusDocumentOperationReq.ValueInfo's refer ValueLen should <= count 10300000")
	}

	if this.ValueInfo == nil {
		this.ValueInfo = make([]byte, int(this.ValueLen))
	}

	referValueInfo := this.ValueInfo[:this.ValueLen]
	err = binary.Read(r, binary.BigEndian, referValueInfo)
	if err != nil {
		return errors.New("TCaplusDocumentOperationReq.ValueInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusDocumentOperationResBaseVersion    uint32 = 40
	TCaplusDocumentOperationResCurrentVersion uint32 = 40
)

// TCaplusDocumentOperationRes
type TCaplusDocumentOperationRes struct {
	Result int32 `tdr_field:"Result"`

	ValueLen int32 `tdr_field:"ValueLen"`

	ValueInfo []byte `tdr_field:"ValueInfo" tdr_count:"10300000" tdr_refer:"ValueLen"`
}

func NewTCaplusDocumentOperationRes() *TCaplusDocumentOperationRes {
	obj := new(TCaplusDocumentOperationRes)
	obj.Init()
	return obj
}

func (this *TCaplusDocumentOperationRes) GetBaseVersion() uint32 {
	return TCaplusDocumentOperationResBaseVersion
}

func (this *TCaplusDocumentOperationRes) GetCurrentVersion() uint32 {
	return TCaplusDocumentOperationResCurrentVersion
}

func (this *TCaplusDocumentOperationRes) Init() {

	this.ValueLen = 0

}

func (this *TCaplusDocumentOperationRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusDocumentOperationRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusDocumentOperationRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusDocumentOperationResCurrentVersion {
		cutVer = TCaplusDocumentOperationResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusDocumentOperationResBaseVersion {
		return errors.New("TCaplusDocumentOperationRes cut version must large than TCaplusDocumentOperationResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusDocumentOperationRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ValueLen)
	if err != nil {
		return errors.New("TCaplusDocumentOperationRes.ValueLen pack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusDocumentOperationRes.ValueInfo's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusDocumentOperationRes.ValueInfo's refer ValueLen should <= count 10300000")
	}
	if len(this.ValueInfo) < int(this.ValueLen) {
		return errors.New("TCaplusDocumentOperationRes.ValueInfo's length should > ValueLen")
	}
	if this.ValueLen > 0 {
		referValueInfo := this.ValueInfo[:this.ValueLen]
		err = binary.Write(w, binary.BigEndian, referValueInfo)
		if err != nil {
			return errors.New("TCaplusDocumentOperationRes.ValueInfo pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusDocumentOperationRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusDocumentOperationRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusDocumentOperationRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusDocumentOperationResCurrentVersion {
		cutVer = TCaplusDocumentOperationResCurrentVersion
	}
	// check version
	if cutVer < TCaplusDocumentOperationResBaseVersion {
		errors.New("TCaplusDocumentOperationRes cut version must large than TCaplusDocumentOperationResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusDocumentOperationRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ValueLen)
	if err != nil {
		return errors.New("TCaplusDocumentOperationRes.ValueLen unpack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusDocumentOperationRes.ValueInfo's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusDocumentOperationRes.ValueInfo's refer ValueLen should <= count 10300000")
	}

	if this.ValueInfo == nil {
		this.ValueInfo = make([]byte, int(this.ValueLen))
	}

	referValueInfo := this.ValueInfo[:this.ValueLen]
	err = binary.Read(r, binary.BigEndian, referValueInfo)
	if err != nil {
		return errors.New("TCaplusDocumentOperationRes.ValueInfo pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetTableRecordCountReqBaseVersion    uint32 = 51
	TCaplusGetTableRecordCountReqCurrentVersion uint32 = 51
)

// TCaplusGetTableRecordCountReq
type TCaplusGetTableRecordCountReq struct {
	Reserve int32 `tdr_field:"Reserve"`
}

func NewTCaplusGetTableRecordCountReq() *TCaplusGetTableRecordCountReq {
	obj := new(TCaplusGetTableRecordCountReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetTableRecordCountReq) GetBaseVersion() uint32 {
	return TCaplusGetTableRecordCountReqBaseVersion
}

func (this *TCaplusGetTableRecordCountReq) GetCurrentVersion() uint32 {
	return TCaplusGetTableRecordCountReqCurrentVersion
}

func (this *TCaplusGetTableRecordCountReq) Init() {

}

func (this *TCaplusGetTableRecordCountReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetTableRecordCountReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetTableRecordCountReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetTableRecordCountReqCurrentVersion {
		cutVer = TCaplusGetTableRecordCountReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetTableRecordCountReqBaseVersion {
		return errors.New("TCaplusGetTableRecordCountReq cut version must large than TCaplusGetTableRecordCountReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Reserve)
	if err != nil {
		return errors.New("TCaplusGetTableRecordCountReq.Reserve pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetTableRecordCountReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetTableRecordCountReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetTableRecordCountReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetTableRecordCountReqCurrentVersion {
		cutVer = TCaplusGetTableRecordCountReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetTableRecordCountReqBaseVersion {
		errors.New("TCaplusGetTableRecordCountReq cut version must large than TCaplusGetTableRecordCountReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Reserve)
	if err != nil {
		return errors.New("TCaplusGetTableRecordCountReq.Reserve unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetTableRecordCountResBaseVersion                 uint32 = 51
	TCaplusGetTableRecordCountResCurrentVersion              uint32 = 53
	TCaplusGetTableRecordCountResShardCountVersion           uint32 = 53
	TCaplusGetTableRecordCountResShardListVersion            uint32 = 53
	TCaplusGetTableRecordCountResShardRecordCountListVersion uint32 = 53
)

// TCaplusGetTableRecordCountRes
type TCaplusGetTableRecordCountRes struct {
	Result int32 `tdr_field:"Result"`

	Count int64 `tdr_field:"Count"`

	ShardCount int32 `tdr_field:"ShardCount"`

	ShardList []int32 `tdr_field:"ShardList" tdr_count:"512" tdr_refer:"ShardCount"`

	ShardRecordCountList []int32 `tdr_field:"ShardRecordCountList" tdr_count:"512" tdr_refer:"ShardCount"`
}

func NewTCaplusGetTableRecordCountRes() *TCaplusGetTableRecordCountRes {
	obj := new(TCaplusGetTableRecordCountRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetTableRecordCountRes) GetBaseVersion() uint32 {
	return TCaplusGetTableRecordCountResBaseVersion
}

func (this *TCaplusGetTableRecordCountRes) GetCurrentVersion() uint32 {
	return TCaplusGetTableRecordCountResCurrentVersion
}

func (this *TCaplusGetTableRecordCountRes) Init() {

	this.ShardCount = 0

}

func (this *TCaplusGetTableRecordCountRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetTableRecordCountRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetTableRecordCountRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetTableRecordCountResCurrentVersion {
		cutVer = TCaplusGetTableRecordCountResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetTableRecordCountResBaseVersion {
		return errors.New("TCaplusGetTableRecordCountRes cut version must large than TCaplusGetTableRecordCountResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusGetTableRecordCountRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Count)
	if err != nil {
		return errors.New("TCaplusGetTableRecordCountRes.Count pack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetTableRecordCountResShardCountVersion {

		err = binary.Write(w, binary.BigEndian, this.ShardCount)
		if err != nil {
			return errors.New("TCaplusGetTableRecordCountRes.ShardCount pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusGetTableRecordCountResShardListVersion {

		if this.ShardCount < 0 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardList's refer ShardCount should >= 0")
		}
		if this.ShardCount > 512 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardList's refer ShardCount should <= count 512")
		}
		if len(this.ShardList) < int(this.ShardCount) {
			return errors.New("TCaplusGetTableRecordCountRes.ShardList's length should > ShardCount")
		}
		if this.ShardCount > 0 {
			referShardList := this.ShardList[:this.ShardCount]
			err = binary.Write(w, binary.BigEndian, referShardList)
			if err != nil {
				return errors.New("TCaplusGetTableRecordCountRes.ShardList pack error\n" + err.Error())
			}
		}

	}
	if cutVer >= TCaplusGetTableRecordCountResShardRecordCountListVersion {

		if this.ShardCount < 0 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList's refer ShardCount should >= 0")
		}
		if this.ShardCount > 512 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList's refer ShardCount should <= count 512")
		}
		if len(this.ShardRecordCountList) < int(this.ShardCount) {
			return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList's length should > ShardCount")
		}
		if this.ShardCount > 0 {
			referShardRecordCountList := this.ShardRecordCountList[:this.ShardCount]
			err = binary.Write(w, binary.BigEndian, referShardRecordCountList)
			if err != nil {
				return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList pack error\n" + err.Error())
			}
		}

	}

	return nil
}

func (this *TCaplusGetTableRecordCountRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetTableRecordCountRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetTableRecordCountRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetTableRecordCountResCurrentVersion {
		cutVer = TCaplusGetTableRecordCountResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetTableRecordCountResBaseVersion {
		errors.New("TCaplusGetTableRecordCountRes cut version must large than TCaplusGetTableRecordCountResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusGetTableRecordCountRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Count)
	if err != nil {
		return errors.New("TCaplusGetTableRecordCountRes.Count unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusGetTableRecordCountResShardCountVersion {

		err = binary.Read(r, binary.BigEndian, &this.ShardCount)
		if err != nil {
			return errors.New("TCaplusGetTableRecordCountRes.ShardCount unpack error\n" + err.Error())
		}

	} else {
		this.ShardCount = 0

	}
	if cutVer >= TCaplusGetTableRecordCountResShardListVersion {

		if this.ShardCount < 0 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardList's refer ShardCount should >= 0")
		}
		if this.ShardCount > 512 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardList's refer ShardCount should <= count 512")
		}

		if this.ShardList == nil {
			this.ShardList = make([]int32, int(this.ShardCount))
		}

		referShardList := this.ShardList[:this.ShardCount]
		err = binary.Read(r, binary.BigEndian, referShardList)
		if err != nil {
			return errors.New("TCaplusGetTableRecordCountRes.ShardList pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusGetTableRecordCountResShardRecordCountListVersion {

		if this.ShardCount < 0 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList's refer ShardCount should >= 0")
		}
		if this.ShardCount > 512 {
			return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList's refer ShardCount should <= count 512")
		}

		if this.ShardRecordCountList == nil {
			this.ShardRecordCountList = make([]int32, int(this.ShardCount))
		}

		referShardRecordCountList := this.ShardRecordCountList[:this.ShardCount]
		err = binary.Read(r, binary.BigEndian, referShardRecordCountList)
		if err != nil {
			return errors.New("TCaplusGetTableRecordCountRes.ShardRecordCountList pack error\n" + err.Error())
		}

	}
	return err
}

const (
	TCaplusHttpGenericReqBaseVersion    uint32 = 54
	TCaplusHttpGenericReqCurrentVersion uint32 = 54
)

// TCaplusHttpGenericReq
type TCaplusHttpGenericReq struct {
	Version string `tdr_field:"Version"`

	Target string `tdr_field:"Target"`

	ValueLen int32 `tdr_field:"ValueLen"`

	Value []byte `tdr_field:"Value" tdr_count:"10300000" tdr_refer:"ValueLen"`
}

func NewTCaplusHttpGenericReq() *TCaplusHttpGenericReq {
	obj := new(TCaplusHttpGenericReq)
	obj.Init()
	return obj
}

func (this *TCaplusHttpGenericReq) GetBaseVersion() uint32 {
	return TCaplusHttpGenericReqBaseVersion
}

func (this *TCaplusHttpGenericReq) GetCurrentVersion() uint32 {
	return TCaplusHttpGenericReqCurrentVersion
}

func (this *TCaplusHttpGenericReq) Init() {

	this.ValueLen = 0

}

func (this *TCaplusHttpGenericReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusHttpGenericReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusHttpGenericReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusHttpGenericReqCurrentVersion {
		cutVer = TCaplusHttpGenericReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusHttpGenericReqBaseVersion {
		return errors.New("TCaplusHttpGenericReq cut version must large than TCaplusHttpGenericReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Version))+1)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Version string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Version), 0))
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Version string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Target))+1)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Target string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Target), 0))
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Target string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ValueLen)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.ValueLen pack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusHttpGenericReq.Value's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusHttpGenericReq.Value's refer ValueLen should <= count 10300000")
	}
	if len(this.Value) < int(this.ValueLen) {
		return errors.New("TCaplusHttpGenericReq.Value's length should > ValueLen")
	}
	if this.ValueLen > 0 {
		referValue := this.Value[:this.ValueLen]
		err = binary.Write(w, binary.BigEndian, referValue)
		if err != nil {
			return errors.New("TCaplusHttpGenericReq.Value pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusHttpGenericReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusHttpGenericReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusHttpGenericReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusHttpGenericReqCurrentVersion {
		cutVer = TCaplusHttpGenericReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusHttpGenericReqBaseVersion {
		errors.New("TCaplusHttpGenericReq cut version must large than TCaplusHttpGenericReqBaseVersion\n")
	}

	var VersionSize uint32
	err = binary.Read(r, binary.BigEndian, &VersionSize)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Version string size unpack error\n" + err.Error())
	}

	VersionBytes := make([]byte, VersionSize)
	err = binary.Read(r, binary.BigEndian, VersionBytes)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Version string content unpack error\n" + err.Error())
	}
	this.Version = string(VersionBytes[:len(VersionBytes)-1])

	var TargetSize uint32
	err = binary.Read(r, binary.BigEndian, &TargetSize)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Target string size unpack error\n" + err.Error())
	}

	TargetBytes := make([]byte, TargetSize)
	err = binary.Read(r, binary.BigEndian, TargetBytes)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Target string content unpack error\n" + err.Error())
	}
	this.Target = string(TargetBytes[:len(TargetBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.ValueLen)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.ValueLen unpack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusHttpGenericReq.Value's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusHttpGenericReq.Value's refer ValueLen should <= count 10300000")
	}

	if this.Value == nil {
		this.Value = make([]byte, int(this.ValueLen))
	}

	referValue := this.Value[:this.ValueLen]
	err = binary.Read(r, binary.BigEndian, referValue)
	if err != nil {
		return errors.New("TCaplusHttpGenericReq.Value pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusHttpGenericResBaseVersion    uint32 = 54
	TCaplusHttpGenericResCurrentVersion uint32 = 54
)

// TCaplusHttpGenericRes
type TCaplusHttpGenericRes struct {
	Version string `tdr_field:"Version"`

	Target string `tdr_field:"Target"`

	Result int32 `tdr_field:"Result"`

	ValueLen int32 `tdr_field:"ValueLen"`

	Value []byte `tdr_field:"Value" tdr_count:"10300000" tdr_refer:"ValueLen"`
}

func NewTCaplusHttpGenericRes() *TCaplusHttpGenericRes {
	obj := new(TCaplusHttpGenericRes)
	obj.Init()
	return obj
}

func (this *TCaplusHttpGenericRes) GetBaseVersion() uint32 {
	return TCaplusHttpGenericResBaseVersion
}

func (this *TCaplusHttpGenericRes) GetCurrentVersion() uint32 {
	return TCaplusHttpGenericResCurrentVersion
}

func (this *TCaplusHttpGenericRes) Init() {

	this.ValueLen = 0

}

func (this *TCaplusHttpGenericRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusHttpGenericRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusHttpGenericRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusHttpGenericResCurrentVersion {
		cutVer = TCaplusHttpGenericResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusHttpGenericResBaseVersion {
		return errors.New("TCaplusHttpGenericRes cut version must large than TCaplusHttpGenericResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Version))+1)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Version string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Version), 0))
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Version string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Target))+1)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Target string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Target), 0))
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Target string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ValueLen)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.ValueLen pack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusHttpGenericRes.Value's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusHttpGenericRes.Value's refer ValueLen should <= count 10300000")
	}
	if len(this.Value) < int(this.ValueLen) {
		return errors.New("TCaplusHttpGenericRes.Value's length should > ValueLen")
	}
	if this.ValueLen > 0 {
		referValue := this.Value[:this.ValueLen]
		err = binary.Write(w, binary.BigEndian, referValue)
		if err != nil {
			return errors.New("TCaplusHttpGenericRes.Value pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusHttpGenericRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusHttpGenericRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusHttpGenericRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusHttpGenericResCurrentVersion {
		cutVer = TCaplusHttpGenericResCurrentVersion
	}
	// check version
	if cutVer < TCaplusHttpGenericResBaseVersion {
		errors.New("TCaplusHttpGenericRes cut version must large than TCaplusHttpGenericResBaseVersion\n")
	}

	var VersionSize uint32
	err = binary.Read(r, binary.BigEndian, &VersionSize)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Version string size unpack error\n" + err.Error())
	}

	VersionBytes := make([]byte, VersionSize)
	err = binary.Read(r, binary.BigEndian, VersionBytes)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Version string content unpack error\n" + err.Error())
	}
	this.Version = string(VersionBytes[:len(VersionBytes)-1])

	var TargetSize uint32
	err = binary.Read(r, binary.BigEndian, &TargetSize)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Target string size unpack error\n" + err.Error())
	}

	TargetBytes := make([]byte, TargetSize)
	err = binary.Read(r, binary.BigEndian, TargetBytes)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Target string content unpack error\n" + err.Error())
	}
	this.Target = string(TargetBytes[:len(TargetBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ValueLen)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.ValueLen unpack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusHttpGenericRes.Value's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusHttpGenericRes.Value's refer ValueLen should <= count 10300000")
	}

	if this.Value == nil {
		this.Value = make([]byte, int(this.ValueLen))
	}

	referValue := this.Value[:this.ValueLen]
	err = binary.Read(r, binary.BigEndian, referValue)
	if err != nil {
		return errors.New("TCaplusHttpGenericRes.Value pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetDuringMoveReqBaseVersion    uint32 = 57
	TCaplusGetDuringMoveReqCurrentVersion uint32 = 109
)

// TCaplusGetDuringMoveReq
type TCaplusGetDuringMoveReq struct {
	GetReq *TCaplusGetReq `tdr_field:"GetReq"`

	SrcShardID int32 `tdr_field:"SrcShardID"`

	GetFlag int32 `tdr_field:"GetFlag"`
}

func NewTCaplusGetDuringMoveReq() *TCaplusGetDuringMoveReq {
	obj := new(TCaplusGetDuringMoveReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetDuringMoveReq) GetBaseVersion() uint32 {
	return TCaplusGetDuringMoveReqBaseVersion
}

func (this *TCaplusGetDuringMoveReq) GetCurrentVersion() uint32 {
	return TCaplusGetDuringMoveReqCurrentVersion
}

func (this *TCaplusGetDuringMoveReq) Init() {
	this.GetReq = NewTCaplusGetReq()

	this.GetFlag = 0x00

}

func (this *TCaplusGetDuringMoveReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetDuringMoveReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetDuringMoveReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveReqCurrentVersion {
		cutVer = TCaplusGetDuringMoveReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetDuringMoveReqBaseVersion {
		return errors.New("TCaplusGetDuringMoveReq cut version must large than TCaplusGetDuringMoveReqBaseVersion\n")
	}

	var err error

	err = this.GetReq.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveReq.GetReq pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveReq.SrcShardID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.GetFlag)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveReq.GetFlag pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetDuringMoveReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetDuringMoveReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetDuringMoveReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveReqCurrentVersion {
		cutVer = TCaplusGetDuringMoveReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetDuringMoveReqBaseVersion {
		errors.New("TCaplusGetDuringMoveReq cut version must large than TCaplusGetDuringMoveReqBaseVersion\n")
	}

	err = this.GetReq.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveReq.GetReq unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SrcShardID)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveReq.SrcShardID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.GetFlag)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveReq.GetFlag unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetDuringMoveResBaseVersion    uint32 = 57
	TCaplusGetDuringMoveResCurrentVersion uint32 = 109
)

// TCaplusGetDuringMoveRes
type TCaplusGetDuringMoveRes struct {
	GetRes *TCaplusGetRes `tdr_field:"GetRes"`
}

func NewTCaplusGetDuringMoveRes() *TCaplusGetDuringMoveRes {
	obj := new(TCaplusGetDuringMoveRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetDuringMoveRes) GetBaseVersion() uint32 {
	return TCaplusGetDuringMoveResBaseVersion
}

func (this *TCaplusGetDuringMoveRes) GetCurrentVersion() uint32 {
	return TCaplusGetDuringMoveResCurrentVersion
}

func (this *TCaplusGetDuringMoveRes) Init() {
	this.GetRes = NewTCaplusGetRes()

}

func (this *TCaplusGetDuringMoveRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetDuringMoveRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetDuringMoveRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveResCurrentVersion {
		cutVer = TCaplusGetDuringMoveResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetDuringMoveResBaseVersion {
		return errors.New("TCaplusGetDuringMoveRes cut version must large than TCaplusGetDuringMoveResBaseVersion\n")
	}

	var err error

	err = this.GetRes.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveRes.GetRes pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetDuringMoveRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetDuringMoveRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetDuringMoveRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveResCurrentVersion {
		cutVer = TCaplusGetDuringMoveResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetDuringMoveResBaseVersion {
		errors.New("TCaplusGetDuringMoveRes cut version must large than TCaplusGetDuringMoveResBaseVersion\n")
	}

	err = this.GetRes.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveRes.GetRes unpack error\n" + err.Error())
	}

	return err
}

const (
	ProxyHeadForReqSendToSvrBaseVersion    uint32 = 58
	ProxyHeadForReqSendToSvrCurrentVersion uint32 = 58
)

// ProxyHeadForReqSendToSvr
type ProxyHeadForReqSendToSvr struct {
	Version uint32 `tdr_field:"Version"`

	Token uint64 `tdr_field:"Token"`

	ShardID int32 `tdr_field:"ShardID"`

	SendTime uint64 `tdr_field:"SendTime"`

	HashCode uint64 `tdr_field:"HashCode"`
}

func NewProxyHeadForReqSendToSvr() *ProxyHeadForReqSendToSvr {
	obj := new(ProxyHeadForReqSendToSvr)
	obj.Init()
	return obj
}

func (this *ProxyHeadForReqSendToSvr) GetBaseVersion() uint32 {
	return ProxyHeadForReqSendToSvrBaseVersion
}

func (this *ProxyHeadForReqSendToSvr) GetCurrentVersion() uint32 {
	return ProxyHeadForReqSendToSvrCurrentVersion
}

func (this *ProxyHeadForReqSendToSvr) Init() {
	this.Version = 0

	this.Token = 0

	this.ShardID = 0

	this.SendTime = 0

	this.HashCode = 0

}

func (this *ProxyHeadForReqSendToSvr) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ProxyHeadForReqSendToSvr Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ProxyHeadForReqSendToSvr) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ProxyHeadForReqSendToSvrCurrentVersion {
		cutVer = ProxyHeadForReqSendToSvrCurrentVersion
	}
	// check cut version
	if cutVer < ProxyHeadForReqSendToSvrBaseVersion {
		return errors.New("ProxyHeadForReqSendToSvr cut version must large than ProxyHeadForReqSendToSvrBaseVersion\n")
	}
	// versionindicator
	this.Version = uint32(cutVer)

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Token)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.Token pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ShardID)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.ShardID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SendTime)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.SendTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.HashCode)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.HashCode pack error\n" + err.Error())
	}

	return nil
}

func (this *ProxyHeadForReqSendToSvr) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ProxyHeadForReqSendToSvr data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ProxyHeadForReqSendToSvr) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// get net version
	var netVer uint32
	oriPos := r.Tell()
	r.Seek(oriPos+0, io.SeekStart)
	err = binary.Read(r, binary.BigEndian, &netVer)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr get net version error\n" + err.Error())
	}
	r.Seek(oriPos, io.SeekStart)
	cutVer = uint32(netVer)
	// check version
	if cutVer < ProxyHeadForReqSendToSvrBaseVersion || cutVer > ProxyHeadForReqSendToSvrCurrentVersion {
		return errors.New("ProxyHeadForReqSendToSvr wrong cut version")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Token)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.Token unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ShardID)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.ShardID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SendTime)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.SendTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.HashCode)
	if err != nil {
		return errors.New("ProxyHeadForReqSendToSvr.HashCode unpack error\n" + err.Error())
	}

	return err
}

const (
	PerfTestBaseVersion                 uint32 = 79
	PerfTestCurrentVersion              uint32 = 108
	PerfTestSvrTbusppForwardTimeVersion uint32 = 108
)

// PerfTest
type PerfTest struct {
	Version uint32 `tdr_field:"version"`

	ApiSendTime uint64 `tdr_field:"ApiSendTime"`

	ProxyFrontForwardTime uint64 `tdr_field:"ProxyFrontForwardTime"`

	ProxyEndForwardTime uint64 `tdr_field:"ProxyEndForwardTime"`

	SvrTbusppForwardTime uint64 `tdr_field:"SvrTbusppForwardTime"`

	SvrMainForwardTime uint64 `tdr_field:"SvrMainForwardTime"`

	SvrWorkerRecvTime uint64 `tdr_field:"SvrWorkerRecvTime"`

	SvrWorkerSendTime uint64 `tdr_field:"SvrWorkerSendTime"`

	ProxyFrontBackwardTime uint64 `tdr_field:"ProxyFrontBackwardTime"`

	ProxyEndBackwardTime uint64 `tdr_field:"ProxyEndBackwardTime"`

	ApiRecvTime uint64 `tdr_field:"ApiRecvTime"`
}

func NewPerfTest() *PerfTest {
	obj := new(PerfTest)
	obj.Init()
	return obj
}

func (this *PerfTest) GetBaseVersion() uint32 {
	return PerfTestBaseVersion
}

func (this *PerfTest) GetCurrentVersion() uint32 {
	return PerfTestCurrentVersion
}

func (this *PerfTest) Init() {

}

func (this *PerfTest) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("PerfTest Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *PerfTest) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > PerfTestCurrentVersion {
		cutVer = PerfTestCurrentVersion
	}
	// check cut version
	if cutVer < PerfTestBaseVersion {
		return errors.New("PerfTest cut version must large than PerfTestBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("PerfTest.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ApiSendTime)
	if err != nil {
		return errors.New("PerfTest.ApiSendTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ProxyFrontForwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyFrontForwardTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ProxyEndForwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyEndForwardTime pack error\n" + err.Error())
	}

	if cutVer >= PerfTestSvrTbusppForwardTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.SvrTbusppForwardTime)
		if err != nil {
			return errors.New("PerfTest.SvrTbusppForwardTime pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.SvrMainForwardTime)
	if err != nil {
		return errors.New("PerfTest.SvrMainForwardTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SvrWorkerRecvTime)
	if err != nil {
		return errors.New("PerfTest.SvrWorkerRecvTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SvrWorkerSendTime)
	if err != nil {
		return errors.New("PerfTest.SvrWorkerSendTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ProxyFrontBackwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyFrontBackwardTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ProxyEndBackwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyEndBackwardTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ApiRecvTime)
	if err != nil {
		return errors.New("PerfTest.ApiRecvTime pack error\n" + err.Error())
	}

	return nil
}

func (this *PerfTest) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("PerfTest data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *PerfTest) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > PerfTestCurrentVersion {
		cutVer = PerfTestCurrentVersion
	}
	// check version
	if cutVer < PerfTestBaseVersion {
		errors.New("PerfTest cut version must large than PerfTestBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("PerfTest.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ApiSendTime)
	if err != nil {
		return errors.New("PerfTest.ApiSendTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ProxyFrontForwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyFrontForwardTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ProxyEndForwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyEndForwardTime unpack error\n" + err.Error())
	}

	if cutVer >= PerfTestSvrTbusppForwardTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.SvrTbusppForwardTime)
		if err != nil {
			return errors.New("PerfTest.SvrTbusppForwardTime unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.SvrMainForwardTime)
	if err != nil {
		return errors.New("PerfTest.SvrMainForwardTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SvrWorkerRecvTime)
	if err != nil {
		return errors.New("PerfTest.SvrWorkerRecvTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SvrWorkerSendTime)
	if err != nil {
		return errors.New("PerfTest.SvrWorkerSendTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ProxyFrontBackwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyFrontBackwardTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ProxyEndBackwardTime)
	if err != nil {
		return errors.New("PerfTest.ProxyEndBackwardTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ApiRecvTime)
	if err != nil {
		return errors.New("PerfTest.ApiRecvTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusPkgHeadBaseVersion                 uint32 = 1
	TCaplusPkgHeadCurrentVersion              uint32 = 91
	TCaplusPkgHeadSubCmdVersion               uint32 = 54
	TCaplusPkgHeadFlagsVersion                uint32 = 16
	TCaplusPkgHeadPerfTestLenVersion          uint32 = 79
	TCaplusPkgHeadPerfTestVersion             uint32 = 79
	TCaplusPkgHeadTdrMetaVersionVersion       uint32 = 5
	TCaplusPkgHeadReqBodyCompressTypeVersion  uint32 = 20
	TCaplusPkgHeadRespBodyCompressTypeVersion uint32 = 20
	TCaplusPkgHeadResultVersion               uint32 = 37
	TCaplusPkgHeadSplitTableKeyBuffLenVersion uint32 = 91
	TCaplusPkgHeadSplitTableKeyBuffVersion    uint32 = 91
)

// TCaplusPkgHead
type TCaplusPkgHead struct {
	Magic uint16 `tdr_field:"Magic"`

	Version uint16 `tdr_field:"Version"`

	HeadLen uint32 `tdr_field:"HeadLen"`

	BodyLen uint32 `tdr_field:"BodyLen"`

	AsynID uint64 `tdr_field:"AsynID"`

	Seq int32 `tdr_field:"Seq"`

	Cmd uint32 `tdr_field:"Cmd"`

	SubCmd uint32 `tdr_field:"SubCmd"`

	Flags int32 `tdr_field:"Flags"`

	RouterInfo *TCaplusRouterInfo `tdr_field:"RouterInfo"`

	UserBuffLen uint32 `tdr_field:"UserBuffLen"`

	UserBuff []byte `tdr_field:"UserBuff" tdr_count:"1024" tdr_refer:"UserBuffLen"`

	PerfTestLen uint32 `tdr_field:"PerfTestLen"`

	PerfTest []byte `tdr_field:"PerfTest" tdr_count:"256" tdr_refer:"PerfTestLen"`

	KeyInfo *TCaplusKeySet `tdr_field:"KeyInfo"`

	TdrMetaVersion int32 `tdr_field:"TdrMetaVersion"`

	ReqBodyCompressType byte `tdr_field:"ReqBodyCompressType"`

	RespBodyCompressType byte `tdr_field:"RespBodyCompressType"`

	Result int32 `tdr_field:"Result"`

	SplitTableKeyBuffLen uint32 `tdr_field:"SplitTableKeyBuffLen"`

	SplitTableKeyBuff []byte `tdr_field:"SplitTableKeyBuff" tdr_count:"1024" tdr_refer:"SplitTableKeyBuffLen"`
}

func NewTCaplusPkgHead() *TCaplusPkgHead {
	obj := new(TCaplusPkgHead)
	obj.Init()
	return obj
}

func (this *TCaplusPkgHead) GetBaseVersion() uint32 {
	return TCaplusPkgHeadBaseVersion
}

func (this *TCaplusPkgHead) GetCurrentVersion() uint32 {
	return TCaplusPkgHeadCurrentVersion
}

func (this *TCaplusPkgHead) Init() {
	this.Magic = 0x7543

	this.SubCmd = 0

	this.Flags = 0

	this.RouterInfo = NewTCaplusRouterInfo()

	this.UserBuffLen = 0

	this.PerfTestLen = 0

	this.KeyInfo = NewTCaplusKeySet()

	this.ReqBodyCompressType = 0

	this.RespBodyCompressType = 0

	this.Result = 0

	this.SplitTableKeyBuffLen = 0

}

func (this *TCaplusPkgHead) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusPkgHead Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusPkgHead) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusPkgHeadCurrentVersion {
		cutVer = TCaplusPkgHeadCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusPkgHeadBaseVersion {
		return errors.New("TCaplusPkgHead cut version must large than TCaplusPkgHeadBaseVersion\n")
	}

	beginPos := w.Tell()

	var err error

	err = binary.Write(w, binary.BigEndian, this.Magic)
	if err != nil {
		return errors.New("TCaplusPkgHead.Magic pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusPkgHead.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.HeadLen)
	if err != nil {
		return errors.New("TCaplusPkgHead.HeadLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BodyLen)
	if err != nil {
		return errors.New("TCaplusPkgHead.BodyLen pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.AsynID)
	if err != nil {
		return errors.New("TCaplusPkgHead.AsynID pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Seq)
	if err != nil {
		return errors.New("TCaplusPkgHead.Seq pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Cmd)
	if err != nil {
		return errors.New("TCaplusPkgHead.Cmd pack error\n" + err.Error())
	}

	if cutVer >= TCaplusPkgHeadSubCmdVersion {

		err = binary.Write(w, binary.BigEndian, this.SubCmd)
		if err != nil {
			return errors.New("TCaplusPkgHead.SubCmd pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadFlagsVersion {

		err = binary.Write(w, binary.BigEndian, this.Flags)
		if err != nil {
			return errors.New("TCaplusPkgHead.Flags pack error\n" + err.Error())
		}

	}

	err = this.RouterInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusPkgHead.RouterInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.UserBuffLen)
	if err != nil {
		return errors.New("TCaplusPkgHead.UserBuffLen pack error\n" + err.Error())
	}

	if this.UserBuffLen < 0 {
		return errors.New("TCaplusPkgHead.UserBuff's refer UserBuffLen should >= 0")
	}
	if this.UserBuffLen > 1024 {
		return errors.New("TCaplusPkgHead.UserBuff's refer UserBuffLen should <= count 1024")
	}
	if len(this.UserBuff) < int(this.UserBuffLen) {
		return errors.New("TCaplusPkgHead.UserBuff's length should > UserBuffLen")
	}
	if this.UserBuffLen > 0 {
		referUserBuff := this.UserBuff[:this.UserBuffLen]
		err = binary.Write(w, binary.BigEndian, referUserBuff)
		if err != nil {
			return errors.New("TCaplusPkgHead.UserBuff pack error\n" + err.Error())
		}
	}

	if cutVer >= TCaplusPkgHeadPerfTestLenVersion {

		err = binary.Write(w, binary.BigEndian, this.PerfTestLen)
		if err != nil {
			return errors.New("TCaplusPkgHead.PerfTestLen pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadPerfTestVersion {

		if this.PerfTestLen < 0 {
			return errors.New("TCaplusPkgHead.PerfTest's refer PerfTestLen should >= 0")
		}
		if this.PerfTestLen > 256 {
			return errors.New("TCaplusPkgHead.PerfTest's refer PerfTestLen should <= count 256")
		}
		if len(this.PerfTest) < int(this.PerfTestLen) {
			return errors.New("TCaplusPkgHead.PerfTest's length should > PerfTestLen")
		}
		if this.PerfTestLen > 0 {
			referPerfTest := this.PerfTest[:this.PerfTestLen]
			err = binary.Write(w, binary.BigEndian, referPerfTest)
			if err != nil {
				return errors.New("TCaplusPkgHead.PerfTest pack error\n" + err.Error())
			}
		}

	}

	err = this.KeyInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusPkgHead.KeyInfo pack error\n" + err.Error())
	}

	if cutVer >= TCaplusPkgHeadTdrMetaVersionVersion {

		err = binary.Write(w, binary.BigEndian, this.TdrMetaVersion)
		if err != nil {
			return errors.New("TCaplusPkgHead.TdrMetaVersion pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadReqBodyCompressTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.ReqBodyCompressType)
		if err != nil {
			return errors.New("TCaplusPkgHead.ReqBodyCompressType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadRespBodyCompressTypeVersion {

		err = binary.Write(w, binary.BigEndian, this.RespBodyCompressType)
		if err != nil {
			return errors.New("TCaplusPkgHead.RespBodyCompressType pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadResultVersion {

		err = binary.Write(w, binary.BigEndian, this.Result)
		if err != nil {
			return errors.New("TCaplusPkgHead.Result pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadSplitTableKeyBuffLenVersion {

		err = binary.Write(w, binary.BigEndian, this.SplitTableKeyBuffLen)
		if err != nil {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuffLen pack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadSplitTableKeyBuffVersion {

		if this.SplitTableKeyBuffLen < 0 {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuff's refer SplitTableKeyBuffLen should >= 0")
		}
		if this.SplitTableKeyBuffLen > 1024 {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuff's refer SplitTableKeyBuffLen should <= count 1024")
		}
		if len(this.SplitTableKeyBuff) < int(this.SplitTableKeyBuffLen) {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuff's length should > SplitTableKeyBuffLen")
		}
		if this.SplitTableKeyBuffLen > 0 {
			referSplitTableKeyBuff := this.SplitTableKeyBuff[:this.SplitTableKeyBuffLen]
			err = binary.Write(w, binary.BigEndian, referSplitTableKeyBuff)
			if err != nil {
				return errors.New("TCaplusPkgHead.SplitTableKeyBuff pack error\n" + err.Error())
			}
		}

	}

	// sizeinfo
	endPos := w.Tell()
	w.Seek(beginPos+4, io.SeekStart)
	err = binary.Write(w, binary.BigEndian, uint32(endPos-beginPos))
	if err != nil {
		return errors.New("TCaplusPkgHead's sizeinfo HeadLen pack error\n" + err.Error())
	}
	w.Seek(endPos, io.SeekStart)

	return nil
}

func (this *TCaplusPkgHead) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusPkgHead data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusPkgHead) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusPkgHeadCurrentVersion {
		cutVer = TCaplusPkgHeadCurrentVersion
	}
	// check version
	if cutVer < TCaplusPkgHeadBaseVersion {
		errors.New("TCaplusPkgHead cut version must large than TCaplusPkgHeadBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Magic)
	if err != nil {
		return errors.New("TCaplusPkgHead.Magic unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusPkgHead.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.HeadLen)
	if err != nil {
		return errors.New("TCaplusPkgHead.HeadLen unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BodyLen)
	if err != nil {
		return errors.New("TCaplusPkgHead.BodyLen unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.AsynID)
	if err != nil {
		return errors.New("TCaplusPkgHead.AsynID unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Seq)
	if err != nil {
		return errors.New("TCaplusPkgHead.Seq unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Cmd)
	if err != nil {
		return errors.New("TCaplusPkgHead.Cmd unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusPkgHeadSubCmdVersion {

		err = binary.Read(r, binary.BigEndian, &this.SubCmd)
		if err != nil {
			return errors.New("TCaplusPkgHead.SubCmd unpack error\n" + err.Error())
		}

	} else {
		this.SubCmd = 0

	}
	if cutVer >= TCaplusPkgHeadFlagsVersion {

		err = binary.Read(r, binary.BigEndian, &this.Flags)
		if err != nil {
			return errors.New("TCaplusPkgHead.Flags unpack error\n" + err.Error())
		}

	} else {
		this.Flags = 0

	}

	err = this.RouterInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusPkgHead.RouterInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.UserBuffLen)
	if err != nil {
		return errors.New("TCaplusPkgHead.UserBuffLen unpack error\n" + err.Error())
	}

	if this.UserBuffLen < 0 {
		return errors.New("TCaplusPkgHead.UserBuff's refer UserBuffLen should >= 0")
	}
	if this.UserBuffLen > 1024 {
		return errors.New("TCaplusPkgHead.UserBuff's refer UserBuffLen should <= count 1024")
	}

	if this.UserBuff == nil {
		this.UserBuff = make([]byte, int(this.UserBuffLen))
	}

	referUserBuff := this.UserBuff[:this.UserBuffLen]
	err = binary.Read(r, binary.BigEndian, referUserBuff)
	if err != nil {
		return errors.New("TCaplusPkgHead.UserBuff pack error\n" + err.Error())
	}

	if cutVer >= TCaplusPkgHeadPerfTestLenVersion {

		err = binary.Read(r, binary.BigEndian, &this.PerfTestLen)
		if err != nil {
			return errors.New("TCaplusPkgHead.PerfTestLen unpack error\n" + err.Error())
		}

	} else {
		this.PerfTestLen = 0

	}
	if cutVer >= TCaplusPkgHeadPerfTestVersion {

		if this.PerfTestLen < 0 {
			return errors.New("TCaplusPkgHead.PerfTest's refer PerfTestLen should >= 0")
		}
		if this.PerfTestLen > 256 {
			return errors.New("TCaplusPkgHead.PerfTest's refer PerfTestLen should <= count 256")
		}

		if this.PerfTest == nil {
			this.PerfTest = make([]byte, int(this.PerfTestLen))
		}

		referPerfTest := this.PerfTest[:this.PerfTestLen]
		err = binary.Read(r, binary.BigEndian, referPerfTest)
		if err != nil {
			return errors.New("TCaplusPkgHead.PerfTest pack error\n" + err.Error())
		}

	}

	err = this.KeyInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusPkgHead.KeyInfo unpack error\n" + err.Error())
	}

	if cutVer >= TCaplusPkgHeadTdrMetaVersionVersion {

		err = binary.Read(r, binary.BigEndian, &this.TdrMetaVersion)
		if err != nil {
			return errors.New("TCaplusPkgHead.TdrMetaVersion unpack error\n" + err.Error())
		}

	}
	if cutVer >= TCaplusPkgHeadReqBodyCompressTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ReqBodyCompressType)
		if err != nil {
			return errors.New("TCaplusPkgHead.ReqBodyCompressType unpack error\n" + err.Error())
		}

	} else {
		this.ReqBodyCompressType = 0

	}
	if cutVer >= TCaplusPkgHeadRespBodyCompressTypeVersion {

		err = binary.Read(r, binary.BigEndian, &this.RespBodyCompressType)
		if err != nil {
			return errors.New("TCaplusPkgHead.RespBodyCompressType unpack error\n" + err.Error())
		}

	} else {
		this.RespBodyCompressType = 0

	}
	if cutVer >= TCaplusPkgHeadResultVersion {

		err = binary.Read(r, binary.BigEndian, &this.Result)
		if err != nil {
			return errors.New("TCaplusPkgHead.Result unpack error\n" + err.Error())
		}

	} else {
		this.Result = 0

	}
	if cutVer >= TCaplusPkgHeadSplitTableKeyBuffLenVersion {

		err = binary.Read(r, binary.BigEndian, &this.SplitTableKeyBuffLen)
		if err != nil {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuffLen unpack error\n" + err.Error())
		}

	} else {
		this.SplitTableKeyBuffLen = 0

	}
	if cutVer >= TCaplusPkgHeadSplitTableKeyBuffVersion {

		if this.SplitTableKeyBuffLen < 0 {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuff's refer SplitTableKeyBuffLen should >= 0")
		}
		if this.SplitTableKeyBuffLen > 1024 {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuff's refer SplitTableKeyBuffLen should <= count 1024")
		}

		if this.SplitTableKeyBuff == nil {
			this.SplitTableKeyBuff = make([]byte, int(this.SplitTableKeyBuffLen))
		}

		referSplitTableKeyBuff := this.SplitTableKeyBuff[:this.SplitTableKeyBuffLen]
		err = binary.Read(r, binary.BigEndian, referSplitTableKeyBuff)
		if err != nil {
			return errors.New("TCaplusPkgHead.SplitTableKeyBuff pack error\n" + err.Error())
		}

	}
	return err
}

const (
	CarryInfoDuringMoveBaseVersion    uint32 = 57
	CarryInfoDuringMoveCurrentVersion uint32 = 91
)

// CarryInfoDuringMove
type CarryInfoDuringMove struct {
	ExpireTime uint32 `tdr_field:"ExpireTime"`

	GetFlag int32 `tdr_field:"GetFlag"`

	FieldInfo *TCaplusNameSet `tdr_field:"FieldInfo"`

	ProxyID int32 `tdr_field:"ProxyID"`

	Head *TCaplusPkgHead `tdr_field:"Head"`

	BuffLen int32 `tdr_field:"BuffLen"`

	Buff []byte `tdr_field:"Buff" tdr_count:"1024" tdr_refer:"BuffLen"`
}

func NewCarryInfoDuringMove() *CarryInfoDuringMove {
	obj := new(CarryInfoDuringMove)
	obj.Init()
	return obj
}

func (this *CarryInfoDuringMove) GetBaseVersion() uint32 {
	return CarryInfoDuringMoveBaseVersion
}

func (this *CarryInfoDuringMove) GetCurrentVersion() uint32 {
	return CarryInfoDuringMoveCurrentVersion
}

func (this *CarryInfoDuringMove) Init() {
	this.ExpireTime = 0

	this.GetFlag = 0x00

	this.FieldInfo = NewTCaplusNameSet()

	this.Head = NewTCaplusPkgHead()

	this.BuffLen = 0

}

func (this *CarryInfoDuringMove) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("CarryInfoDuringMove Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *CarryInfoDuringMove) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > CarryInfoDuringMoveCurrentVersion {
		cutVer = CarryInfoDuringMoveCurrentVersion
	}
	// check cut version
	if cutVer < CarryInfoDuringMoveBaseVersion {
		return errors.New("CarryInfoDuringMove cut version must large than CarryInfoDuringMoveBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ExpireTime)
	if err != nil {
		return errors.New("CarryInfoDuringMove.ExpireTime pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.GetFlag)
	if err != nil {
		return errors.New("CarryInfoDuringMove.GetFlag pack error\n" + err.Error())
	}

	err = this.FieldInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("CarryInfoDuringMove.FieldInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ProxyID)
	if err != nil {
		return errors.New("CarryInfoDuringMove.ProxyID pack error\n" + err.Error())
	}

	err = this.Head.PackTo(cutVer, w)
	if err != nil {
		return errors.New("CarryInfoDuringMove.Head pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.BuffLen)
	if err != nil {
		return errors.New("CarryInfoDuringMove.BuffLen pack error\n" + err.Error())
	}

	if this.BuffLen < 0 {
		return errors.New("CarryInfoDuringMove.Buff's refer BuffLen should >= 0")
	}
	if this.BuffLen > 1024 {
		return errors.New("CarryInfoDuringMove.Buff's refer BuffLen should <= count 1024")
	}
	if len(this.Buff) < int(this.BuffLen) {
		return errors.New("CarryInfoDuringMove.Buff's length should > BuffLen")
	}
	if this.BuffLen > 0 {
		referBuff := this.Buff[:this.BuffLen]
		err = binary.Write(w, binary.BigEndian, referBuff)
		if err != nil {
			return errors.New("CarryInfoDuringMove.Buff pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *CarryInfoDuringMove) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("CarryInfoDuringMove data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *CarryInfoDuringMove) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > CarryInfoDuringMoveCurrentVersion {
		cutVer = CarryInfoDuringMoveCurrentVersion
	}
	// check version
	if cutVer < CarryInfoDuringMoveBaseVersion {
		errors.New("CarryInfoDuringMove cut version must large than CarryInfoDuringMoveBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ExpireTime)
	if err != nil {
		return errors.New("CarryInfoDuringMove.ExpireTime unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.GetFlag)
	if err != nil {
		return errors.New("CarryInfoDuringMove.GetFlag unpack error\n" + err.Error())
	}

	err = this.FieldInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("CarryInfoDuringMove.FieldInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ProxyID)
	if err != nil {
		return errors.New("CarryInfoDuringMove.ProxyID unpack error\n" + err.Error())
	}

	err = this.Head.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("CarryInfoDuringMove.Head unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.BuffLen)
	if err != nil {
		return errors.New("CarryInfoDuringMove.BuffLen unpack error\n" + err.Error())
	}

	if this.BuffLen < 0 {
		return errors.New("CarryInfoDuringMove.Buff's refer BuffLen should >= 0")
	}
	if this.BuffLen > 1024 {
		return errors.New("CarryInfoDuringMove.Buff's refer BuffLen should <= count 1024")
	}

	if this.Buff == nil {
		this.Buff = make([]byte, int(this.BuffLen))
	}

	referBuff := this.Buff[:this.BuffLen]
	err = binary.Read(r, binary.BigEndian, referBuff)
	if err != nil {
		return errors.New("CarryInfoDuringMove.Buff pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetDuringMoveFromSrcReqBaseVersion    uint32 = 57
	TCaplusGetDuringMoveFromSrcReqCurrentVersion uint32 = 91
)

// TCaplusGetDuringMoveFromSrcReq
type TCaplusGetDuringMoveFromSrcReq struct {
	CarryInfoDuringMove *CarryInfoDuringMove `tdr_field:"CarryInfoDuringMove"`
}

func NewTCaplusGetDuringMoveFromSrcReq() *TCaplusGetDuringMoveFromSrcReq {
	obj := new(TCaplusGetDuringMoveFromSrcReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetDuringMoveFromSrcReq) GetBaseVersion() uint32 {
	return TCaplusGetDuringMoveFromSrcReqBaseVersion
}

func (this *TCaplusGetDuringMoveFromSrcReq) GetCurrentVersion() uint32 {
	return TCaplusGetDuringMoveFromSrcReqCurrentVersion
}

func (this *TCaplusGetDuringMoveFromSrcReq) Init() {
	this.CarryInfoDuringMove = NewCarryInfoDuringMove()

}

func (this *TCaplusGetDuringMoveFromSrcReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetDuringMoveFromSrcReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetDuringMoveFromSrcReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveFromSrcReqCurrentVersion {
		cutVer = TCaplusGetDuringMoveFromSrcReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetDuringMoveFromSrcReqBaseVersion {
		return errors.New("TCaplusGetDuringMoveFromSrcReq cut version must large than TCaplusGetDuringMoveFromSrcReqBaseVersion\n")
	}

	var err error

	err = this.CarryInfoDuringMove.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcReq.CarryInfoDuringMove pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetDuringMoveFromSrcReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetDuringMoveFromSrcReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetDuringMoveFromSrcReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveFromSrcReqCurrentVersion {
		cutVer = TCaplusGetDuringMoveFromSrcReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetDuringMoveFromSrcReqBaseVersion {
		errors.New("TCaplusGetDuringMoveFromSrcReq cut version must large than TCaplusGetDuringMoveFromSrcReqBaseVersion\n")
	}

	err = this.CarryInfoDuringMove.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcReq.CarryInfoDuringMove unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetDuringMoveFromSrcResBaseVersion    uint32 = 57
	TCaplusGetDuringMoveFromSrcResCurrentVersion uint32 = 109
)

// TCaplusGetDuringMoveFromSrcRes
type TCaplusGetDuringMoveFromSrcRes struct {
	GetRes *TCaplusGetRes `tdr_field:"GetRes"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`

	CarryInfoDuringMove *CarryInfoDuringMove `tdr_field:"CarryInfoDuringMove"`
}

func NewTCaplusGetDuringMoveFromSrcRes() *TCaplusGetDuringMoveFromSrcRes {
	obj := new(TCaplusGetDuringMoveFromSrcRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetDuringMoveFromSrcRes) GetBaseVersion() uint32 {
	return TCaplusGetDuringMoveFromSrcResBaseVersion
}

func (this *TCaplusGetDuringMoveFromSrcRes) GetCurrentVersion() uint32 {
	return TCaplusGetDuringMoveFromSrcResCurrentVersion
}

func (this *TCaplusGetDuringMoveFromSrcRes) Init() {
	this.GetRes = NewTCaplusGetRes()

	this.RecordProperty = NewTCaplusRecordProperty()

	this.CarryInfoDuringMove = NewCarryInfoDuringMove()

}

func (this *TCaplusGetDuringMoveFromSrcRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetDuringMoveFromSrcRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetDuringMoveFromSrcRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveFromSrcResCurrentVersion {
		cutVer = TCaplusGetDuringMoveFromSrcResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetDuringMoveFromSrcResBaseVersion {
		return errors.New("TCaplusGetDuringMoveFromSrcRes cut version must large than TCaplusGetDuringMoveFromSrcResBaseVersion\n")
	}

	var err error

	err = this.GetRes.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcRes.GetRes pack error\n" + err.Error())
	}

	err = this.RecordProperty.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcRes.RecordProperty pack error\n" + err.Error())
	}

	err = this.CarryInfoDuringMove.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcRes.CarryInfoDuringMove pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetDuringMoveFromSrcRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetDuringMoveFromSrcRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetDuringMoveFromSrcRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetDuringMoveFromSrcResCurrentVersion {
		cutVer = TCaplusGetDuringMoveFromSrcResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetDuringMoveFromSrcResBaseVersion {
		errors.New("TCaplusGetDuringMoveFromSrcRes cut version must large than TCaplusGetDuringMoveFromSrcResBaseVersion\n")
	}

	err = this.GetRes.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcRes.GetRes unpack error\n" + err.Error())
	}

	err = this.RecordProperty.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcRes.RecordProperty unpack error\n" + err.Error())
	}

	err = this.CarryInfoDuringMove.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetDuringMoveFromSrcRes.CarryInfoDuringMove unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusNegotiateVersionReqBaseVersion    uint32 = 57
	TCaplusNegotiateVersionReqCurrentVersion uint32 = 57
)

// TCaplusNegotiateVersionReq
type TCaplusNegotiateVersionReq struct {
	Version int32 `tdr_field:"Version"`
}

func NewTCaplusNegotiateVersionReq() *TCaplusNegotiateVersionReq {
	obj := new(TCaplusNegotiateVersionReq)
	obj.Init()
	return obj
}

func (this *TCaplusNegotiateVersionReq) GetBaseVersion() uint32 {
	return TCaplusNegotiateVersionReqBaseVersion
}

func (this *TCaplusNegotiateVersionReq) GetCurrentVersion() uint32 {
	return TCaplusNegotiateVersionReqCurrentVersion
}

func (this *TCaplusNegotiateVersionReq) Init() {

}

func (this *TCaplusNegotiateVersionReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusNegotiateVersionReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusNegotiateVersionReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusNegotiateVersionReqCurrentVersion {
		cutVer = TCaplusNegotiateVersionReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusNegotiateVersionReqBaseVersion {
		return errors.New("TCaplusNegotiateVersionReq cut version must large than TCaplusNegotiateVersionReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusNegotiateVersionReq.Version pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusNegotiateVersionReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusNegotiateVersionReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusNegotiateVersionReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusNegotiateVersionReqCurrentVersion {
		cutVer = TCaplusNegotiateVersionReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusNegotiateVersionReqBaseVersion {
		errors.New("TCaplusNegotiateVersionReq cut version must large than TCaplusNegotiateVersionReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusNegotiateVersionReq.Version unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusNegotiateVersionResBaseVersion    uint32 = 57
	TCaplusNegotiateVersionResCurrentVersion uint32 = 57
)

// TCaplusNegotiateVersionRes
type TCaplusNegotiateVersionRes struct {
	Version int32 `tdr_field:"Version"`
}

func NewTCaplusNegotiateVersionRes() *TCaplusNegotiateVersionRes {
	obj := new(TCaplusNegotiateVersionRes)
	obj.Init()
	return obj
}

func (this *TCaplusNegotiateVersionRes) GetBaseVersion() uint32 {
	return TCaplusNegotiateVersionResBaseVersion
}

func (this *TCaplusNegotiateVersionRes) GetCurrentVersion() uint32 {
	return TCaplusNegotiateVersionResCurrentVersion
}

func (this *TCaplusNegotiateVersionRes) Init() {

}

func (this *TCaplusNegotiateVersionRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusNegotiateVersionRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusNegotiateVersionRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusNegotiateVersionResCurrentVersion {
		cutVer = TCaplusNegotiateVersionResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusNegotiateVersionResBaseVersion {
		return errors.New("TCaplusNegotiateVersionRes cut version must large than TCaplusNegotiateVersionResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusNegotiateVersionRes.Version pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusNegotiateVersionRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusNegotiateVersionRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusNegotiateVersionRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusNegotiateVersionResCurrentVersion {
		cutVer = TCaplusNegotiateVersionResCurrentVersion
	}
	// check version
	if cutVer < TCaplusNegotiateVersionResBaseVersion {
		errors.New("TCaplusNegotiateVersionRes cut version must large than TCaplusNegotiateVersionResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusNegotiateVersionRes.Version unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusCheckConnectDuringMoveReqBaseVersion    uint32 = 57
	TCaplusCheckConnectDuringMoveReqCurrentVersion uint32 = 57
)

// TCaplusCheckConnectDuringMoveReq
type TCaplusCheckConnectDuringMoveReq struct {
	ListenURL string `tdr_field:"ListenURL"`

	TCaplusPkgVersion int32 `tdr_field:"TCaplusPkgVersion"`
}

func NewTCaplusCheckConnectDuringMoveReq() *TCaplusCheckConnectDuringMoveReq {
	obj := new(TCaplusCheckConnectDuringMoveReq)
	obj.Init()
	return obj
}

func (this *TCaplusCheckConnectDuringMoveReq) GetBaseVersion() uint32 {
	return TCaplusCheckConnectDuringMoveReqBaseVersion
}

func (this *TCaplusCheckConnectDuringMoveReq) GetCurrentVersion() uint32 {
	return TCaplusCheckConnectDuringMoveReqCurrentVersion
}

func (this *TCaplusCheckConnectDuringMoveReq) Init() {

}

func (this *TCaplusCheckConnectDuringMoveReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusCheckConnectDuringMoveReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusCheckConnectDuringMoveReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusCheckConnectDuringMoveReqCurrentVersion {
		cutVer = TCaplusCheckConnectDuringMoveReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusCheckConnectDuringMoveReqBaseVersion {
		return errors.New("TCaplusCheckConnectDuringMoveReq cut version must large than TCaplusCheckConnectDuringMoveReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.ListenURL))+1)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveReq.ListenURL string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.ListenURL), 0))
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveReq.ListenURL string content pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.TCaplusPkgVersion)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveReq.TCaplusPkgVersion pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusCheckConnectDuringMoveReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusCheckConnectDuringMoveReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusCheckConnectDuringMoveReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusCheckConnectDuringMoveReqCurrentVersion {
		cutVer = TCaplusCheckConnectDuringMoveReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusCheckConnectDuringMoveReqBaseVersion {
		errors.New("TCaplusCheckConnectDuringMoveReq cut version must large than TCaplusCheckConnectDuringMoveReqBaseVersion\n")
	}

	var ListenURLSize uint32
	err = binary.Read(r, binary.BigEndian, &ListenURLSize)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveReq.ListenURL string size unpack error\n" + err.Error())
	}

	ListenURLBytes := make([]byte, ListenURLSize)
	err = binary.Read(r, binary.BigEndian, ListenURLBytes)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveReq.ListenURL string content unpack error\n" + err.Error())
	}
	this.ListenURL = string(ListenURLBytes[:len(ListenURLBytes)-1])

	err = binary.Read(r, binary.BigEndian, &this.TCaplusPkgVersion)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveReq.TCaplusPkgVersion unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusCheckConnectDuringMoveResBaseVersion    uint32 = 57
	TCaplusCheckConnectDuringMoveResCurrentVersion uint32 = 57
)

// TCaplusCheckConnectDuringMoveRes
type TCaplusCheckConnectDuringMoveRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusCheckConnectDuringMoveRes() *TCaplusCheckConnectDuringMoveRes {
	obj := new(TCaplusCheckConnectDuringMoveRes)
	obj.Init()
	return obj
}

func (this *TCaplusCheckConnectDuringMoveRes) GetBaseVersion() uint32 {
	return TCaplusCheckConnectDuringMoveResBaseVersion
}

func (this *TCaplusCheckConnectDuringMoveRes) GetCurrentVersion() uint32 {
	return TCaplusCheckConnectDuringMoveResCurrentVersion
}

func (this *TCaplusCheckConnectDuringMoveRes) Init() {

}

func (this *TCaplusCheckConnectDuringMoveRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusCheckConnectDuringMoveRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusCheckConnectDuringMoveRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusCheckConnectDuringMoveResCurrentVersion {
		cutVer = TCaplusCheckConnectDuringMoveResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusCheckConnectDuringMoveResBaseVersion {
		return errors.New("TCaplusCheckConnectDuringMoveRes cut version must large than TCaplusCheckConnectDuringMoveResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusCheckConnectDuringMoveRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusCheckConnectDuringMoveRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusCheckConnectDuringMoveRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusCheckConnectDuringMoveResCurrentVersion {
		cutVer = TCaplusCheckConnectDuringMoveResCurrentVersion
	}
	// check version
	if cutVer < TCaplusCheckConnectDuringMoveResBaseVersion {
		errors.New("TCaplusCheckConnectDuringMoveRes cut version must large than TCaplusCheckConnectDuringMoveResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusCheckConnectDuringMoveRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufFieldUpdateReqBaseVersion    uint32 = 78
	TCaplusProtobufFieldUpdateReqCurrentVersion uint32 = 109
)

// TCaplusProtobufFieldUpdateReq
type TCaplusProtobufFieldUpdateReq struct {
	ValueInfo *ProtobufValueSet_ `tdr_field:"ValueInfo"`

	CheckVersionType byte `tdr_field:"CheckVersionType"`
}

func NewTCaplusProtobufFieldUpdateReq() *TCaplusProtobufFieldUpdateReq {
	obj := new(TCaplusProtobufFieldUpdateReq)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufFieldUpdateReq) GetBaseVersion() uint32 {
	return TCaplusProtobufFieldUpdateReqBaseVersion
}

func (this *TCaplusProtobufFieldUpdateReq) GetCurrentVersion() uint32 {
	return TCaplusProtobufFieldUpdateReqCurrentVersion
}

func (this *TCaplusProtobufFieldUpdateReq) Init() {
	this.ValueInfo = NewProtobufValueSet_()

	this.CheckVersionType = 1

}

func (this *TCaplusProtobufFieldUpdateReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufFieldUpdateReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufFieldUpdateReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldUpdateReqCurrentVersion {
		cutVer = TCaplusProtobufFieldUpdateReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufFieldUpdateReqBaseVersion {
		return errors.New("TCaplusProtobufFieldUpdateReq cut version must large than TCaplusProtobufFieldUpdateReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateReq.ValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CheckVersionType)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateReq.CheckVersionType pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufFieldUpdateReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufFieldUpdateReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufFieldUpdateReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldUpdateReqCurrentVersion {
		cutVer = TCaplusProtobufFieldUpdateReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufFieldUpdateReqBaseVersion {
		errors.New("TCaplusProtobufFieldUpdateReq cut version must large than TCaplusProtobufFieldUpdateReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateReq.ValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CheckVersionType)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateReq.CheckVersionType unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufFieldUpdateResBaseVersion    uint32 = 78
	TCaplusProtobufFieldUpdateResCurrentVersion uint32 = 109
)

// TCaplusProtobufFieldUpdateRes
type TCaplusProtobufFieldUpdateRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *ProtobufValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusProtobufFieldUpdateRes() *TCaplusProtobufFieldUpdateRes {
	obj := new(TCaplusProtobufFieldUpdateRes)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufFieldUpdateRes) GetBaseVersion() uint32 {
	return TCaplusProtobufFieldUpdateResBaseVersion
}

func (this *TCaplusProtobufFieldUpdateRes) GetCurrentVersion() uint32 {
	return TCaplusProtobufFieldUpdateResCurrentVersion
}

func (this *TCaplusProtobufFieldUpdateRes) Init() {

	this.ResultInfo = NewProtobufValueSet_()

}

func (this *TCaplusProtobufFieldUpdateRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufFieldUpdateRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufFieldUpdateRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldUpdateResCurrentVersion {
		cutVer = TCaplusProtobufFieldUpdateResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufFieldUpdateResBaseVersion {
		return errors.New("TCaplusProtobufFieldUpdateRes cut version must large than TCaplusProtobufFieldUpdateResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufFieldUpdateRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufFieldUpdateRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufFieldUpdateRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldUpdateResCurrentVersion {
		cutVer = TCaplusProtobufFieldUpdateResCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufFieldUpdateResBaseVersion {
		errors.New("TCaplusProtobufFieldUpdateRes cut version must large than TCaplusProtobufFieldUpdateResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufFieldUpdateRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufFieldGetReqBaseVersion    uint32 = 78
	TCaplusProtobufFieldGetReqCurrentVersion uint32 = 109
)

// TCaplusProtobufFieldGetReq
type TCaplusProtobufFieldGetReq struct {
	ValueInfo *ProtobufValueSet_ `tdr_field:"ValueInfo"`
}

func NewTCaplusProtobufFieldGetReq() *TCaplusProtobufFieldGetReq {
	obj := new(TCaplusProtobufFieldGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufFieldGetReq) GetBaseVersion() uint32 {
	return TCaplusProtobufFieldGetReqBaseVersion
}

func (this *TCaplusProtobufFieldGetReq) GetCurrentVersion() uint32 {
	return TCaplusProtobufFieldGetReqCurrentVersion
}

func (this *TCaplusProtobufFieldGetReq) Init() {
	this.ValueInfo = NewProtobufValueSet_()

}

func (this *TCaplusProtobufFieldGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufFieldGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufFieldGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldGetReqCurrentVersion {
		cutVer = TCaplusProtobufFieldGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufFieldGetReqBaseVersion {
		return errors.New("TCaplusProtobufFieldGetReq cut version must large than TCaplusProtobufFieldGetReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetReq.ValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufFieldGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufFieldGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufFieldGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldGetReqCurrentVersion {
		cutVer = TCaplusProtobufFieldGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufFieldGetReqBaseVersion {
		errors.New("TCaplusProtobufFieldGetReq cut version must large than TCaplusProtobufFieldGetReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetReq.ValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufFieldGetResBaseVersion    uint32 = 78
	TCaplusProtobufFieldGetResCurrentVersion uint32 = 109
)

// TCaplusProtobufFieldGetRes
type TCaplusProtobufFieldGetRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *ProtobufValueSet_ `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusProtobufFieldGetRes() *TCaplusProtobufFieldGetRes {
	obj := new(TCaplusProtobufFieldGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufFieldGetRes) GetBaseVersion() uint32 {
	return TCaplusProtobufFieldGetResBaseVersion
}

func (this *TCaplusProtobufFieldGetRes) GetCurrentVersion() uint32 {
	return TCaplusProtobufFieldGetResCurrentVersion
}

func (this *TCaplusProtobufFieldGetRes) Init() {

	this.ResultInfo = NewProtobufValueSet_()

}

func (this *TCaplusProtobufFieldGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufFieldGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufFieldGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldGetResCurrentVersion {
		cutVer = TCaplusProtobufFieldGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufFieldGetResBaseVersion {
		return errors.New("TCaplusProtobufFieldGetRes cut version must large than TCaplusProtobufFieldGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetRes.ResultInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetRes.LastAccessTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufFieldGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufFieldGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufFieldGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldGetResCurrentVersion {
		cutVer = TCaplusProtobufFieldGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufFieldGetResBaseVersion {
		errors.New("TCaplusProtobufFieldGetRes cut version must large than TCaplusProtobufFieldGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetRes.ResultInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusProtobufFieldGetRes.LastAccessTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufFieldIncreaseReqBaseVersion    uint32 = 78
	TCaplusProtobufFieldIncreaseReqCurrentVersion uint32 = 109
)

// TCaplusProtobufFieldIncreaseReq
type TCaplusProtobufFieldIncreaseReq struct {
	ValueInfo *ProtobufValueSet_ `tdr_field:"ValueInfo"`

	CheckVersionType byte `tdr_field:"CheckVersionType"`
}

func NewTCaplusProtobufFieldIncreaseReq() *TCaplusProtobufFieldIncreaseReq {
	obj := new(TCaplusProtobufFieldIncreaseReq)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufFieldIncreaseReq) GetBaseVersion() uint32 {
	return TCaplusProtobufFieldIncreaseReqBaseVersion
}

func (this *TCaplusProtobufFieldIncreaseReq) GetCurrentVersion() uint32 {
	return TCaplusProtobufFieldIncreaseReqCurrentVersion
}

func (this *TCaplusProtobufFieldIncreaseReq) Init() {
	this.ValueInfo = NewProtobufValueSet_()

	this.CheckVersionType = 1

}

func (this *TCaplusProtobufFieldIncreaseReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufFieldIncreaseReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufFieldIncreaseReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldIncreaseReqCurrentVersion {
		cutVer = TCaplusProtobufFieldIncreaseReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufFieldIncreaseReqBaseVersion {
		return errors.New("TCaplusProtobufFieldIncreaseReq cut version must large than TCaplusProtobufFieldIncreaseReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseReq.ValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.CheckVersionType)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseReq.CheckVersionType pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufFieldIncreaseReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufFieldIncreaseReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufFieldIncreaseReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldIncreaseReqCurrentVersion {
		cutVer = TCaplusProtobufFieldIncreaseReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufFieldIncreaseReqBaseVersion {
		errors.New("TCaplusProtobufFieldIncreaseReq cut version must large than TCaplusProtobufFieldIncreaseReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseReq.ValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.CheckVersionType)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseReq.CheckVersionType unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusProtobufFieldIncreaseResBaseVersion    uint32 = 78
	TCaplusProtobufFieldIncreaseResCurrentVersion uint32 = 109
)

// TCaplusProtobufFieldIncreaseRes
type TCaplusProtobufFieldIncreaseRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *ProtobufValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusProtobufFieldIncreaseRes() *TCaplusProtobufFieldIncreaseRes {
	obj := new(TCaplusProtobufFieldIncreaseRes)
	obj.Init()
	return obj
}

func (this *TCaplusProtobufFieldIncreaseRes) GetBaseVersion() uint32 {
	return TCaplusProtobufFieldIncreaseResBaseVersion
}

func (this *TCaplusProtobufFieldIncreaseRes) GetCurrentVersion() uint32 {
	return TCaplusProtobufFieldIncreaseResCurrentVersion
}

func (this *TCaplusProtobufFieldIncreaseRes) Init() {

	this.ResultInfo = NewProtobufValueSet_()

}

func (this *TCaplusProtobufFieldIncreaseRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusProtobufFieldIncreaseRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusProtobufFieldIncreaseRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldIncreaseResCurrentVersion {
		cutVer = TCaplusProtobufFieldIncreaseResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusProtobufFieldIncreaseResBaseVersion {
		return errors.New("TCaplusProtobufFieldIncreaseRes cut version must large than TCaplusProtobufFieldIncreaseResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusProtobufFieldIncreaseRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusProtobufFieldIncreaseRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusProtobufFieldIncreaseRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusProtobufFieldIncreaseResCurrentVersion {
		cutVer = TCaplusProtobufFieldIncreaseResCurrentVersion
	}
	// check version
	if cutVer < TCaplusProtobufFieldIncreaseResBaseVersion {
		errors.New("TCaplusProtobufFieldIncreaseRes cut version must large than TCaplusProtobufFieldIncreaseResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusProtobufFieldIncreaseRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncGetReqBaseVersion    uint32 = 85
	TCaplusMsSyncGetReqCurrentVersion uint32 = 89
)

// TCaplusMsSyncGetReq
type TCaplusMsSyncGetReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusMsSyncGetReq() *TCaplusMsSyncGetReq {
	obj := new(TCaplusMsSyncGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncGetReq) GetBaseVersion() uint32 {
	return TCaplusMsSyncGetReqBaseVersion
}

func (this *TCaplusMsSyncGetReq) GetCurrentVersion() uint32 {
	return TCaplusMsSyncGetReqCurrentVersion
}

func (this *TCaplusMsSyncGetReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusMsSyncGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncGetReqCurrentVersion {
		cutVer = TCaplusMsSyncGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncGetReqBaseVersion {
		return errors.New("TCaplusMsSyncGetReq cut version must large than TCaplusMsSyncGetReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMsSyncGetReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncGetReqCurrentVersion {
		cutVer = TCaplusMsSyncGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncGetReqBaseVersion {
		errors.New("TCaplusMsSyncGetReq cut version must large than TCaplusMsSyncGetReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMsSyncGetReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncGetResBaseVersion    uint32 = 85
	TCaplusMsSyncGetResCurrentVersion uint32 = 85
)

// TCaplusMsSyncGetRes
type TCaplusMsSyncGetRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMsSyncGetRes() *TCaplusMsSyncGetRes {
	obj := new(TCaplusMsSyncGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncGetRes) GetBaseVersion() uint32 {
	return TCaplusMsSyncGetResBaseVersion
}

func (this *TCaplusMsSyncGetRes) GetCurrentVersion() uint32 {
	return TCaplusMsSyncGetResCurrentVersion
}

func (this *TCaplusMsSyncGetRes) Init() {

}

func (this *TCaplusMsSyncGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncGetResCurrentVersion {
		cutVer = TCaplusMsSyncGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncGetResBaseVersion {
		return errors.New("TCaplusMsSyncGetRes cut version must large than TCaplusMsSyncGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncGetRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncGetResCurrentVersion {
		cutVer = TCaplusMsSyncGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncGetResBaseVersion {
		errors.New("TCaplusMsSyncGetRes cut version must large than TCaplusMsSyncGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncGetRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncGetReqBaseVersion    uint32 = 85
	TCaplusListMsSyncGetReqCurrentVersion uint32 = 89
)

// TCaplusListMsSyncGetReq
type TCaplusListMsSyncGetReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusListMsSyncGetReq() *TCaplusListMsSyncGetReq {
	obj := new(TCaplusListMsSyncGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncGetReq) GetBaseVersion() uint32 {
	return TCaplusListMsSyncGetReqBaseVersion
}

func (this *TCaplusListMsSyncGetReq) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncGetReqCurrentVersion
}

func (this *TCaplusListMsSyncGetReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusListMsSyncGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetReqCurrentVersion {
		cutVer = TCaplusListMsSyncGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncGetReqBaseVersion {
		return errors.New("TCaplusListMsSyncGetReq cut version must large than TCaplusListMsSyncGetReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetReqCurrentVersion {
		cutVer = TCaplusListMsSyncGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncGetReqBaseVersion {
		errors.New("TCaplusListMsSyncGetReq cut version must large than TCaplusListMsSyncGetReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncGetResBaseVersion    uint32 = 85
	TCaplusListMsSyncGetResCurrentVersion uint32 = 85
)

// TCaplusListMsSyncGetRes
type TCaplusListMsSyncGetRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListMsSyncGetRes() *TCaplusListMsSyncGetRes {
	obj := new(TCaplusListMsSyncGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncGetRes) GetBaseVersion() uint32 {
	return TCaplusListMsSyncGetResBaseVersion
}

func (this *TCaplusListMsSyncGetRes) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncGetResCurrentVersion
}

func (this *TCaplusListMsSyncGetRes) Init() {

}

func (this *TCaplusListMsSyncGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetResCurrentVersion {
		cutVer = TCaplusListMsSyncGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncGetResBaseVersion {
		return errors.New("TCaplusListMsSyncGetRes cut version must large than TCaplusListMsSyncGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetResCurrentVersion {
		cutVer = TCaplusListMsSyncGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncGetResBaseVersion {
		errors.New("TCaplusListMsSyncGetRes cut version must large than TCaplusListMsSyncGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncGetAllReqBaseVersion    uint32 = 85
	TCaplusListMsSyncGetAllReqCurrentVersion uint32 = 89
)

// TCaplusListMsSyncGetAllReq
type TCaplusListMsSyncGetAllReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusListMsSyncGetAllReq() *TCaplusListMsSyncGetAllReq {
	obj := new(TCaplusListMsSyncGetAllReq)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncGetAllReq) GetBaseVersion() uint32 {
	return TCaplusListMsSyncGetAllReqBaseVersion
}

func (this *TCaplusListMsSyncGetAllReq) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncGetAllReqCurrentVersion
}

func (this *TCaplusListMsSyncGetAllReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusListMsSyncGetAllReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncGetAllReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncGetAllReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetAllReqCurrentVersion {
		cutVer = TCaplusListMsSyncGetAllReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncGetAllReqBaseVersion {
		return errors.New("TCaplusListMsSyncGetAllReq cut version must large than TCaplusListMsSyncGetAllReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetAllReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncGetAllReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncGetAllReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncGetAllReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetAllReqCurrentVersion {
		cutVer = TCaplusListMsSyncGetAllReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncGetAllReqBaseVersion {
		errors.New("TCaplusListMsSyncGetAllReq cut version must large than TCaplusListMsSyncGetAllReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetAllReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListMsSyncGetAllResBaseVersion    uint32 = 85
	TCaplusListMsSyncGetAllResCurrentVersion uint32 = 85
)

// TCaplusListMsSyncGetAllRes
type TCaplusListMsSyncGetAllRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListMsSyncGetAllRes() *TCaplusListMsSyncGetAllRes {
	obj := new(TCaplusListMsSyncGetAllRes)
	obj.Init()
	return obj
}

func (this *TCaplusListMsSyncGetAllRes) GetBaseVersion() uint32 {
	return TCaplusListMsSyncGetAllResBaseVersion
}

func (this *TCaplusListMsSyncGetAllRes) GetCurrentVersion() uint32 {
	return TCaplusListMsSyncGetAllResCurrentVersion
}

func (this *TCaplusListMsSyncGetAllRes) Init() {

}

func (this *TCaplusListMsSyncGetAllRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListMsSyncGetAllRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListMsSyncGetAllRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetAllResCurrentVersion {
		cutVer = TCaplusListMsSyncGetAllResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListMsSyncGetAllResBaseVersion {
		return errors.New("TCaplusListMsSyncGetAllRes cut version must large than TCaplusListMsSyncGetAllResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetAllRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListMsSyncGetAllRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListMsSyncGetAllRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListMsSyncGetAllRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListMsSyncGetAllResCurrentVersion {
		cutVer = TCaplusListMsSyncGetAllResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListMsSyncGetAllResBaseVersion {
		errors.New("TCaplusListMsSyncGetAllRes cut version must large than TCaplusListMsSyncGetAllResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListMsSyncGetAllRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncPartkeyGetReqBaseVersion    uint32 = 85
	TCaplusMsSyncPartkeyGetReqCurrentVersion uint32 = 89
)

// TCaplusMsSyncPartkeyGetReq
type TCaplusMsSyncPartkeyGetReq struct {
	UlogRecord *TCaplusMsSyncRecord `tdr_field:"UlogRecord"`
}

func NewTCaplusMsSyncPartkeyGetReq() *TCaplusMsSyncPartkeyGetReq {
	obj := new(TCaplusMsSyncPartkeyGetReq)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncPartkeyGetReq) GetBaseVersion() uint32 {
	return TCaplusMsSyncPartkeyGetReqBaseVersion
}

func (this *TCaplusMsSyncPartkeyGetReq) GetCurrentVersion() uint32 {
	return TCaplusMsSyncPartkeyGetReqCurrentVersion
}

func (this *TCaplusMsSyncPartkeyGetReq) Init() {
	this.UlogRecord = NewTCaplusMsSyncRecord()

}

func (this *TCaplusMsSyncPartkeyGetReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncPartkeyGetReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncPartkeyGetReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncPartkeyGetReqCurrentVersion {
		cutVer = TCaplusMsSyncPartkeyGetReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncPartkeyGetReqBaseVersion {
		return errors.New("TCaplusMsSyncPartkeyGetReq cut version must large than TCaplusMsSyncPartkeyGetReqBaseVersion\n")
	}

	var err error

	err = this.UlogRecord.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusMsSyncPartkeyGetReq.UlogRecord pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncPartkeyGetReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncPartkeyGetReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncPartkeyGetReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncPartkeyGetReqCurrentVersion {
		cutVer = TCaplusMsSyncPartkeyGetReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncPartkeyGetReqBaseVersion {
		errors.New("TCaplusMsSyncPartkeyGetReq cut version must large than TCaplusMsSyncPartkeyGetReqBaseVersion\n")
	}

	err = this.UlogRecord.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusMsSyncPartkeyGetReq.UlogRecord unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusMsSyncPartkeyGetResBaseVersion    uint32 = 85
	TCaplusMsSyncPartkeyGetResCurrentVersion uint32 = 85
)

// TCaplusMsSyncPartkeyGetRes
type TCaplusMsSyncPartkeyGetRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusMsSyncPartkeyGetRes() *TCaplusMsSyncPartkeyGetRes {
	obj := new(TCaplusMsSyncPartkeyGetRes)
	obj.Init()
	return obj
}

func (this *TCaplusMsSyncPartkeyGetRes) GetBaseVersion() uint32 {
	return TCaplusMsSyncPartkeyGetResBaseVersion
}

func (this *TCaplusMsSyncPartkeyGetRes) GetCurrentVersion() uint32 {
	return TCaplusMsSyncPartkeyGetResCurrentVersion
}

func (this *TCaplusMsSyncPartkeyGetRes) Init() {

}

func (this *TCaplusMsSyncPartkeyGetRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusMsSyncPartkeyGetRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusMsSyncPartkeyGetRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusMsSyncPartkeyGetResCurrentVersion {
		cutVer = TCaplusMsSyncPartkeyGetResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusMsSyncPartkeyGetResBaseVersion {
		return errors.New("TCaplusMsSyncPartkeyGetRes cut version must large than TCaplusMsSyncPartkeyGetResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncPartkeyGetRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusMsSyncPartkeyGetRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusMsSyncPartkeyGetRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusMsSyncPartkeyGetRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusMsSyncPartkeyGetResCurrentVersion {
		cutVer = TCaplusMsSyncPartkeyGetResCurrentVersion
	}
	// check version
	if cutVer < TCaplusMsSyncPartkeyGetResBaseVersion {
		errors.New("TCaplusMsSyncPartkeyGetRes cut version must large than TCaplusMsSyncPartkeyGetResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusMsSyncPartkeyGetRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysMakeConsistReqBaseVersion    uint32 = 86
	TCaplusSysMakeConsistReqCurrentVersion uint32 = 109
)

// TCaplusSysMakeConsistReq
type TCaplusSysMakeConsistReq struct {
	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	ExpireTime uint32 `tdr_field:"ExpireTime"`
}

func NewTCaplusSysMakeConsistReq() *TCaplusSysMakeConsistReq {
	obj := new(TCaplusSysMakeConsistReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysMakeConsistReq) GetBaseVersion() uint32 {
	return TCaplusSysMakeConsistReqBaseVersion
}

func (this *TCaplusSysMakeConsistReq) GetCurrentVersion() uint32 {
	return TCaplusSysMakeConsistReqCurrentVersion
}

func (this *TCaplusSysMakeConsistReq) Init() {
	this.ValueInfo = NewTCaplusValueSet_()

	this.ExpireTime = 0

}

func (this *TCaplusSysMakeConsistReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysMakeConsistReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysMakeConsistReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysMakeConsistReqCurrentVersion {
		cutVer = TCaplusSysMakeConsistReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysMakeConsistReqBaseVersion {
		return errors.New("TCaplusSysMakeConsistReq cut version must large than TCaplusSysMakeConsistReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistReq.ValueInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ExpireTime)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistReq.ExpireTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysMakeConsistReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysMakeConsistReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysMakeConsistReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysMakeConsistReqCurrentVersion {
		cutVer = TCaplusSysMakeConsistReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysMakeConsistReqBaseVersion {
		errors.New("TCaplusSysMakeConsistReq cut version must large than TCaplusSysMakeConsistReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistReq.ValueInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ExpireTime)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistReq.ExpireTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysMakeConsistResBaseVersion    uint32 = 86
	TCaplusSysMakeConsistResCurrentVersion uint32 = 109
)

// TCaplusSysMakeConsistRes
type TCaplusSysMakeConsistRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusSysMakeConsistRes() *TCaplusSysMakeConsistRes {
	obj := new(TCaplusSysMakeConsistRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysMakeConsistRes) GetBaseVersion() uint32 {
	return TCaplusSysMakeConsistResBaseVersion
}

func (this *TCaplusSysMakeConsistRes) GetCurrentVersion() uint32 {
	return TCaplusSysMakeConsistResCurrentVersion
}

func (this *TCaplusSysMakeConsistRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusSysMakeConsistRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysMakeConsistRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysMakeConsistRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysMakeConsistResCurrentVersion {
		cutVer = TCaplusSysMakeConsistResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysMakeConsistResBaseVersion {
		return errors.New("TCaplusSysMakeConsistRes cut version must large than TCaplusSysMakeConsistResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistRes.ResultInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistRes.LastAccessTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysMakeConsistRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysMakeConsistRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysMakeConsistRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysMakeConsistResCurrentVersion {
		cutVer = TCaplusSysMakeConsistResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysMakeConsistResBaseVersion {
		errors.New("TCaplusSysMakeConsistRes cut version must large than TCaplusSysMakeConsistResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistRes.ResultInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysMakeConsistRes.LastAccessTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysListMakeConsistReqBaseVersion    uint32 = 86
	TCaplusSysListMakeConsistReqCurrentVersion uint32 = 86
)

// TCaplusSysListMakeConsistReq
type TCaplusSysListMakeConsistReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	ElementValueNames *TCaplusNameSet `tdr_field:"ElementValueNames"`
}

func NewTCaplusSysListMakeConsistReq() *TCaplusSysListMakeConsistReq {
	obj := new(TCaplusSysListMakeConsistReq)
	obj.Init()
	return obj
}

func (this *TCaplusSysListMakeConsistReq) GetBaseVersion() uint32 {
	return TCaplusSysListMakeConsistReqBaseVersion
}

func (this *TCaplusSysListMakeConsistReq) GetCurrentVersion() uint32 {
	return TCaplusSysListMakeConsistReqCurrentVersion
}

func (this *TCaplusSysListMakeConsistReq) Init() {
	this.ElementIndex = 0

	this.ElementValueNames = NewTCaplusNameSet()

}

func (this *TCaplusSysListMakeConsistReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListMakeConsistReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListMakeConsistReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListMakeConsistReqCurrentVersion {
		cutVer = TCaplusSysListMakeConsistReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListMakeConsistReqBaseVersion {
		return errors.New("TCaplusSysListMakeConsistReq cut version must large than TCaplusSysListMakeConsistReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistReq.ElementIndex pack error\n" + err.Error())
	}

	err = this.ElementValueNames.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistReq.ElementValueNames pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListMakeConsistReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListMakeConsistReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListMakeConsistReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListMakeConsistReqCurrentVersion {
		cutVer = TCaplusSysListMakeConsistReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListMakeConsistReqBaseVersion {
		errors.New("TCaplusSysListMakeConsistReq cut version must large than TCaplusSysListMakeConsistReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistReq.ElementIndex unpack error\n" + err.Error())
	}

	err = this.ElementValueNames.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistReq.ElementValueNames unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSysListMakeConsistResBaseVersion    uint32 = 86
	TCaplusSysListMakeConsistResCurrentVersion uint32 = 86
)

// TCaplusSysListMakeConsistRes
type TCaplusSysListMakeConsistRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusListElementSet `tdr_field:"ResultInfo"`

	LastAccessTime uint64 `tdr_field:"LastAccessTime"`
}

func NewTCaplusSysListMakeConsistRes() *TCaplusSysListMakeConsistRes {
	obj := new(TCaplusSysListMakeConsistRes)
	obj.Init()
	return obj
}

func (this *TCaplusSysListMakeConsistRes) GetBaseVersion() uint32 {
	return TCaplusSysListMakeConsistResBaseVersion
}

func (this *TCaplusSysListMakeConsistRes) GetCurrentVersion() uint32 {
	return TCaplusSysListMakeConsistResCurrentVersion
}

func (this *TCaplusSysListMakeConsistRes) Init() {

	this.ResultInfo = NewTCaplusListElementSet()

}

func (this *TCaplusSysListMakeConsistRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSysListMakeConsistRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSysListMakeConsistRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSysListMakeConsistResCurrentVersion {
		cutVer = TCaplusSysListMakeConsistResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSysListMakeConsistResBaseVersion {
		return errors.New("TCaplusSysListMakeConsistRes cut version must large than TCaplusSysListMakeConsistResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistRes.ResultInfo pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistRes.LastAccessTime pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSysListMakeConsistRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSysListMakeConsistRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSysListMakeConsistRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSysListMakeConsistResCurrentVersion {
		cutVer = TCaplusSysListMakeConsistResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSysListMakeConsistResBaseVersion {
		errors.New("TCaplusSysListMakeConsistRes cut version must large than TCaplusSysListMakeConsistResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistRes.ResultInfo unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.LastAccessTime)
	if err != nil {
		return errors.New("TCaplusSysListMakeConsistRes.LastAccessTime unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusLosslessMoveReplaceReqBaseVersion    uint32 = 87
	TCaplusLosslessMoveReplaceReqCurrentVersion uint32 = 109
)

// TCaplusLosslessMoveReplaceReq
type TCaplusLosslessMoveReplaceReq struct {
	ValueInfo *TCaplusValueSet_ `tdr_field:"ValueInfo"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`
}

func NewTCaplusLosslessMoveReplaceReq() *TCaplusLosslessMoveReplaceReq {
	obj := new(TCaplusLosslessMoveReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusLosslessMoveReplaceReq) GetBaseVersion() uint32 {
	return TCaplusLosslessMoveReplaceReqBaseVersion
}

func (this *TCaplusLosslessMoveReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusLosslessMoveReplaceReqCurrentVersion
}

func (this *TCaplusLosslessMoveReplaceReq) Init() {
	this.ValueInfo = NewTCaplusValueSet_()

	this.RecordProperty = NewTCaplusRecordProperty()

}

func (this *TCaplusLosslessMoveReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusLosslessMoveReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusLosslessMoveReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveReplaceReqCurrentVersion {
		cutVer = TCaplusLosslessMoveReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusLosslessMoveReplaceReqBaseVersion {
		return errors.New("TCaplusLosslessMoveReplaceReq cut version must large than TCaplusLosslessMoveReplaceReqBaseVersion\n")
	}

	var err error

	err = this.ValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusLosslessMoveReplaceReq.ValueInfo pack error\n" + err.Error())
	}

	err = this.RecordProperty.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusLosslessMoveReplaceReq.RecordProperty pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusLosslessMoveReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusLosslessMoveReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusLosslessMoveReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveReplaceReqCurrentVersion {
		cutVer = TCaplusLosslessMoveReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusLosslessMoveReplaceReqBaseVersion {
		errors.New("TCaplusLosslessMoveReplaceReq cut version must large than TCaplusLosslessMoveReplaceReqBaseVersion\n")
	}

	err = this.ValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusLosslessMoveReplaceReq.ValueInfo unpack error\n" + err.Error())
	}

	err = this.RecordProperty.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusLosslessMoveReplaceReq.RecordProperty unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusLosslessMoveReplaceResBaseVersion    uint32 = 87
	TCaplusLosslessMoveReplaceResCurrentVersion uint32 = 87
)

// TCaplusLosslessMoveReplaceRes
type TCaplusLosslessMoveReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusLosslessMoveReplaceRes() *TCaplusLosslessMoveReplaceRes {
	obj := new(TCaplusLosslessMoveReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusLosslessMoveReplaceRes) GetBaseVersion() uint32 {
	return TCaplusLosslessMoveReplaceResBaseVersion
}

func (this *TCaplusLosslessMoveReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusLosslessMoveReplaceResCurrentVersion
}

func (this *TCaplusLosslessMoveReplaceRes) Init() {

}

func (this *TCaplusLosslessMoveReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusLosslessMoveReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusLosslessMoveReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveReplaceResCurrentVersion {
		cutVer = TCaplusLosslessMoveReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusLosslessMoveReplaceResBaseVersion {
		return errors.New("TCaplusLosslessMoveReplaceRes cut version must large than TCaplusLosslessMoveReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusLosslessMoveReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusLosslessMoveReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusLosslessMoveReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusLosslessMoveReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveReplaceResCurrentVersion {
		cutVer = TCaplusLosslessMoveReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusLosslessMoveReplaceResBaseVersion {
		errors.New("TCaplusLosslessMoveReplaceRes cut version must large than TCaplusLosslessMoveReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusLosslessMoveReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusLosslessMoveListIndexReplaceReqBaseVersion    uint32 = 87
	TCaplusLosslessMoveListIndexReplaceReqCurrentVersion uint32 = 91
)

// TCaplusLosslessMoveListIndexReplaceReq
type TCaplusLosslessMoveListIndexReplaceReq struct {
	ListIndex *TcapListIndex `tdr_field:"ListIndex"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`
}

func NewTCaplusLosslessMoveListIndexReplaceReq() *TCaplusLosslessMoveListIndexReplaceReq {
	obj := new(TCaplusLosslessMoveListIndexReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusLosslessMoveListIndexReplaceReq) GetBaseVersion() uint32 {
	return TCaplusLosslessMoveListIndexReplaceReqBaseVersion
}

func (this *TCaplusLosslessMoveListIndexReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusLosslessMoveListIndexReplaceReqCurrentVersion
}

func (this *TCaplusLosslessMoveListIndexReplaceReq) Init() {
	this.ListIndex = NewTcapListIndex()

	this.RecordProperty = NewTCaplusRecordProperty()

}

func (this *TCaplusLosslessMoveListIndexReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusLosslessMoveListIndexReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusLosslessMoveListIndexReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListIndexReplaceReqCurrentVersion {
		cutVer = TCaplusLosslessMoveListIndexReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusLosslessMoveListIndexReplaceReqBaseVersion {
		return errors.New("TCaplusLosslessMoveListIndexReplaceReq cut version must large than TCaplusLosslessMoveListIndexReplaceReqBaseVersion\n")
	}

	var err error

	err = this.ListIndex.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListIndexReplaceReq.ListIndex pack error\n" + err.Error())
	}

	err = this.RecordProperty.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListIndexReplaceReq.RecordProperty pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusLosslessMoveListIndexReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusLosslessMoveListIndexReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusLosslessMoveListIndexReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListIndexReplaceReqCurrentVersion {
		cutVer = TCaplusLosslessMoveListIndexReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusLosslessMoveListIndexReplaceReqBaseVersion {
		errors.New("TCaplusLosslessMoveListIndexReplaceReq cut version must large than TCaplusLosslessMoveListIndexReplaceReqBaseVersion\n")
	}

	err = this.ListIndex.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListIndexReplaceReq.ListIndex unpack error\n" + err.Error())
	}

	err = this.RecordProperty.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListIndexReplaceReq.RecordProperty unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusLosslessMoveListIndexReplaceResBaseVersion    uint32 = 87
	TCaplusLosslessMoveListIndexReplaceResCurrentVersion uint32 = 87
)

// TCaplusLosslessMoveListIndexReplaceRes
type TCaplusLosslessMoveListIndexReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusLosslessMoveListIndexReplaceRes() *TCaplusLosslessMoveListIndexReplaceRes {
	obj := new(TCaplusLosslessMoveListIndexReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusLosslessMoveListIndexReplaceRes) GetBaseVersion() uint32 {
	return TCaplusLosslessMoveListIndexReplaceResBaseVersion
}

func (this *TCaplusLosslessMoveListIndexReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusLosslessMoveListIndexReplaceResCurrentVersion
}

func (this *TCaplusLosslessMoveListIndexReplaceRes) Init() {

}

func (this *TCaplusLosslessMoveListIndexReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusLosslessMoveListIndexReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusLosslessMoveListIndexReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListIndexReplaceResCurrentVersion {
		cutVer = TCaplusLosslessMoveListIndexReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusLosslessMoveListIndexReplaceResBaseVersion {
		return errors.New("TCaplusLosslessMoveListIndexReplaceRes cut version must large than TCaplusLosslessMoveListIndexReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListIndexReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusLosslessMoveListIndexReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusLosslessMoveListIndexReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusLosslessMoveListIndexReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListIndexReplaceResCurrentVersion {
		cutVer = TCaplusLosslessMoveListIndexReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusLosslessMoveListIndexReplaceResBaseVersion {
		errors.New("TCaplusLosslessMoveListIndexReplaceRes cut version must large than TCaplusLosslessMoveListIndexReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListIndexReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusLosslessMoveListElemReplaceReqBaseVersion    uint32 = 87
	TCaplusLosslessMoveListElemReplaceReqCurrentVersion uint32 = 109
)

// TCaplusLosslessMoveListElemReplaceReq
type TCaplusLosslessMoveListElemReplaceReq struct {
	ElementValueInfo *TCaplusValueSet_ `tdr_field:"ElementValueInfo"`

	RecordProperty *TCaplusRecordProperty `tdr_field:"RecordProperty"`
}

func NewTCaplusLosslessMoveListElemReplaceReq() *TCaplusLosslessMoveListElemReplaceReq {
	obj := new(TCaplusLosslessMoveListElemReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusLosslessMoveListElemReplaceReq) GetBaseVersion() uint32 {
	return TCaplusLosslessMoveListElemReplaceReqBaseVersion
}

func (this *TCaplusLosslessMoveListElemReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusLosslessMoveListElemReplaceReqCurrentVersion
}

func (this *TCaplusLosslessMoveListElemReplaceReq) Init() {
	this.ElementValueInfo = NewTCaplusValueSet_()

	this.RecordProperty = NewTCaplusRecordProperty()

}

func (this *TCaplusLosslessMoveListElemReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusLosslessMoveListElemReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusLosslessMoveListElemReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListElemReplaceReqCurrentVersion {
		cutVer = TCaplusLosslessMoveListElemReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusLosslessMoveListElemReplaceReqBaseVersion {
		return errors.New("TCaplusLosslessMoveListElemReplaceReq cut version must large than TCaplusLosslessMoveListElemReplaceReqBaseVersion\n")
	}

	var err error

	err = this.ElementValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListElemReplaceReq.ElementValueInfo pack error\n" + err.Error())
	}

	err = this.RecordProperty.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListElemReplaceReq.RecordProperty pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusLosslessMoveListElemReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusLosslessMoveListElemReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusLosslessMoveListElemReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListElemReplaceReqCurrentVersion {
		cutVer = TCaplusLosslessMoveListElemReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusLosslessMoveListElemReplaceReqBaseVersion {
		errors.New("TCaplusLosslessMoveListElemReplaceReq cut version must large than TCaplusLosslessMoveListElemReplaceReqBaseVersion\n")
	}

	err = this.ElementValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListElemReplaceReq.ElementValueInfo unpack error\n" + err.Error())
	}

	err = this.RecordProperty.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListElemReplaceReq.RecordProperty unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusLosslessMoveListElemReplaceResBaseVersion    uint32 = 87
	TCaplusLosslessMoveListElemReplaceResCurrentVersion uint32 = 87
)

// TCaplusLosslessMoveListElemReplaceRes
type TCaplusLosslessMoveListElemReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusLosslessMoveListElemReplaceRes() *TCaplusLosslessMoveListElemReplaceRes {
	obj := new(TCaplusLosslessMoveListElemReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusLosslessMoveListElemReplaceRes) GetBaseVersion() uint32 {
	return TCaplusLosslessMoveListElemReplaceResBaseVersion
}

func (this *TCaplusLosslessMoveListElemReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusLosslessMoveListElemReplaceResCurrentVersion
}

func (this *TCaplusLosslessMoveListElemReplaceRes) Init() {

}

func (this *TCaplusLosslessMoveListElemReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusLosslessMoveListElemReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusLosslessMoveListElemReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListElemReplaceResCurrentVersion {
		cutVer = TCaplusLosslessMoveListElemReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusLosslessMoveListElemReplaceResBaseVersion {
		return errors.New("TCaplusLosslessMoveListElemReplaceRes cut version must large than TCaplusLosslessMoveListElemReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListElemReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusLosslessMoveListElemReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusLosslessMoveListElemReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusLosslessMoveListElemReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusLosslessMoveListElemReplaceResCurrentVersion {
		cutVer = TCaplusLosslessMoveListElemReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusLosslessMoveListElemReplaceResBaseVersion {
		errors.New("TCaplusLosslessMoveListElemReplaceRes cut version must large than TCaplusLosslessMoveListElemReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusLosslessMoveListElemReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListIndexMoveReplaceReqBaseVersion    uint32 = 112
	TCaplusListIndexMoveReplaceReqCurrentVersion uint32 = 112
)

// TCaplusListIndexMoveReplaceReq
type TCaplusListIndexMoveReplaceReq struct {
	IndexValueInfo *TCaplusValueSet_ `tdr_field:"IndexValueInfo"`
}

func NewTCaplusListIndexMoveReplaceReq() *TCaplusListIndexMoveReplaceReq {
	obj := new(TCaplusListIndexMoveReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusListIndexMoveReplaceReq) GetBaseVersion() uint32 {
	return TCaplusListIndexMoveReplaceReqBaseVersion
}

func (this *TCaplusListIndexMoveReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusListIndexMoveReplaceReqCurrentVersion
}

func (this *TCaplusListIndexMoveReplaceReq) Init() {
	this.IndexValueInfo = NewTCaplusValueSet_()

}

func (this *TCaplusListIndexMoveReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListIndexMoveReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListIndexMoveReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveReplaceReqCurrentVersion {
		cutVer = TCaplusListIndexMoveReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListIndexMoveReplaceReqBaseVersion {
		return errors.New("TCaplusListIndexMoveReplaceReq cut version must large than TCaplusListIndexMoveReplaceReqBaseVersion\n")
	}

	var err error

	err = this.IndexValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListIndexMoveReplaceReq.IndexValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListIndexMoveReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListIndexMoveReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListIndexMoveReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveReplaceReqCurrentVersion {
		cutVer = TCaplusListIndexMoveReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListIndexMoveReplaceReqBaseVersion {
		errors.New("TCaplusListIndexMoveReplaceReq cut version must large than TCaplusListIndexMoveReplaceReqBaseVersion\n")
	}

	err = this.IndexValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListIndexMoveReplaceReq.IndexValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListIndexMoveReplaceResBaseVersion    uint32 = 112
	TCaplusListIndexMoveReplaceResCurrentVersion uint32 = 112
)

// TCaplusListIndexMoveReplaceRes
type TCaplusListIndexMoveReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListIndexMoveReplaceRes() *TCaplusListIndexMoveReplaceRes {
	obj := new(TCaplusListIndexMoveReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusListIndexMoveReplaceRes) GetBaseVersion() uint32 {
	return TCaplusListIndexMoveReplaceResBaseVersion
}

func (this *TCaplusListIndexMoveReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusListIndexMoveReplaceResCurrentVersion
}

func (this *TCaplusListIndexMoveReplaceRes) Init() {

}

func (this *TCaplusListIndexMoveReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListIndexMoveReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListIndexMoveReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveReplaceResCurrentVersion {
		cutVer = TCaplusListIndexMoveReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListIndexMoveReplaceResBaseVersion {
		return errors.New("TCaplusListIndexMoveReplaceRes cut version must large than TCaplusListIndexMoveReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListIndexMoveReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListIndexMoveReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListIndexMoveReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListIndexMoveReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListIndexMoveReplaceResCurrentVersion {
		cutVer = TCaplusListIndexMoveReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListIndexMoveReplaceResBaseVersion {
		errors.New("TCaplusListIndexMoveReplaceRes cut version must large than TCaplusListIndexMoveReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListIndexMoveReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListElementMoveReplaceReqBaseVersion    uint32 = 112
	TCaplusListElementMoveReplaceReqCurrentVersion uint32 = 112
)

// TCaplusListElementMoveReplaceReq
type TCaplusListElementMoveReplaceReq struct {
	ElementIndex int32 `tdr_field:"ElementIndex"`

	ElementValueInfo *TCaplusValueSet_ `tdr_field:"ElementValueInfo"`
}

func NewTCaplusListElementMoveReplaceReq() *TCaplusListElementMoveReplaceReq {
	obj := new(TCaplusListElementMoveReplaceReq)
	obj.Init()
	return obj
}

func (this *TCaplusListElementMoveReplaceReq) GetBaseVersion() uint32 {
	return TCaplusListElementMoveReplaceReqBaseVersion
}

func (this *TCaplusListElementMoveReplaceReq) GetCurrentVersion() uint32 {
	return TCaplusListElementMoveReplaceReqCurrentVersion
}

func (this *TCaplusListElementMoveReplaceReq) Init() {
	this.ElementIndex = 0

	this.ElementValueInfo = NewTCaplusValueSet_()

}

func (this *TCaplusListElementMoveReplaceReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListElementMoveReplaceReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListElementMoveReplaceReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListElementMoveReplaceReqCurrentVersion {
		cutVer = TCaplusListElementMoveReplaceReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListElementMoveReplaceReqBaseVersion {
		return errors.New("TCaplusListElementMoveReplaceReq cut version must large than TCaplusListElementMoveReplaceReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListElementMoveReplaceReq.ElementIndex pack error\n" + err.Error())
	}

	err = this.ElementValueInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusListElementMoveReplaceReq.ElementValueInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListElementMoveReplaceReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListElementMoveReplaceReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListElementMoveReplaceReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListElementMoveReplaceReqCurrentVersion {
		cutVer = TCaplusListElementMoveReplaceReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusListElementMoveReplaceReqBaseVersion {
		errors.New("TCaplusListElementMoveReplaceReq cut version must large than TCaplusListElementMoveReplaceReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.ElementIndex)
	if err != nil {
		return errors.New("TCaplusListElementMoveReplaceReq.ElementIndex unpack error\n" + err.Error())
	}

	err = this.ElementValueInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusListElementMoveReplaceReq.ElementValueInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusListElementMoveReplaceResBaseVersion    uint32 = 112
	TCaplusListElementMoveReplaceResCurrentVersion uint32 = 112
)

// TCaplusListElementMoveReplaceRes
type TCaplusListElementMoveReplaceRes struct {
	Result int32 `tdr_field:"Result"`
}

func NewTCaplusListElementMoveReplaceRes() *TCaplusListElementMoveReplaceRes {
	obj := new(TCaplusListElementMoveReplaceRes)
	obj.Init()
	return obj
}

func (this *TCaplusListElementMoveReplaceRes) GetBaseVersion() uint32 {
	return TCaplusListElementMoveReplaceResBaseVersion
}

func (this *TCaplusListElementMoveReplaceRes) GetCurrentVersion() uint32 {
	return TCaplusListElementMoveReplaceResCurrentVersion
}

func (this *TCaplusListElementMoveReplaceRes) Init() {

}

func (this *TCaplusListElementMoveReplaceRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusListElementMoveReplaceRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusListElementMoveReplaceRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusListElementMoveReplaceResCurrentVersion {
		cutVer = TCaplusListElementMoveReplaceResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusListElementMoveReplaceResBaseVersion {
		return errors.New("TCaplusListElementMoveReplaceRes cut version must large than TCaplusListElementMoveReplaceResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusListElementMoveReplaceRes.Result pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusListElementMoveReplaceRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusListElementMoveReplaceRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusListElementMoveReplaceRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusListElementMoveReplaceResCurrentVersion {
		cutVer = TCaplusListElementMoveReplaceResCurrentVersion
	}
	// check version
	if cutVer < TCaplusListElementMoveReplaceResBaseVersion {
		errors.New("TCaplusListElementMoveReplaceRes cut version must large than TCaplusListElementMoveReplaceResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusListElementMoveReplaceRes.Result unpack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusSqlReqBaseVersion    uint32 = 117
	TCaplusSqlReqCurrentVersion uint32 = 117
)

// TCaplusSqlReq
type TCaplusSqlReq struct {
	Version int32 `tdr_field:"Version"`

	Sql string `tdr_field:"Sql"`
}

func NewTCaplusSqlReq() *TCaplusSqlReq {
	obj := new(TCaplusSqlReq)
	obj.Init()
	return obj
}

func (this *TCaplusSqlReq) GetBaseVersion() uint32 {
	return TCaplusSqlReqBaseVersion
}

func (this *TCaplusSqlReq) GetCurrentVersion() uint32 {
	return TCaplusSqlReqCurrentVersion
}

func (this *TCaplusSqlReq) Init() {
	this.Version = 1

}

func (this *TCaplusSqlReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSqlReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSqlReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSqlReqCurrentVersion {
		cutVer = TCaplusSqlReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSqlReqBaseVersion {
		return errors.New("TCaplusSqlReq cut version must large than TCaplusSqlReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusSqlReq.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Sql))+1)
	if err != nil {
		return errors.New("TCaplusSqlReq.Sql string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Sql), 0))
	if err != nil {
		return errors.New("TCaplusSqlReq.Sql string content pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusSqlReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSqlReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSqlReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSqlReqCurrentVersion {
		cutVer = TCaplusSqlReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusSqlReqBaseVersion {
		errors.New("TCaplusSqlReq cut version must large than TCaplusSqlReqBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusSqlReq.Version unpack error\n" + err.Error())
	}

	var SqlSize uint32
	err = binary.Read(r, binary.BigEndian, &SqlSize)
	if err != nil {
		return errors.New("TCaplusSqlReq.Sql string size unpack error\n" + err.Error())
	}

	SqlBytes := make([]byte, SqlSize)
	err = binary.Read(r, binary.BigEndian, SqlBytes)
	if err != nil {
		return errors.New("TCaplusSqlReq.Sql string content unpack error\n" + err.Error())
	}
	this.Sql = string(SqlBytes[:len(SqlBytes)-1])

	return err
}

const (
	TCaplusSqlResBaseVersion    uint32 = 117
	TCaplusSqlResCurrentVersion uint32 = 117
)

// TCaplusSqlRes
type TCaplusSqlRes struct {
	Result int32 `tdr_field:"Result"`

	IsCompleteFlag int32 `tdr_field:"IsCompleteFlag"`

	Version int32 `tdr_field:"Version"`

	SqlType int32 `tdr_field:"SqlType"`

	RecordNum uint32 `tdr_field:"RecordNum"`

	ValueLen int32 `tdr_field:"ValueLen"`

	Value []byte `tdr_field:"Value" tdr_count:"10300000" tdr_refer:"ValueLen"`
}

func NewTCaplusSqlRes() *TCaplusSqlRes {
	obj := new(TCaplusSqlRes)
	obj.Init()
	return obj
}

func (this *TCaplusSqlRes) GetBaseVersion() uint32 {
	return TCaplusSqlResBaseVersion
}

func (this *TCaplusSqlRes) GetCurrentVersion() uint32 {
	return TCaplusSqlResCurrentVersion
}

func (this *TCaplusSqlRes) Init() {

	this.IsCompleteFlag = 1

	this.Version = 1

	this.SqlType = 0

	this.RecordNum = 0

	this.ValueLen = 0

}

func (this *TCaplusSqlRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusSqlRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusSqlRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusSqlResCurrentVersion {
		cutVer = TCaplusSqlResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusSqlResBaseVersion {
		return errors.New("TCaplusSqlRes cut version must large than TCaplusSqlResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusSqlRes.Result pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusSqlRes.IsCompleteFlag pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Version)
	if err != nil {
		return errors.New("TCaplusSqlRes.Version pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SqlType)
	if err != nil {
		return errors.New("TCaplusSqlRes.SqlType pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RecordNum)
	if err != nil {
		return errors.New("TCaplusSqlRes.RecordNum pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.ValueLen)
	if err != nil {
		return errors.New("TCaplusSqlRes.ValueLen pack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusSqlRes.Value's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusSqlRes.Value's refer ValueLen should <= count 10300000")
	}
	if len(this.Value) < int(this.ValueLen) {
		return errors.New("TCaplusSqlRes.Value's length should > ValueLen")
	}
	if this.ValueLen > 0 {
		referValue := this.Value[:this.ValueLen]
		err = binary.Write(w, binary.BigEndian, referValue)
		if err != nil {
			return errors.New("TCaplusSqlRes.Value pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *TCaplusSqlRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusSqlRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusSqlRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusSqlResCurrentVersion {
		cutVer = TCaplusSqlResCurrentVersion
	}
	// check version
	if cutVer < TCaplusSqlResBaseVersion {
		errors.New("TCaplusSqlRes cut version must large than TCaplusSqlResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusSqlRes.Result unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.IsCompleteFlag)
	if err != nil {
		return errors.New("TCaplusSqlRes.IsCompleteFlag unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Version)
	if err != nil {
		return errors.New("TCaplusSqlRes.Version unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SqlType)
	if err != nil {
		return errors.New("TCaplusSqlRes.SqlType unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RecordNum)
	if err != nil {
		return errors.New("TCaplusSqlRes.RecordNum unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.ValueLen)
	if err != nil {
		return errors.New("TCaplusSqlRes.ValueLen unpack error\n" + err.Error())
	}

	if this.ValueLen < 0 {
		return errors.New("TCaplusSqlRes.Value's refer ValueLen should >= 0")
	}
	if this.ValueLen > 10300000 {
		return errors.New("TCaplusSqlRes.Value's refer ValueLen should <= count 10300000")
	}

	if this.Value == nil {
		this.Value = make([]byte, int(this.ValueLen))
	}

	referValue := this.Value[:this.ValueLen]
	err = binary.Read(r, binary.BigEndian, referValue)
	if err != nil {
		return errors.New("TCaplusSqlRes.Value pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusGetForSqlQueryReqBaseVersion    uint32 = 117
	TCaplusGetForSqlQueryReqCurrentVersion uint32 = 117
)

// TCaplusGetForSqlQueryReq
type TCaplusGetForSqlQueryReq struct {
	Sql string `tdr_field:"Sql"`
}

func NewTCaplusGetForSqlQueryReq() *TCaplusGetForSqlQueryReq {
	obj := new(TCaplusGetForSqlQueryReq)
	obj.Init()
	return obj
}

func (this *TCaplusGetForSqlQueryReq) GetBaseVersion() uint32 {
	return TCaplusGetForSqlQueryReqBaseVersion
}

func (this *TCaplusGetForSqlQueryReq) GetCurrentVersion() uint32 {
	return TCaplusGetForSqlQueryReqCurrentVersion
}

func (this *TCaplusGetForSqlQueryReq) Init() {

}

func (this *TCaplusGetForSqlQueryReq) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetForSqlQueryReq Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetForSqlQueryReq) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetForSqlQueryReqCurrentVersion {
		cutVer = TCaplusGetForSqlQueryReqCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetForSqlQueryReqBaseVersion {
		return errors.New("TCaplusGetForSqlQueryReq cut version must large than TCaplusGetForSqlQueryReqBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, uint32(len(this.Sql))+1)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryReq.Sql string size pack error\n" + err.Error())
	}
	err = binary.Write(w, binary.BigEndian, append([]byte(this.Sql), 0))
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryReq.Sql string content pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetForSqlQueryReq) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetForSqlQueryReq data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetForSqlQueryReq) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetForSqlQueryReqCurrentVersion {
		cutVer = TCaplusGetForSqlQueryReqCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetForSqlQueryReqBaseVersion {
		errors.New("TCaplusGetForSqlQueryReq cut version must large than TCaplusGetForSqlQueryReqBaseVersion\n")
	}

	var SqlSize uint32
	err = binary.Read(r, binary.BigEndian, &SqlSize)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryReq.Sql string size unpack error\n" + err.Error())
	}

	SqlBytes := make([]byte, SqlSize)
	err = binary.Read(r, binary.BigEndian, SqlBytes)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryReq.Sql string content unpack error\n" + err.Error())
	}
	this.Sql = string(SqlBytes[:len(SqlBytes)-1])

	return err
}

const (
	TCaplusGetForSqlQueryResBaseVersion    uint32 = 117
	TCaplusGetForSqlQueryResCurrentVersion uint32 = 117
)

// TCaplusGetForSqlQueryRes
type TCaplusGetForSqlQueryRes struct {
	Result int32 `tdr_field:"Result"`

	ResultInfo *TCaplusValueSet_ `tdr_field:"ResultInfo"`
}

func NewTCaplusGetForSqlQueryRes() *TCaplusGetForSqlQueryRes {
	obj := new(TCaplusGetForSqlQueryRes)
	obj.Init()
	return obj
}

func (this *TCaplusGetForSqlQueryRes) GetBaseVersion() uint32 {
	return TCaplusGetForSqlQueryResBaseVersion
}

func (this *TCaplusGetForSqlQueryRes) GetCurrentVersion() uint32 {
	return TCaplusGetForSqlQueryResCurrentVersion
}

func (this *TCaplusGetForSqlQueryRes) Init() {

	this.ResultInfo = NewTCaplusValueSet_()

}

func (this *TCaplusGetForSqlQueryRes) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusGetForSqlQueryRes Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusGetForSqlQueryRes) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusGetForSqlQueryResCurrentVersion {
		cutVer = TCaplusGetForSqlQueryResCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusGetForSqlQueryResBaseVersion {
		return errors.New("TCaplusGetForSqlQueryRes cut version must large than TCaplusGetForSqlQueryResBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.Result)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryRes.Result pack error\n" + err.Error())
	}

	err = this.ResultInfo.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryRes.ResultInfo pack error\n" + err.Error())
	}

	return nil
}

func (this *TCaplusGetForSqlQueryRes) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusGetForSqlQueryRes data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusGetForSqlQueryRes) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusGetForSqlQueryResCurrentVersion {
		cutVer = TCaplusGetForSqlQueryResCurrentVersion
	}
	// check version
	if cutVer < TCaplusGetForSqlQueryResBaseVersion {
		errors.New("TCaplusGetForSqlQueryRes cut version must large than TCaplusGetForSqlQueryResBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.Result)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryRes.Result unpack error\n" + err.Error())
	}

	err = this.ResultInfo.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusGetForSqlQueryRes.ResultInfo unpack error\n" + err.Error())
	}

	return err
}

const (
	ProxyCacheRequestInfoBaseVersion                  uint32 = 87
	ProxyCacheRequestInfoCurrentVersion               uint32 = 108
	ProxyCacheRequestInfoProxyFrontForwardTimeVersion uint32 = 108
)

// ProxyCacheRequestInfo
type ProxyCacheRequestInfo struct {
	KeyCode uint32 `tdr_field:"KeyCode"`

	Token uint64 `tdr_field:"Token"`

	RouterHashCode uint32 `tdr_field:"RouterHashCode"`

	OrigineCmd uint32 `tdr_field:"OrigineCmd"`

	SubCmd uint32 `tdr_field:"SubCmd"`

	ProxyFrontForwardTime uint64 `tdr_field:"ProxyFrontForwardTime"`

	SwiftHeadLen uint32 `tdr_field:"SwiftHeadLen"`

	SwiftHead []byte `tdr_field:"SwiftHead" tdr_count:"1024" tdr_refer:"SwiftHeadLen"`

	RequestBufferLen uint32 `tdr_field:"RequestBufferLen"`

	RequestBuffer []byte `tdr_field:"RequestBuffer" tdr_count:"13000000" tdr_refer:"RequestBufferLen"`
}

func NewProxyCacheRequestInfo() *ProxyCacheRequestInfo {
	obj := new(ProxyCacheRequestInfo)
	obj.Init()
	return obj
}

func (this *ProxyCacheRequestInfo) GetBaseVersion() uint32 {
	return ProxyCacheRequestInfoBaseVersion
}

func (this *ProxyCacheRequestInfo) GetCurrentVersion() uint32 {
	return ProxyCacheRequestInfoCurrentVersion
}

func (this *ProxyCacheRequestInfo) Init() {
	this.KeyCode = 0

	this.Token = 0

	this.RouterHashCode = 0

	this.OrigineCmd = 0

	this.SubCmd = 0

	this.SwiftHeadLen = 0

	this.RequestBufferLen = 0

}

func (this *ProxyCacheRequestInfo) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("ProxyCacheRequestInfo Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *ProxyCacheRequestInfo) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > ProxyCacheRequestInfoCurrentVersion {
		cutVer = ProxyCacheRequestInfoCurrentVersion
	}
	// check cut version
	if cutVer < ProxyCacheRequestInfoBaseVersion {
		return errors.New("ProxyCacheRequestInfo cut version must large than ProxyCacheRequestInfoBaseVersion\n")
	}

	var err error

	err = binary.Write(w, binary.BigEndian, this.KeyCode)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.KeyCode pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.Token)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.Token pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.RouterHashCode)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.RouterHashCode pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.OrigineCmd)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.OrigineCmd pack error\n" + err.Error())
	}

	err = binary.Write(w, binary.BigEndian, this.SubCmd)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.SubCmd pack error\n" + err.Error())
	}

	if cutVer >= ProxyCacheRequestInfoProxyFrontForwardTimeVersion {

		err = binary.Write(w, binary.BigEndian, this.ProxyFrontForwardTime)
		if err != nil {
			return errors.New("ProxyCacheRequestInfo.ProxyFrontForwardTime pack error\n" + err.Error())
		}

	}

	err = binary.Write(w, binary.BigEndian, this.SwiftHeadLen)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.SwiftHeadLen pack error\n" + err.Error())
	}

	if this.SwiftHeadLen < 0 {
		return errors.New("ProxyCacheRequestInfo.SwiftHead's refer SwiftHeadLen should >= 0")
	}
	if this.SwiftHeadLen > 1024 {
		return errors.New("ProxyCacheRequestInfo.SwiftHead's refer SwiftHeadLen should <= count 1024")
	}
	if len(this.SwiftHead) < int(this.SwiftHeadLen) {
		return errors.New("ProxyCacheRequestInfo.SwiftHead's length should > SwiftHeadLen")
	}
	if this.SwiftHeadLen > 0 {
		referSwiftHead := this.SwiftHead[:this.SwiftHeadLen]
		err = binary.Write(w, binary.BigEndian, referSwiftHead)
		if err != nil {
			return errors.New("ProxyCacheRequestInfo.SwiftHead pack error\n" + err.Error())
		}
	}

	err = binary.Write(w, binary.BigEndian, this.RequestBufferLen)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.RequestBufferLen pack error\n" + err.Error())
	}

	if this.RequestBufferLen < 0 {
		return errors.New("ProxyCacheRequestInfo.RequestBuffer's refer RequestBufferLen should >= 0")
	}
	if this.RequestBufferLen > 13000000 {
		return errors.New("ProxyCacheRequestInfo.RequestBuffer's refer RequestBufferLen should <= count 13000000")
	}
	if len(this.RequestBuffer) < int(this.RequestBufferLen) {
		return errors.New("ProxyCacheRequestInfo.RequestBuffer's length should > RequestBufferLen")
	}
	if this.RequestBufferLen > 0 {
		referRequestBuffer := this.RequestBuffer[:this.RequestBufferLen]
		err = binary.Write(w, binary.BigEndian, referRequestBuffer)
		if err != nil {
			return errors.New("ProxyCacheRequestInfo.RequestBuffer pack error\n" + err.Error())
		}
	}

	return nil
}

func (this *ProxyCacheRequestInfo) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("ProxyCacheRequestInfo data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *ProxyCacheRequestInfo) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > ProxyCacheRequestInfoCurrentVersion {
		cutVer = ProxyCacheRequestInfoCurrentVersion
	}
	// check version
	if cutVer < ProxyCacheRequestInfoBaseVersion {
		errors.New("ProxyCacheRequestInfo cut version must large than ProxyCacheRequestInfoBaseVersion\n")
	}

	err = binary.Read(r, binary.BigEndian, &this.KeyCode)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.KeyCode unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.Token)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.Token unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RouterHashCode)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.RouterHashCode unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.OrigineCmd)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.OrigineCmd unpack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.SubCmd)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.SubCmd unpack error\n" + err.Error())
	}

	if cutVer >= ProxyCacheRequestInfoProxyFrontForwardTimeVersion {

		err = binary.Read(r, binary.BigEndian, &this.ProxyFrontForwardTime)
		if err != nil {
			return errors.New("ProxyCacheRequestInfo.ProxyFrontForwardTime unpack error\n" + err.Error())
		}

	}

	err = binary.Read(r, binary.BigEndian, &this.SwiftHeadLen)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.SwiftHeadLen unpack error\n" + err.Error())
	}

	if this.SwiftHeadLen < 0 {
		return errors.New("ProxyCacheRequestInfo.SwiftHead's refer SwiftHeadLen should >= 0")
	}
	if this.SwiftHeadLen > 1024 {
		return errors.New("ProxyCacheRequestInfo.SwiftHead's refer SwiftHeadLen should <= count 1024")
	}

	if this.SwiftHead == nil {
		this.SwiftHead = make([]byte, int(this.SwiftHeadLen))
	}

	referSwiftHead := this.SwiftHead[:this.SwiftHeadLen]
	err = binary.Read(r, binary.BigEndian, referSwiftHead)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.SwiftHead pack error\n" + err.Error())
	}

	err = binary.Read(r, binary.BigEndian, &this.RequestBufferLen)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.RequestBufferLen unpack error\n" + err.Error())
	}

	if this.RequestBufferLen < 0 {
		return errors.New("ProxyCacheRequestInfo.RequestBuffer's refer RequestBufferLen should >= 0")
	}
	if this.RequestBufferLen > 13000000 {
		return errors.New("ProxyCacheRequestInfo.RequestBuffer's refer RequestBufferLen should <= count 13000000")
	}

	if this.RequestBuffer == nil {
		this.RequestBuffer = make([]byte, int(this.RequestBufferLen))
	}

	referRequestBuffer := this.RequestBuffer[:this.RequestBufferLen]
	err = binary.Read(r, binary.BigEndian, referRequestBuffer)
	if err != nil {
		return errors.New("ProxyCacheRequestInfo.RequestBuffer pack error\n" + err.Error())
	}

	return err
}

const (
	TCaplusPkgBodyBaseVersion                            uint32 = 1
	TCaplusPkgBodyCurrentVersion                         uint32 = 117
	TCaplusPkgBodySysGetReqVersion                       uint32 = 53
	TCaplusPkgBodySysGetResVersion                       uint32 = 53
	TCaplusPkgBodySysDeleteReqVersion                    uint32 = 53
	TCaplusPkgBodySysDeleteResVersion                    uint32 = 53
	TCaplusPkgBodyListDeleteBatchReqVersion              uint32 = 10
	TCaplusPkgBodyListDeleteBatchResVersion              uint32 = 10
	TCaplusPkgBodySysListDeleteReqVersion                uint32 = 53
	TCaplusPkgBodySysListDeleteResVersion                uint32 = 53
	TCaplusPkgBodyUpdateByPartkeyReqVersion              uint32 = 41
	TCaplusPkgBodyUpdateByPartkeyResVersion              uint32 = 41
	TCaplusPkgBodyDeleteByPartkeyReqVersion              uint32 = 41
	TCaplusPkgBodyDeleteByPartkeyResVersion              uint32 = 41
	TCaplusPkgBodyInsertByPartKeyReqVersion              uint32 = 50
	TCaplusPkgBodyInsertByPartKeyResVersion              uint32 = 50
	TCaplusPkgBodyMsSyncInsertReqVersion                 uint32 = 3
	TCaplusPkgBodyMsSyncInsertResVersion                 uint32 = 3
	TCaplusPkgBodyMsSyncReplaceReqVersion                uint32 = 3
	TCaplusPkgBodyMsSyncReplaceResVersion                uint32 = 3
	TCaplusPkgBodyMsSyncDeleteReqVersion                 uint32 = 3
	TCaplusPkgBodyMsSyncDeleteResVersion                 uint32 = 3
	TCaplusPkgBodyMsSyncUpdateReqVersion                 uint32 = 3
	TCaplusPkgBodyMsSyncUpdateResVersion                 uint32 = 3
	TCaplusPkgBodyListMsSyncDeleteAllReqVersion          uint32 = 3
	TCaplusPkgBodyListMsSyncDeleteAllResVersion          uint32 = 3
	TCaplusPkgBodyListMsSyncAddAfterReqVersion           uint32 = 3
	TCaplusPkgBodyListMsSyncAddAfterResVersion           uint32 = 3
	TCaplusPkgBodyListMsSyncDeleteReqVersion             uint32 = 3
	TCaplusPkgBodyListMsSyncDeleteResVersion             uint32 = 3
	TCaplusPkgBodyListMsSyncReplaceReqVersion            uint32 = 3
	TCaplusPkgBodyListMsSyncReplaceResVersion            uint32 = 3
	TCaplusPkgBodyAppSignupReqVersion                    uint32 = 7
	TCaplusPkgBodyAppSignupResVersion                    uint32 = 7
	TCaplusPkgBodyHeartBeatReqVersion                    uint32 = 7
	TCaplusPkgBodyHeartBeatResVersion                    uint32 = 7
	TCaplusPkgBodyPrepareMoveReqVersion                  uint32 = 8
	TCaplusPkgBodyPrepareMoveResVersion                  uint32 = 8
	TCaplusPkgBodyFinishMoveReqVersion                   uint32 = 8
	TCaplusPkgBodyFinishMoveResVersion                   uint32 = 8
	TCaplusPkgBodyListIndexMoveInsertReqVersion          uint32 = 8
	TCaplusPkgBodyListIndexMoveInsertResVersion          uint32 = 8
	TCaplusPkgBodyListElemMoveInsertReqVersion           uint32 = 8
	TCaplusPkgBodyListElemMoveInsertResVersion           uint32 = 8
	TCaplusPkgBodyGetShardListReqVersion                 uint32 = 12
	TCaplusPkgBodyGetShardListResVersion                 uint32 = 12
	TCaplusPkgBodyTableTraverseReqVersion                uint32 = 12
	TCaplusPkgBodyTableTraverseResVersion                uint32 = 12
	TCaplusPkgBodyBatchGetByPartkeyReqVersion            uint32 = 39
	TCaplusPkgBodyBatchGetByPartkeyResVersion            uint32 = 39
	TCaplusPkgBodyTCaplusDocumentOperationReqVersion     uint32 = 40
	TCaplusPkgBodyTCaplusDocumentOperationResVersion     uint32 = 40
	TCaplusPkgBodyGetTableRecordCountReqVersion          uint32 = 51
	TCaplusPkgBodyGetTableRecordCountResVersion          uint32 = 51
	TCaplusPkgBodyHttpGenericReqVersion                  uint32 = 54
	TCaplusPkgBodyHttpGenericResVersion                  uint32 = 54
	TCaplusPkgBodyListTableTraverseReqVersion            uint32 = 55
	TCaplusPkgBodyListTableTraverseResVersion            uint32 = 55
	TCaplusPkgBodySysListGetReqVersion                   uint32 = 55
	TCaplusPkgBodySysListGetResVersion                   uint32 = 55
	TCaplusPkgBodySysListGetAllReqVersion                uint32 = 55
	TCaplusPkgBodySysListGetAllResVersion                uint32 = 55
	TCaplusPkgBodyGetDuringMoveReqVersion                uint32 = 57
	TCaplusPkgBodyGetDuringMoveResVersion                uint32 = 57
	TCaplusPkgBodyGetDuringMoveFromSrcReqVersion         uint32 = 57
	TCaplusPkgBodyGetDuringMoveFromSrcResVersion         uint32 = 57
	TCaplusPkgBodyNegotiateVersionReqVersion             uint32 = 57
	TCaplusPkgBodyNegotiateVersionResVersion             uint32 = 57
	TCaplusPkgBodyCheckConnectDuringMoveReqVersion       uint32 = 57
	TCaplusPkgBodyCheckConnectDuringMoveResVersion       uint32 = 57
	TCaplusPkgBodyMsSyncDataExpireDeleteReqVersion       uint32 = 58
	TCaplusPkgBodyMsSyncDataExpireDeleteResVersion       uint32 = 58
	TCaplusPkgBodyMsSyncDataMoveDeleteReqVersion         uint32 = 58
	TCaplusPkgBodyMsSyncDataMoveDeleteResVersion         uint32 = 58
	TCaplusPkgBodyListMsSyncDataExpireDeleteReqVersion   uint32 = 58
	TCaplusPkgBodyListMsSyncDataExpireDeleteResVersion   uint32 = 58
	TCaplusPkgBodyTCaplusPbFieldGetReqVersion            uint32 = 78
	TCaplusPkgBodyTCaplusPbFieldGetResVersion            uint32 = 78
	TCaplusPkgBodyTCaplusPbFieldUpdateReqVersion         uint32 = 78
	TCaplusPkgBodyTCaplusPbFieldUpdateResVersion         uint32 = 78
	TCaplusPkgBodyTCaplusPbFieldIncReqVersion            uint32 = 78
	TCaplusPkgBodyTCaplusPbFieldIncResVersion            uint32 = 78
	TCaplusPkgBodyMsSyncGetReqVersion                    uint32 = 85
	TCaplusPkgBodyMsSyncGetResVersion                    uint32 = 85
	TCaplusPkgBodyListMsSyncGetReqVersion                uint32 = 85
	TCaplusPkgBodyListMsSyncGetResVersion                uint32 = 85
	TCaplusPkgBodyListMsSyncGetAllReqVersion             uint32 = 85
	TCaplusPkgBodyListMsSyncGetAllResVersion             uint32 = 85
	TCaplusPkgBodyMsSyncPartkeyGetReqVersion             uint32 = 85
	TCaplusPkgBodyMsSyncPartkeyGetResVersion             uint32 = 85
	TCaplusPkgBodySysMakeConsistReqVersion               uint32 = 86
	TCaplusPkgBodySysMakeConsistResVersion               uint32 = 86
	TCaplusPkgBodySysListMakeConsistReqVersion           uint32 = 86
	TCaplusPkgBodySysListMakeConsistResVersion           uint32 = 86
	TCaplusPkgBodyLosslessMoveReplaceReqVersion          uint32 = 87
	TCaplusPkgBodyLosslessMoveReplaceResVersion          uint32 = 87
	TCaplusPkgBodyLosslessMoveListIndexReplaceReqVersion uint32 = 87
	TCaplusPkgBodyLosslessMoveListIndexReplaceResVersion uint32 = 87
	TCaplusPkgBodyLosslessMoveListElemReplaceReqVersion  uint32 = 87
	TCaplusPkgBodyLosslessMoveListElemReplaceResVersion  uint32 = 87
	TCaplusPkgBodyTCaplusPbBatchFieldGetReqVersion       uint32 = 102
	TCaplusPkgBodyTCaplusPbBatchFieldGetResVersion       uint32 = 102
	TCaplusPkgBodyListIndexMoveReplaceReqVersion         uint32 = 112
	TCaplusPkgBodyListIndexMoveReplaceResVersion         uint32 = 112
	TCaplusPkgBodyListElementMoveReplaceReqVersion       uint32 = 112
	TCaplusPkgBodyListElementMoveReplaceResVersion       uint32 = 112
	TCaplusPkgBodyTCaplusSqlReqVersion                   uint32 = 117
	TCaplusPkgBodyTCaplusSqlResVersion                   uint32 = 117
	TCaplusPkgBodyTCaplusGetForSqlQueryReqVersion        uint32 = 117
	TCaplusPkgBodyTCaplusGetForSqlQueryResVersion        uint32 = 117
)

// TCaplusPkgBody
type TCaplusPkgBody struct {
	InsertReq *TCaplusInsertReq `tdr_field:"InsertReq"`

	InsertRes *TCaplusInsertRes `tdr_field:"InsertRes"`

	ReplaceReq *TCaplusReplaceReq `tdr_field:"ReplaceReq"`

	ReplaceRes *TCaplusReplaceRes `tdr_field:"ReplaceRes"`

	UpdateReq *TCaplusReplaceReq `tdr_field:"UpdateReq"`

	UpdateRes *TCaplusReplaceRes `tdr_field:"UpdateRes"`

	IncreaseReq *TCaplusIncreaseReq `tdr_field:"IncreaseReq"`

	IncreaseRes *TCaplusIncreaseRes `tdr_field:"IncreaseRes"`

	GetReq *TCaplusGetReq `tdr_field:"GetReq"`

	GetRes *TCaplusGetRes `tdr_field:"GetRes"`

	SysGetReq *TCaplusSysGetReq `tdr_field:"SysGetReq"`

	SysGetRes *TCaplusSysGetRes `tdr_field:"SysGetRes"`

	DeleteReq *TCaplusDeleteReq `tdr_field:"DeleteReq"`

	DeleteRes *TCaplusDeleteRes `tdr_field:"DeleteRes"`

	SysDeleteReq *TCaplusSysDeleteReq `tdr_field:"SysDeleteReq"`

	SysDeleteRes *TCaplusSysDeleteRes `tdr_field:"SysDeleteRes"`

	BatchGetReq *TCaplusBatchGetReq `tdr_field:"BatchGetReq"`

	BatchGetRes *TCaplusBatchGetRes `tdr_field:"BatchGetRes"`

	ListGetAllReq *TCaplusListGetAllReq `tdr_field:"ListGetAllReq"`

	ListGetAllRes *TCaplusListGetAllRes `tdr_field:"ListGetAllRes"`

	ListDeleteAllReq *TCaplusListDeleteAllReq `tdr_field:"ListDeleteAllReq"`

	ListDeleteAllRes *TCaplusListDeleteAllRes `tdr_field:"ListDeleteAllRes"`

	ListDeleteBatchReq *TCaplusListDeleteBatchReq `tdr_field:"ListDeleteBatchReq"`

	ListDeleteBatchRes *TCaplusListDeleteBatchRes `tdr_field:"ListDeleteBatchRes"`

	ListGetReq *TCaplusListGetReq `tdr_field:"ListGetReq"`

	ListGetRes *TCaplusListGetRes `tdr_field:"ListGetRes"`

	ListAddAfterReq *TCaplusListAddAfterReq `tdr_field:"ListAddAfterReq"`

	ListAddAfterRes *TCaplusListAddAfterRes `tdr_field:"ListAddAfterRes"`

	ListDeleteReq *TCaplusListDeleteReq `tdr_field:"ListDeleteReq"`

	ListDeleteRes *TCaplusListDeleteRes `tdr_field:"ListDeleteRes"`

	SysListDeleteReq *TCaplusSysListDeleteReq `tdr_field:"SysListDeleteReq"`

	SysListDeleteRes *TCaplusSysListDeleteRes `tdr_field:"SysListDeleteRes"`

	ListReplaceReq *TCaplusListReplaceReq `tdr_field:"ListReplaceReq"`

	ListReplaceRes *TCaplusListReplaceRes `tdr_field:"ListReplaceRes"`

	GetByPartKeyReq *TCaplusGetByPartKeyReq `tdr_field:"GetByPartKeyReq"`

	GetByPartKeyRes *TCaplusGetByPartKeyRes `tdr_field:"GetByPartKeyRes"`

	UpdateByPartkeyReq *TCaplusUpdateByPartkeyReq `tdr_field:"UpdateByPartkeyReq"`

	UpdateByPartkeyRes *TCaplusUpdateByPartkeyRes `tdr_field:"UpdateByPartkeyRes"`

	DeleteByPartkeyReq *TCaplusDeleteByPartkeyReq `tdr_field:"DeleteByPartkeyReq"`

	DeleteByPartkeyRes *TCaplusDeleteByPartkeyRes `tdr_field:"DeleteByPartkeyRes"`

	InsertByPartKeyReq *TCaplusInsertByPartKeyReq `tdr_field:"InsertByPartKeyReq"`

	InsertByPartKeyRes *TCaplusInsertByPartKeyRes `tdr_field:"InsertByPartKeyRes"`

	MetadataGetReq *TCaplusMetadataGetReq `tdr_field:"MetadataGetReq"`

	MetadataGetRes *TCaplusMetadataGetRes `tdr_field:"MetadataGetRes"`

	SpecialGetReq *TCaplusSpecialGetReq `tdr_field:"SpecialGetReq"`

	SpecialGetRes *TCaplusSpecialGetRes `tdr_field:"SpecialGetRes"`

	MoveInsertReq *TCaplusMoveInsertReq `tdr_field:"MoveInsertReq"`

	MoveInsertRes *TCaplusMoveInsertRes `tdr_field:"MoveInsertRes"`

	MsSyncInsertReq *TCaplusMsSyncInsertReq `tdr_field:"MsSyncInsertReq"`

	MsSyncInsertRes *TCaplusMsSyncInsertRes `tdr_field:"MsSyncInsertRes"`

	MsSyncReplaceReq *TCaplusMsSyncReplaceReq `tdr_field:"MsSyncReplaceReq"`

	MsSyncReplaceRes *TCaplusMsSyncReplaceRes `tdr_field:"MsSyncReplaceRes"`

	MsSyncDeleteReq *TCaplusMsSyncDeleteReq `tdr_field:"MsSyncDeleteReq"`

	MsSyncDeleteRes *TCaplusMsSyncDeleteRes `tdr_field:"MsSyncDeleteRes"`

	MsSyncUpdateReq *TCaplusMsSyncUpdateReq `tdr_field:"MsSyncUpdateReq"`

	MsSyncUpdateRes *TCaplusMsSyncUpdateRes `tdr_field:"MsSyncUpdateRes"`

	ListMsSyncDeleteAllReq *TCaplusListMsSyncDeleteAllReq `tdr_field:"ListMsSyncDeleteAllReq"`

	ListMsSyncDeleteAllRes *TCaplusListMsSyncDeleteAllRes `tdr_field:"ListMsSyncDeleteAllRes"`

	ListMsSyncAddAfterReq *TCaplusListMsSyncAddAfterReq `tdr_field:"ListMsSyncAddAfterReq"`

	ListMsSyncAddAfterRes *TCaplusListMsSyncAddAfterRes `tdr_field:"ListMsSyncAddAfterRes"`

	ListMsSyncDeleteReq *TCaplusListMsSyncDeleteReq `tdr_field:"ListMsSyncDeleteReq"`

	ListMsSyncDeleteRes *TCaplusListMsSyncDeleteRes `tdr_field:"ListMsSyncDeleteRes"`

	ListMsSyncReplaceReq *TCaplusListMsSyncReplaceReq `tdr_field:"ListMsSyncReplaceReq"`

	ListMsSyncReplaceRes *TCaplusListMsSyncReplaceRes `tdr_field:"ListMsSyncReplaceRes"`

	AppSignupReq *TCaplusAppSignupReq `tdr_field:"AppSignupReq"`

	AppSignupRes *TCaplusAppSignupRes `tdr_field:"AppSignupRes"`

	HeartBeatReq *TCaplusHeartBeatReq `tdr_field:"HeartBeatReq"`

	HeartBeatRes *TCaplusHeartBeatRes `tdr_field:"HeartBeatRes"`

	PrepareMoveReq *TCaplusPrepareMoveReq `tdr_field:"PrepareMoveReq"`

	PrepareMoveRes *TCaplusPrepareMoveRes `tdr_field:"PrepareMoveRes"`

	FinishMoveReq *TCaplusFinishMoveReq `tdr_field:"FinishMoveReq"`

	FinishMoveRes *TCaplusFinishMoveRes `tdr_field:"FinishMoveRes"`

	ListCheckReq *TCaplusListCheckReq `tdr_field:"ListCheckReq"`

	ListCheckRes *TCaplusListCheckRes `tdr_field:"ListCheckRes"`

	ListIndexMoveInsertReq *TCaplusListIndexMoveInsertReq `tdr_field:"ListIndexMoveInsertReq"`

	ListIndexMoveInsertRes *TCaplusListIndexMoveInsertRes `tdr_field:"ListIndexMoveInsertRes"`

	ListElemMoveInsertReq *TCaplusListElemMoveInsertReq `tdr_field:"ListElemMoveInsertReq"`

	ListElemMoveInsertRes *TCaplusListElemMoveInsertRes `tdr_field:"ListElemMoveInsertRes"`

	GetShardListReq *TCaplusGetShardListReq `tdr_field:"GetShardListReq"`

	GetShardListRes *TCaplusGetShardListRes `tdr_field:"GetShardListRes"`

	TableTraverseReq *TCaplusTableTraverseReq `tdr_field:"TableTraverseReq"`

	TableTraverseRes *TCaplusTableTraverseRes `tdr_field:"TableTraverseRes"`

	BatchGetByPartkeyReq *TCaplusBatchGetByPartkeyReq `tdr_field:"BatchGetByPartkeyReq"`

	BatchGetByPartkeyRes *TCaplusBatchGetByPartkeyRes `tdr_field:"BatchGetByPartkeyRes"`

	TCaplusDocumentOperationReq *TCaplusDocumentOperationReq `tdr_field:"TCaplusDocumentOperationReq"`

	TCaplusDocumentOperationRes *TCaplusDocumentOperationRes `tdr_field:"TCaplusDocumentOperationRes"`

	GetTableRecordCountReq *TCaplusGetTableRecordCountReq `tdr_field:"GetTableRecordCountReq"`

	GetTableRecordCountRes *TCaplusGetTableRecordCountRes `tdr_field:"GetTableRecordCountRes"`

	HttpGenericReq *TCaplusHttpGenericReq `tdr_field:"HttpGenericReq"`

	HttpGenericRes *TCaplusHttpGenericRes `tdr_field:"HttpGenericRes"`

	ListTableTraverseReq *TCaplusListTableTraverseReq `tdr_field:"ListTableTraverseReq"`

	ListTableTraverseRes *TCaplusListTableTraverseRes `tdr_field:"ListTableTraverseRes"`

	SysListGetReq *TCaplusSysListGetReq `tdr_field:"SysListGetReq"`

	SysListGetRes *TCaplusSysListGetRes `tdr_field:"SysListGetRes"`

	SysListGetAllReq *TCaplusSysListGetAllReq `tdr_field:"SysListGetAllReq"`

	SysListGetAllRes *TCaplusSysListGetAllRes `tdr_field:"SysListGetAllRes"`

	GetDuringMoveReq *TCaplusGetDuringMoveReq `tdr_field:"GetDuringMoveReq"`

	GetDuringMoveRes *TCaplusGetDuringMoveRes `tdr_field:"GetDuringMoveRes"`

	GetDuringMoveFromSrcReq *TCaplusGetDuringMoveFromSrcReq `tdr_field:"GetDuringMoveFromSrcReq"`

	GetDuringMoveFromSrcRes *TCaplusGetDuringMoveFromSrcRes `tdr_field:"GetDuringMoveFromSrcRes"`

	NegotiateVersionReq *TCaplusNegotiateVersionReq `tdr_field:"NegotiateVersionReq"`

	NegotiateVersionRes *TCaplusNegotiateVersionRes `tdr_field:"NegotiateVersionRes"`

	CheckConnectDuringMoveReq *TCaplusCheckConnectDuringMoveReq `tdr_field:"CheckConnectDuringMoveReq"`

	CheckConnectDuringMoveRes *TCaplusCheckConnectDuringMoveRes `tdr_field:"CheckConnectDuringMoveRes"`

	MsSyncDataExpireDeleteReq *TCaplusMsSyncDeleteReq `tdr_field:"MsSyncDataExpireDeleteReq"`

	MsSyncDataExpireDeleteRes *TCaplusMsSyncDeleteRes `tdr_field:"MsSyncDataExpireDeleteRes"`

	MsSyncDataMoveDeleteReq *TCaplusMsSyncDeleteReq `tdr_field:"MsSyncDataMoveDeleteReq"`

	MsSyncDataMoveDeleteRes *TCaplusMsSyncDeleteRes `tdr_field:"MsSyncDataMoveDeleteRes"`

	ListMsSyncDataExpireDeleteReq *TCaplusListMsSyncDeleteReq `tdr_field:"ListMsSyncDataExpireDeleteReq"`

	ListMsSyncDataExpireDeleteRes *TCaplusListMsSyncDeleteRes `tdr_field:"ListMsSyncDataExpireDeleteRes"`

	TCaplusPbFieldGetReq *TCaplusProtobufFieldGetReq `tdr_field:"TCaplusPbFieldGetReq"`

	TCaplusPbFieldGetRes *TCaplusProtobufFieldGetRes `tdr_field:"TCaplusPbFieldGetRes"`

	TCaplusPbFieldUpdateReq *TCaplusProtobufFieldUpdateReq `tdr_field:"TCaplusPbFieldUpdateReq"`

	TCaplusPbFieldUpdateRes *TCaplusProtobufFieldUpdateRes `tdr_field:"TCaplusPbFieldUpdateRes"`

	TCaplusPbFieldIncReq *TCaplusProtobufFieldIncreaseReq `tdr_field:"TCaplusPbFieldIncReq"`

	TCaplusPbFieldIncRes *TCaplusProtobufFieldIncreaseRes `tdr_field:"TCaplusPbFieldIncRes"`

	MsSyncGetReq *TCaplusMsSyncGetReq `tdr_field:"MsSyncGetReq"`

	MsSyncGetRes *TCaplusMsSyncGetRes `tdr_field:"MsSyncGetRes"`

	ListMsSyncGetReq *TCaplusListMsSyncGetReq `tdr_field:"ListMsSyncGetReq"`

	ListMsSyncGetRes *TCaplusListMsSyncGetRes `tdr_field:"ListMsSyncGetRes"`

	ListMsSyncGetAllReq *TCaplusListMsSyncGetAllReq `tdr_field:"listMsSyncGetAllReq"`

	ListMsSyncGetAllRes *TCaplusListMsSyncGetAllRes `tdr_field:"listMsSyncGetAllRes"`

	MsSyncPartkeyGetReq *TCaplusMsSyncPartkeyGetReq `tdr_field:"MsSyncPartkeyGetReq"`

	MsSyncPartkeyGetRes *TCaplusMsSyncPartkeyGetRes `tdr_field:"MsSyncPartkeyGetRes"`

	SysMakeConsistReq *TCaplusSysMakeConsistReq `tdr_field:"SysMakeConsistReq"`

	SysMakeConsistRes *TCaplusSysMakeConsistRes `tdr_field:"SysMakeConsistRes"`

	SysListMakeConsistReq *TCaplusSysListMakeConsistReq `tdr_field:"SysListMakeConsistReq"`

	SysListMakeConsistRes *TCaplusSysListMakeConsistRes `tdr_field:"SysListMakeConsistRes"`

	LosslessMoveReplaceReq *TCaplusLosslessMoveReplaceReq `tdr_field:"LosslessMoveReplaceReq"`

	LosslessMoveReplaceRes *TCaplusLosslessMoveReplaceRes `tdr_field:"LosslessMoveReplaceRes"`

	LosslessMoveListIndexReplaceReq *TCaplusLosslessMoveListIndexReplaceReq `tdr_field:"LosslessMoveListIndexReplaceReq"`

	LosslessMoveListIndexReplaceRes *TCaplusLosslessMoveListIndexReplaceRes `tdr_field:"LosslessMoveListIndexReplaceRes"`

	LosslessMoveListElemReplaceReq *TCaplusLosslessMoveListElemReplaceReq `tdr_field:"LosslessMoveListElemReplaceReq"`

	LosslessMoveListElemReplaceRes *TCaplusLosslessMoveListElemReplaceRes `tdr_field:"LosslessMoveListElemReplaceRes"`

	TCaplusPbBatchFieldGetReq *TCaplusProtobufBatchFieldGetReq `tdr_field:"TCaplusPbBatchFieldGetReq"`

	TCaplusPbBatchFieldGetRes *TCaplusProtobufBatchFieldGetRes `tdr_field:"TCaplusPbBatchFieldGetRes"`

	ListIndexMoveReplaceReq *TCaplusListIndexMoveReplaceReq `tdr_field:"ListIndexMoveReplaceReq"`

	ListIndexMoveReplaceRes *TCaplusListIndexMoveReplaceRes `tdr_field:"ListIndexMoveReplaceRes"`

	ListElementMoveReplaceReq *TCaplusListElementMoveReplaceReq `tdr_field:"ListElementMoveReplaceReq"`

	ListElementMoveReplaceRes *TCaplusListElementMoveReplaceRes `tdr_field:"ListElementMoveReplaceRes"`

	TCaplusSqlReq *TCaplusSqlReq `tdr_field:"TCaplusSqlReq"`

	TCaplusSqlRes *TCaplusSqlRes `tdr_field:"TCaplusSqlRes"`

	TCaplusGetForSqlQueryReq *TCaplusGetForSqlQueryReq `tdr_field:"TCaplusGetForSqlQueryReq"`

	TCaplusGetForSqlQueryRes *TCaplusGetForSqlQueryRes `tdr_field:"TCaplusGetForSqlQueryRes"`
}

func NewTCaplusPkgBody(selector int64) *TCaplusPkgBody {
	obj := new(TCaplusPkgBody)
	obj.Init(selector)
	return obj
}

func (this *TCaplusPkgBody) GetBaseVersion() uint32 {
	return TCaplusPkgBodyBaseVersion
}

func (this *TCaplusPkgBody) GetCurrentVersion() uint32 {
	return TCaplusPkgBodyCurrentVersion
}

func (this *TCaplusPkgBody) Init(selector int64) {
	switch selector {
	case TCAPLUS_CMD_INSERT_REQ:
		this.InsertReq = NewTCaplusInsertReq()

	case TCAPLUS_CMD_INSERT_RES:
		this.InsertRes = NewTCaplusInsertRes()

	case TCAPLUS_CMD_REPLACE_REQ:
		this.ReplaceReq = NewTCaplusReplaceReq()

	case TCAPLUS_CMD_REPLACE_RES:
		this.ReplaceRes = NewTCaplusReplaceRes()

	case TCAPLUS_CMD_UPDATE_REQ:
		this.UpdateReq = NewTCaplusReplaceReq()

	case TCAPLUS_CMD_UPDATE_RES:
		this.UpdateRes = NewTCaplusReplaceRes()

	case TCAPLUS_CMD_INCREASE_REQ:
		this.IncreaseReq = NewTCaplusIncreaseReq()

	case TCAPLUS_CMD_INCREASE_RES:
		this.IncreaseRes = NewTCaplusIncreaseRes()

	case TCAPLUS_CMD_GET_REQ:
		this.GetReq = NewTCaplusGetReq()

	case TCAPLUS_CMD_GET_RES:
		this.GetRes = NewTCaplusGetRes()

	case TCAPLUS_CMD_SYS_GET_REQ:
		this.SysGetReq = NewTCaplusSysGetReq()

	case TCAPLUS_CMD_SYS_GET_RES:
		this.SysGetRes = NewTCaplusSysGetRes()

	case TCAPLUS_CMD_DELETE_REQ:
		this.DeleteReq = NewTCaplusDeleteReq()

	case TCAPLUS_CMD_DELETE_RES:
		this.DeleteRes = NewTCaplusDeleteRes()

	case TCAPLUS_CMD_SYS_DELETE_REQ:
		this.SysDeleteReq = NewTCaplusSysDeleteReq()

	case TCAPLUS_CMD_SYS_DELETE_RES:
		this.SysDeleteRes = NewTCaplusSysDeleteRes()

	case TCAPLUS_CMD_BATCH_GET_REQ:
		this.BatchGetReq = NewTCaplusBatchGetReq()

	case TCAPLUS_CMD_BATCH_GET_RES:
		this.BatchGetRes = NewTCaplusBatchGetRes()

	case TCAPLUS_CMD_LIST_GETALL_REQ:
		this.ListGetAllReq = NewTCaplusListGetAllReq()

	case TCAPLUS_CMD_LIST_GETALL_RES:
		this.ListGetAllRes = NewTCaplusListGetAllRes()

	case TCAPLUS_CMD_LIST_DELETEALL_REQ:
		this.ListDeleteAllReq = NewTCaplusListDeleteAllReq()

	case TCAPLUS_CMD_LIST_DELETEALL_RES:
		this.ListDeleteAllRes = NewTCaplusListDeleteAllRes()

	case TCAPLUS_CMD_LIST_DELETE_BATCH_REQ:
		this.ListDeleteBatchReq = NewTCaplusListDeleteBatchReq()

	case TCAPLUS_CMD_LIST_DELETE_BATCH_RES:
		this.ListDeleteBatchRes = NewTCaplusListDeleteBatchRes()

	case TCAPLUS_CMD_LIST_GET_REQ:
		this.ListGetReq = NewTCaplusListGetReq()

	case TCAPLUS_CMD_LIST_GET_RES:
		this.ListGetRes = NewTCaplusListGetRes()

	case TCAPLUS_CMD_LIST_ADDAFTER_REQ:
		this.ListAddAfterReq = NewTCaplusListAddAfterReq()

	case TCAPLUS_CMD_LIST_ADDAFTER_RES:
		this.ListAddAfterRes = NewTCaplusListAddAfterRes()

	case TCAPLUS_CMD_LIST_DELETE_REQ:
		this.ListDeleteReq = NewTCaplusListDeleteReq()

	case TCAPLUS_CMD_LIST_DELETE_RES:
		this.ListDeleteRes = NewTCaplusListDeleteRes()

	case TCAPLUS_CMD_SYS_LIST_DELETE_REQ:
		this.SysListDeleteReq = NewTCaplusSysListDeleteReq()

	case TCAPLUS_CMD_SYS_LIST_DELETE_RES:
		this.SysListDeleteRes = NewTCaplusSysListDeleteRes()

	case TCAPLUS_CMD_LIST_REPLACE_REQ:
		this.ListReplaceReq = NewTCaplusListReplaceReq()

	case TCAPLUS_CMD_LIST_REPLACE_RES:
		this.ListReplaceRes = NewTCaplusListReplaceRes()

	case TCAPLUS_CMD_GET_BY_PARTKEY_REQ:
		this.GetByPartKeyReq = NewTCaplusGetByPartKeyReq()

	case TCAPLUS_CMD_GET_BY_PARTKEY_RES:
		this.GetByPartKeyRes = NewTCaplusGetByPartKeyRes()

	case TCAPLUS_CMD_UPDATE_BY_PARTKEY_REQ:
		this.UpdateByPartkeyReq = NewTCaplusUpdateByPartkeyReq()

	case TCAPLUS_CMD_UPDATE_BY_PARTKEY_RES:
		this.UpdateByPartkeyRes = NewTCaplusUpdateByPartkeyRes()

	case TCAPLUS_CMD_DELETE_BY_PARTKEY_REQ:
		this.DeleteByPartkeyReq = NewTCaplusDeleteByPartkeyReq()

	case TCAPLUS_CMD_DELETE_BY_PARTKEY_RES:
		this.DeleteByPartkeyRes = NewTCaplusDeleteByPartkeyRes()

	case TCAPLUS_CMD_INSERT_BY_PARTKEY_REQ:
		this.InsertByPartKeyReq = NewTCaplusInsertByPartKeyReq()

	case TCAPLUS_CMD_INSERT_BY_PARTKEY_RES:
		this.InsertByPartKeyRes = NewTCaplusInsertByPartKeyRes()

	case TCAPLUS_CMD_METADATA_GET_REQ:
		this.MetadataGetReq = NewTCaplusMetadataGetReq()

	case TCAPLUS_CMD_METADATA_GET_RES:
		this.MetadataGetRes = NewTCaplusMetadataGetRes()

	case TCAPLUS_CMD_SPECIAL_GET_REQ:
		this.SpecialGetReq = NewTCaplusSpecialGetReq()

	case TCAPLUS_CMD_SPECIAL_GET_RES:
		this.SpecialGetRes = NewTCaplusSpecialGetRes()

	case TCAPLUS_CMD_MOVE_INSERT_REQ:
		this.MoveInsertReq = NewTCaplusMoveInsertReq()

	case TCAPLUS_CMD_MOVE_INSERT_RES:
		this.MoveInsertRes = NewTCaplusMoveInsertRes()

	case TCAPLUS_CMD_MSSYNC_INSERT_REQ:
		this.MsSyncInsertReq = NewTCaplusMsSyncInsertReq()

	case TCAPLUS_CMD_MSSYNC_INSERT_RES:
		this.MsSyncInsertRes = NewTCaplusMsSyncInsertRes()

	case TCAPLUS_CMD_MSSYNC_REPLACE_REQ:
		this.MsSyncReplaceReq = NewTCaplusMsSyncReplaceReq()

	case TCAPLUS_CMD_MSSYNC_REPLACE_RES:
		this.MsSyncReplaceRes = NewTCaplusMsSyncReplaceRes()

	case TCAPLUS_CMD_MSSYNC_DELETE_REQ:
		this.MsSyncDeleteReq = NewTCaplusMsSyncDeleteReq()

	case TCAPLUS_CMD_MSSYNC_DELETE_RES:
		this.MsSyncDeleteRes = NewTCaplusMsSyncDeleteRes()

	case TCAPLUS_CMD_MSSYNC_UPDATE_REQ:
		this.MsSyncUpdateReq = NewTCaplusMsSyncUpdateReq()

	case TCAPLUS_CMD_MSSYNC_UPDATE_RES:
		this.MsSyncUpdateRes = NewTCaplusMsSyncUpdateRes()

	case TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_REQ:
		this.ListMsSyncDeleteAllReq = NewTCaplusListMsSyncDeleteAllReq()

	case TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_RES:
		this.ListMsSyncDeleteAllRes = NewTCaplusListMsSyncDeleteAllRes()

	case TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_REQ:
		this.ListMsSyncAddAfterReq = NewTCaplusListMsSyncAddAfterReq()

	case TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_RES:
		this.ListMsSyncAddAfterRes = NewTCaplusListMsSyncAddAfterRes()

	case TCAPLUS_CMD_LIST_MSSYNC_DELETE_REQ:
		this.ListMsSyncDeleteReq = NewTCaplusListMsSyncDeleteReq()

	case TCAPLUS_CMD_LIST_MSSYNC_DELETE_RES:
		this.ListMsSyncDeleteRes = NewTCaplusListMsSyncDeleteRes()

	case TCAPLUS_CMD_LIST_MSSYNC_REPLACE_REQ:
		this.ListMsSyncReplaceReq = NewTCaplusListMsSyncReplaceReq()

	case TCAPLUS_CMD_LIST_MSSYNC_REPLACE_RES:
		this.ListMsSyncReplaceRes = NewTCaplusListMsSyncReplaceRes()

	case TCAPLUS_CMD_SERV_APP_SIGNUP_REQ:
		this.AppSignupReq = NewTCaplusAppSignupReq()

	case TCAPLUS_CMD_SERV_APP_SIGNUP_RES:
		this.AppSignupRes = NewTCaplusAppSignupRes()

	case TCAPLUS_CMD_SERV_HEART_BEAT_REQ:
		this.HeartBeatReq = NewTCaplusHeartBeatReq()

	case TCAPLUS_CMD_SERV_HEART_BEAT_RES:
		this.HeartBeatRes = NewTCaplusHeartBeatRes()

	case TCAPLUS_CMD_PREPARE_MOVE_REQ:
		this.PrepareMoveReq = NewTCaplusPrepareMoveReq()

	case TCAPLUS_CMD_PREPARE_MOVE_RES:
		this.PrepareMoveRes = NewTCaplusPrepareMoveRes()

	case TCAPLUS_CMD_FINISH_MOVE_REQ:
		this.FinishMoveReq = NewTCaplusFinishMoveReq()

	case TCAPLUS_CMD_FINISH_MOVE_RES:
		this.FinishMoveRes = NewTCaplusFinishMoveRes()

	case TCAPLUS_CMD_LIST_CHECK_REQ:
		this.ListCheckReq = NewTCaplusListCheckReq()

	case TCAPLUS_CMD_LIST_CHECK_RES:
		this.ListCheckRes = NewTCaplusListCheckRes()

	case TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_REQ:
		this.ListIndexMoveInsertReq = NewTCaplusListIndexMoveInsertReq()

	case TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_RES:
		this.ListIndexMoveInsertRes = NewTCaplusListIndexMoveInsertRes()

	case TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_REQ:
		this.ListElemMoveInsertReq = NewTCaplusListElemMoveInsertReq()

	case TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_RES:
		this.ListElemMoveInsertRes = NewTCaplusListElemMoveInsertRes()

	case TCAPLUS_CMD_GET_SHARD_LIST_REQ:
		this.GetShardListReq = NewTCaplusGetShardListReq()

	case TCAPLUS_CMD_GET_SHARD_LIST_RES:
		this.GetShardListRes = NewTCaplusGetShardListRes()

	case TCAPLUS_CMD_TABLE_TRAVERSE_REQ:
		this.TableTraverseReq = NewTCaplusTableTraverseReq()

	case TCAPLUS_CMD_TABLE_TRAVERSE_RES:
		this.TableTraverseRes = NewTCaplusTableTraverseRes()

	case TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_REQ:
		this.BatchGetByPartkeyReq = NewTCaplusBatchGetByPartkeyReq()

	case TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_RES:
		this.BatchGetByPartkeyRes = NewTCaplusBatchGetByPartkeyRes()

	case TCAPLUS_CMD_DOCUMENT_OPERATION_REQ:
		this.TCaplusDocumentOperationReq = NewTCaplusDocumentOperationReq()

	case TCAPLUS_CMD_DOCUMENT_OPERATION_RES:
		this.TCaplusDocumentOperationRes = NewTCaplusDocumentOperationRes()

	case TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_REQ:
		this.GetTableRecordCountReq = NewTCaplusGetTableRecordCountReq()

	case TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_RES:
		this.GetTableRecordCountRes = NewTCaplusGetTableRecordCountRes()

	case TCAPLUS_CMD_HTTP_GENERIC_REQ:
		this.HttpGenericReq = NewTCaplusHttpGenericReq()

	case TCAPLUS_CMD_HTTP_GENERIC_RES:
		this.HttpGenericRes = NewTCaplusHttpGenericRes()

	case TCAPLUS_CMD_LIST_TABLE_TRAVERSE_REQ:
		this.ListTableTraverseReq = NewTCaplusListTableTraverseReq()

	case TCAPLUS_CMD_LIST_TABLE_TRAVERSE_RES:
		this.ListTableTraverseRes = NewTCaplusListTableTraverseRes()

	case TCAPLUS_CMD_SYS_LIST_GET_REQ:
		this.SysListGetReq = NewTCaplusSysListGetReq()

	case TCAPLUS_CMD_SYS_LIST_GET_RES:
		this.SysListGetRes = NewTCaplusSysListGetRes()

	case TCAPLUS_CMD_SYS_LIST_GET_ALL_REQ:
		this.SysListGetAllReq = NewTCaplusSysListGetAllReq()

	case TCAPLUS_CMD_SYS_LIST_GET_ALL_RES:
		this.SysListGetAllRes = NewTCaplusSysListGetAllRes()

	case TCAPLUS_CMD_GET_DURING_MOVE_REQ:
		this.GetDuringMoveReq = NewTCaplusGetDuringMoveReq()

	case TCAPLUS_CMD_GET_DURING_MOVE_RES:
		this.GetDuringMoveRes = NewTCaplusGetDuringMoveRes()

	case TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_REQ:
		this.GetDuringMoveFromSrcReq = NewTCaplusGetDuringMoveFromSrcReq()

	case TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_RES:
		this.GetDuringMoveFromSrcRes = NewTCaplusGetDuringMoveFromSrcRes()

	case TCAPLUS_CMD_NEGOTIATE_VERSION_REQ:
		this.NegotiateVersionReq = NewTCaplusNegotiateVersionReq()

	case TCAPLUS_CMD_NEGOTIATE_VERSION_RES:
		this.NegotiateVersionRes = NewTCaplusNegotiateVersionRes()

	case TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_REQ:
		this.CheckConnectDuringMoveReq = NewTCaplusCheckConnectDuringMoveReq()

	case TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_RES:
		this.CheckConnectDuringMoveRes = NewTCaplusCheckConnectDuringMoveRes()

	case TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_REQ:
		this.MsSyncDataExpireDeleteReq = NewTCaplusMsSyncDeleteReq()

	case TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_RES:
		this.MsSyncDataExpireDeleteRes = NewTCaplusMsSyncDeleteRes()

	case TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_REQ:
		this.MsSyncDataMoveDeleteReq = NewTCaplusMsSyncDeleteReq()

	case TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_RES:
		this.MsSyncDataMoveDeleteRes = NewTCaplusMsSyncDeleteRes()

	case TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_REQ:
		this.ListMsSyncDataExpireDeleteReq = NewTCaplusListMsSyncDeleteReq()

	case TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_RES:
		this.ListMsSyncDataExpireDeleteRes = NewTCaplusListMsSyncDeleteRes()

	case TCAPLUS_CMD_PROTOBUF_FIELD_GET_REQ:
		this.TCaplusPbFieldGetReq = NewTCaplusProtobufFieldGetReq()

	case TCAPLUS_CMD_PROTOBUF_FIELD_GET_RES:
		this.TCaplusPbFieldGetRes = NewTCaplusProtobufFieldGetRes()

	case TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_REQ:
		this.TCaplusPbFieldUpdateReq = NewTCaplusProtobufFieldUpdateReq()

	case TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_RES:
		this.TCaplusPbFieldUpdateRes = NewTCaplusProtobufFieldUpdateRes()

	case TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_REQ:
		this.TCaplusPbFieldIncReq = NewTCaplusProtobufFieldIncreaseReq()

	case TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_RES:
		this.TCaplusPbFieldIncRes = NewTCaplusProtobufFieldIncreaseRes()

	case TCAPLUS_CMD_MSSYNC_GET_REQ:
		this.MsSyncGetReq = NewTCaplusMsSyncGetReq()

	case TCAPLUS_CMD_MSSYNC_GET_RES:
		this.MsSyncGetRes = NewTCaplusMsSyncGetRes()

	case TCAPLUS_CMD_LIST_MSSYNC_GET_REQ:
		this.ListMsSyncGetReq = NewTCaplusListMsSyncGetReq()

	case TCAPLUS_CMD_LIST_MSSYNC_GET_RES:
		this.ListMsSyncGetRes = NewTCaplusListMsSyncGetRes()

	case TCAPLUS_CMD_LIST_MSSYNC_GETALL_REQ:
		this.ListMsSyncGetAllReq = NewTCaplusListMsSyncGetAllReq()

	case TCAPLUS_CMD_LIST_MSSYNC_GETALL_RES:
		this.ListMsSyncGetAllRes = NewTCaplusListMsSyncGetAllRes()

	case TCAPLUS_CMD_MSSYNC_PARTKEY_GET_REQ:
		this.MsSyncPartkeyGetReq = NewTCaplusMsSyncPartkeyGetReq()

	case TCAPLUS_CMD_MSSYNC_PARTKEY_GET_RES:
		this.MsSyncPartkeyGetRes = NewTCaplusMsSyncPartkeyGetRes()

	case TCAPLUS_CMD_SYS_MAKE_CONSIST_REQ:
		this.SysMakeConsistReq = NewTCaplusSysMakeConsistReq()

	case TCAPLUS_CMD_SYS_MAKE_CONSIST_RES:
		this.SysMakeConsistRes = NewTCaplusSysMakeConsistRes()

	case TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_REQ:
		this.SysListMakeConsistReq = NewTCaplusSysListMakeConsistReq()

	case TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_RES:
		this.SysListMakeConsistRes = NewTCaplusSysListMakeConsistRes()

	case TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_REQ:
		this.LosslessMoveReplaceReq = NewTCaplusLosslessMoveReplaceReq()

	case TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_RES:
		this.LosslessMoveReplaceRes = NewTCaplusLosslessMoveReplaceRes()

	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_REQ:
		this.LosslessMoveListIndexReplaceReq = NewTCaplusLosslessMoveListIndexReplaceReq()

	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_RES:
		this.LosslessMoveListIndexReplaceRes = NewTCaplusLosslessMoveListIndexReplaceRes()

	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_REQ:
		this.LosslessMoveListElemReplaceReq = NewTCaplusLosslessMoveListElemReplaceReq()

	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_RES:
		this.LosslessMoveListElemReplaceRes = NewTCaplusLosslessMoveListElemReplaceRes()

	case TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_REQ:
		this.TCaplusPbBatchFieldGetReq = NewTCaplusProtobufBatchFieldGetReq()

	case TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_RES:
		this.TCaplusPbBatchFieldGetRes = NewTCaplusProtobufBatchFieldGetRes()

	case TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_REQ:
		this.ListIndexMoveReplaceReq = NewTCaplusListIndexMoveReplaceReq()

	case TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_RES:
		this.ListIndexMoveReplaceRes = NewTCaplusListIndexMoveReplaceRes()

	case TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_REQ:
		this.ListElementMoveReplaceReq = NewTCaplusListElementMoveReplaceReq()

	case TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_RES:
		this.ListElementMoveReplaceRes = NewTCaplusListElementMoveReplaceRes()

	case TCAPLUS_CMD_SQL_REQ:
		this.TCaplusSqlReq = NewTCaplusSqlReq()

	case TCAPLUS_CMD_SQL_RES:
		this.TCaplusSqlRes = NewTCaplusSqlRes()

	case TCAPLUS_CMD_GET_FOR_SQL_QUERY_REQ:
		this.TCaplusGetForSqlQueryReq = NewTCaplusGetForSqlQueryReq()

	case TCAPLUS_CMD_GET_FOR_SQL_QUERY_RES:
		this.TCaplusGetForSqlQueryRes = NewTCaplusGetForSqlQueryRes()

	}
}

func (this *TCaplusPkgBody) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusPkgBody) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusPkgBodyCurrentVersion {
		cutVer = TCaplusPkgBodyCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusPkgBodyBaseVersion {
		return errors.New("TCaplusPkgBody cut version must large than TCaplusPkgBodyBaseVersion\n")
	}

	var err error = nil
	switch selector {
	case TCAPLUS_CMD_INSERT_REQ:
		if this.InsertReq == nil {
			return errors.New("TCaplusPkgBody.InsertReq is nil")
		}

		err = this.InsertReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.InsertReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_INSERT_RES:
		if this.InsertRes == nil {
			return errors.New("TCaplusPkgBody.InsertRes is nil")
		}

		err = this.InsertRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.InsertRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_REPLACE_REQ:
		if this.ReplaceReq == nil {
			return errors.New("TCaplusPkgBody.ReplaceReq is nil")
		}

		err = this.ReplaceReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ReplaceReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_REPLACE_RES:
		if this.ReplaceRes == nil {
			return errors.New("TCaplusPkgBody.ReplaceRes is nil")
		}

		err = this.ReplaceRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ReplaceRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_UPDATE_REQ:
		if this.UpdateReq == nil {
			return errors.New("TCaplusPkgBody.UpdateReq is nil")
		}

		err = this.UpdateReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.UpdateReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_UPDATE_RES:
		if this.UpdateRes == nil {
			return errors.New("TCaplusPkgBody.UpdateRes is nil")
		}

		err = this.UpdateRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.UpdateRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_INCREASE_REQ:
		if this.IncreaseReq == nil {
			return errors.New("TCaplusPkgBody.IncreaseReq is nil")
		}

		err = this.IncreaseReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.IncreaseReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_INCREASE_RES:
		if this.IncreaseRes == nil {
			return errors.New("TCaplusPkgBody.IncreaseRes is nil")
		}

		err = this.IncreaseRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.IncreaseRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_REQ:
		if this.GetReq == nil {
			return errors.New("TCaplusPkgBody.GetReq is nil")
		}

		err = this.GetReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_RES:
		if this.GetRes == nil {
			return errors.New("TCaplusPkgBody.GetRes is nil")
		}

		err = this.GetRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SYS_GET_REQ:
		if this.SysGetReq == nil {
			return errors.New("TCaplusPkgBody.SysGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysGetReqVersion {

			err = this.SysGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_GET_RES:
		if this.SysGetRes == nil {
			return errors.New("TCaplusPkgBody.SysGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysGetResVersion {

			err = this.SysGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_DELETE_REQ:
		if this.DeleteReq == nil {
			return errors.New("TCaplusPkgBody.DeleteReq is nil")
		}

		err = this.DeleteReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.DeleteReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_DELETE_RES:
		if this.DeleteRes == nil {
			return errors.New("TCaplusPkgBody.DeleteRes is nil")
		}

		err = this.DeleteRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.DeleteRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SYS_DELETE_REQ:
		if this.SysDeleteReq == nil {
			return errors.New("TCaplusPkgBody.SysDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysDeleteReqVersion {

			err = this.SysDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_DELETE_RES:
		if this.SysDeleteRes == nil {
			return errors.New("TCaplusPkgBody.SysDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysDeleteResVersion {

			err = this.SysDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_BATCH_GET_REQ:
		if this.BatchGetReq == nil {
			return errors.New("TCaplusPkgBody.BatchGetReq is nil")
		}

		err = this.BatchGetReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.BatchGetReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_BATCH_GET_RES:
		if this.BatchGetRes == nil {
			return errors.New("TCaplusPkgBody.BatchGetRes is nil")
		}

		err = this.BatchGetRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.BatchGetRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_GETALL_REQ:
		if this.ListGetAllReq == nil {
			return errors.New("TCaplusPkgBody.ListGetAllReq is nil")
		}

		err = this.ListGetAllReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetAllReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_GETALL_RES:
		if this.ListGetAllRes == nil {
			return errors.New("TCaplusPkgBody.ListGetAllRes is nil")
		}

		err = this.ListGetAllRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetAllRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETEALL_REQ:
		if this.ListDeleteAllReq == nil {
			return errors.New("TCaplusPkgBody.ListDeleteAllReq is nil")
		}

		err = this.ListDeleteAllReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteAllReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETEALL_RES:
		if this.ListDeleteAllRes == nil {
			return errors.New("TCaplusPkgBody.ListDeleteAllRes is nil")
		}

		err = this.ListDeleteAllRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteAllRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETE_BATCH_REQ:
		if this.ListDeleteBatchReq == nil {
			return errors.New("TCaplusPkgBody.ListDeleteBatchReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListDeleteBatchReqVersion {

			err = this.ListDeleteBatchReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListDeleteBatchReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_DELETE_BATCH_RES:
		if this.ListDeleteBatchRes == nil {
			return errors.New("TCaplusPkgBody.ListDeleteBatchRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListDeleteBatchResVersion {

			err = this.ListDeleteBatchRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListDeleteBatchRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_GET_REQ:
		if this.ListGetReq == nil {
			return errors.New("TCaplusPkgBody.ListGetReq is nil")
		}

		err = this.ListGetReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_GET_RES:
		if this.ListGetRes == nil {
			return errors.New("TCaplusPkgBody.ListGetRes is nil")
		}

		err = this.ListGetRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_ADDAFTER_REQ:
		if this.ListAddAfterReq == nil {
			return errors.New("TCaplusPkgBody.ListAddAfterReq is nil")
		}

		err = this.ListAddAfterReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListAddAfterReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_ADDAFTER_RES:
		if this.ListAddAfterRes == nil {
			return errors.New("TCaplusPkgBody.ListAddAfterRes is nil")
		}

		err = this.ListAddAfterRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListAddAfterRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETE_REQ:
		if this.ListDeleteReq == nil {
			return errors.New("TCaplusPkgBody.ListDeleteReq is nil")
		}

		err = this.ListDeleteReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETE_RES:
		if this.ListDeleteRes == nil {
			return errors.New("TCaplusPkgBody.ListDeleteRes is nil")
		}

		err = this.ListDeleteRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SYS_LIST_DELETE_REQ:
		if this.SysListDeleteReq == nil {
			return errors.New("TCaplusPkgBody.SysListDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysListDeleteReqVersion {

			err = this.SysListDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_DELETE_RES:
		if this.SysListDeleteRes == nil {
			return errors.New("TCaplusPkgBody.SysListDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysListDeleteResVersion {

			err = this.SysListDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_REPLACE_REQ:
		if this.ListReplaceReq == nil {
			return errors.New("TCaplusPkgBody.ListReplaceReq is nil")
		}

		err = this.ListReplaceReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListReplaceReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_REPLACE_RES:
		if this.ListReplaceRes == nil {
			return errors.New("TCaplusPkgBody.ListReplaceRes is nil")
		}

		err = this.ListReplaceRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListReplaceRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_BY_PARTKEY_REQ:
		if this.GetByPartKeyReq == nil {
			return errors.New("TCaplusPkgBody.GetByPartKeyReq is nil")
		}

		err = this.GetByPartKeyReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetByPartKeyReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_BY_PARTKEY_RES:
		if this.GetByPartKeyRes == nil {
			return errors.New("TCaplusPkgBody.GetByPartKeyRes is nil")
		}

		err = this.GetByPartKeyRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetByPartKeyRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_UPDATE_BY_PARTKEY_REQ:
		if this.UpdateByPartkeyReq == nil {
			return errors.New("TCaplusPkgBody.UpdateByPartkeyReq is nil")
		}
		if cutVer >= TCaplusPkgBodyUpdateByPartkeyReqVersion {

			err = this.UpdateByPartkeyReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.UpdateByPartkeyReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_UPDATE_BY_PARTKEY_RES:
		if this.UpdateByPartkeyRes == nil {
			return errors.New("TCaplusPkgBody.UpdateByPartkeyRes is nil")
		}
		if cutVer >= TCaplusPkgBodyUpdateByPartkeyResVersion {

			err = this.UpdateByPartkeyRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.UpdateByPartkeyRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_DELETE_BY_PARTKEY_REQ:
		if this.DeleteByPartkeyReq == nil {
			return errors.New("TCaplusPkgBody.DeleteByPartkeyReq is nil")
		}
		if cutVer >= TCaplusPkgBodyDeleteByPartkeyReqVersion {

			err = this.DeleteByPartkeyReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.DeleteByPartkeyReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_DELETE_BY_PARTKEY_RES:
		if this.DeleteByPartkeyRes == nil {
			return errors.New("TCaplusPkgBody.DeleteByPartkeyRes is nil")
		}
		if cutVer >= TCaplusPkgBodyDeleteByPartkeyResVersion {

			err = this.DeleteByPartkeyRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.DeleteByPartkeyRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_INSERT_BY_PARTKEY_REQ:
		if this.InsertByPartKeyReq == nil {
			return errors.New("TCaplusPkgBody.InsertByPartKeyReq is nil")
		}
		if cutVer >= TCaplusPkgBodyInsertByPartKeyReqVersion {

			err = this.InsertByPartKeyReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.InsertByPartKeyReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_INSERT_BY_PARTKEY_RES:
		if this.InsertByPartKeyRes == nil {
			return errors.New("TCaplusPkgBody.InsertByPartKeyRes is nil")
		}
		if cutVer >= TCaplusPkgBodyInsertByPartKeyResVersion {

			err = this.InsertByPartKeyRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.InsertByPartKeyRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_METADATA_GET_REQ:
		if this.MetadataGetReq == nil {
			return errors.New("TCaplusPkgBody.MetadataGetReq is nil")
		}

		err = this.MetadataGetReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.MetadataGetReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_METADATA_GET_RES:
		if this.MetadataGetRes == nil {
			return errors.New("TCaplusPkgBody.MetadataGetRes is nil")
		}

		err = this.MetadataGetRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.MetadataGetRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SPECIAL_GET_REQ:
		if this.SpecialGetReq == nil {
			return errors.New("TCaplusPkgBody.SpecialGetReq is nil")
		}

		err = this.SpecialGetReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.SpecialGetReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SPECIAL_GET_RES:
		if this.SpecialGetRes == nil {
			return errors.New("TCaplusPkgBody.SpecialGetRes is nil")
		}

		err = this.SpecialGetRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.SpecialGetRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_MOVE_INSERT_REQ:
		if this.MoveInsertReq == nil {
			return errors.New("TCaplusPkgBody.MoveInsertReq is nil")
		}

		err = this.MoveInsertReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.MoveInsertReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_MOVE_INSERT_RES:
		if this.MoveInsertRes == nil {
			return errors.New("TCaplusPkgBody.MoveInsertRes is nil")
		}

		err = this.MoveInsertRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.MoveInsertRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_MSSYNC_INSERT_REQ:
		if this.MsSyncInsertReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncInsertReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncInsertReqVersion {

			err = this.MsSyncInsertReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncInsertReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_INSERT_RES:
		if this.MsSyncInsertRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncInsertRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncInsertResVersion {

			err = this.MsSyncInsertRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncInsertRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_REPLACE_REQ:
		if this.MsSyncReplaceReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncReplaceReqVersion {

			err = this.MsSyncReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_REPLACE_RES:
		if this.MsSyncReplaceRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncReplaceResVersion {

			err = this.MsSyncReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_DELETE_REQ:
		if this.MsSyncDeleteReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncDeleteReqVersion {

			err = this.MsSyncDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_DELETE_RES:
		if this.MsSyncDeleteRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncDeleteResVersion {

			err = this.MsSyncDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_UPDATE_REQ:
		if this.MsSyncUpdateReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncUpdateReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncUpdateReqVersion {

			err = this.MsSyncUpdateReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncUpdateReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_UPDATE_RES:
		if this.MsSyncUpdateRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncUpdateRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncUpdateResVersion {

			err = this.MsSyncUpdateRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncUpdateRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_REQ:
		if this.ListMsSyncDeleteAllReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncDeleteAllReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteAllReqVersion {

			err = this.ListMsSyncDeleteAllReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteAllReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_RES:
		if this.ListMsSyncDeleteAllRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncDeleteAllRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteAllResVersion {

			err = this.ListMsSyncDeleteAllRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteAllRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_REQ:
		if this.ListMsSyncAddAfterReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncAddAfterReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncAddAfterReqVersion {

			err = this.ListMsSyncAddAfterReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncAddAfterReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_RES:
		if this.ListMsSyncAddAfterRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncAddAfterRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncAddAfterResVersion {

			err = this.ListMsSyncAddAfterRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncAddAfterRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETE_REQ:
		if this.ListMsSyncDeleteReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteReqVersion {

			err = this.ListMsSyncDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETE_RES:
		if this.ListMsSyncDeleteRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteResVersion {

			err = this.ListMsSyncDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_REPLACE_REQ:
		if this.ListMsSyncReplaceReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncReplaceReqVersion {

			err = this.ListMsSyncReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_REPLACE_RES:
		if this.ListMsSyncReplaceRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncReplaceResVersion {

			err = this.ListMsSyncReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SERV_APP_SIGNUP_REQ:
		if this.AppSignupReq == nil {
			return errors.New("TCaplusPkgBody.AppSignupReq is nil")
		}
		if cutVer >= TCaplusPkgBodyAppSignupReqVersion {

			err = this.AppSignupReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.AppSignupReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SERV_APP_SIGNUP_RES:
		if this.AppSignupRes == nil {
			return errors.New("TCaplusPkgBody.AppSignupRes is nil")
		}
		if cutVer >= TCaplusPkgBodyAppSignupResVersion {

			err = this.AppSignupRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.AppSignupRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SERV_HEART_BEAT_REQ:
		if this.HeartBeatReq == nil {
			return errors.New("TCaplusPkgBody.HeartBeatReq is nil")
		}
		if cutVer >= TCaplusPkgBodyHeartBeatReqVersion {

			err = this.HeartBeatReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.HeartBeatReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SERV_HEART_BEAT_RES:
		if this.HeartBeatRes == nil {
			return errors.New("TCaplusPkgBody.HeartBeatRes is nil")
		}
		if cutVer >= TCaplusPkgBodyHeartBeatResVersion {

			err = this.HeartBeatRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.HeartBeatRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PREPARE_MOVE_REQ:
		if this.PrepareMoveReq == nil {
			return errors.New("TCaplusPkgBody.PrepareMoveReq is nil")
		}
		if cutVer >= TCaplusPkgBodyPrepareMoveReqVersion {

			err = this.PrepareMoveReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.PrepareMoveReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PREPARE_MOVE_RES:
		if this.PrepareMoveRes == nil {
			return errors.New("TCaplusPkgBody.PrepareMoveRes is nil")
		}
		if cutVer >= TCaplusPkgBodyPrepareMoveResVersion {

			err = this.PrepareMoveRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.PrepareMoveRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_FINISH_MOVE_REQ:
		if this.FinishMoveReq == nil {
			return errors.New("TCaplusPkgBody.FinishMoveReq is nil")
		}
		if cutVer >= TCaplusPkgBodyFinishMoveReqVersion {

			err = this.FinishMoveReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.FinishMoveReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_FINISH_MOVE_RES:
		if this.FinishMoveRes == nil {
			return errors.New("TCaplusPkgBody.FinishMoveRes is nil")
		}
		if cutVer >= TCaplusPkgBodyFinishMoveResVersion {

			err = this.FinishMoveRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.FinishMoveRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_CHECK_REQ:
		if this.ListCheckReq == nil {
			return errors.New("TCaplusPkgBody.ListCheckReq is nil")
		}

		err = this.ListCheckReq.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListCheckReq pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_CHECK_RES:
		if this.ListCheckRes == nil {
			return errors.New("TCaplusPkgBody.ListCheckRes is nil")
		}

		err = this.ListCheckRes.PackTo(cutVer, w)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListCheckRes pack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_REQ:
		if this.ListIndexMoveInsertReq == nil {
			return errors.New("TCaplusPkgBody.ListIndexMoveInsertReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveInsertReqVersion {

			err = this.ListIndexMoveInsertReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveInsertReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_RES:
		if this.ListIndexMoveInsertRes == nil {
			return errors.New("TCaplusPkgBody.ListIndexMoveInsertRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveInsertResVersion {

			err = this.ListIndexMoveInsertRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveInsertRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_REQ:
		if this.ListElemMoveInsertReq == nil {
			return errors.New("TCaplusPkgBody.ListElemMoveInsertReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListElemMoveInsertReqVersion {

			err = this.ListElemMoveInsertReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElemMoveInsertReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_RES:
		if this.ListElemMoveInsertRes == nil {
			return errors.New("TCaplusPkgBody.ListElemMoveInsertRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListElemMoveInsertResVersion {

			err = this.ListElemMoveInsertRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElemMoveInsertRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_SHARD_LIST_REQ:
		if this.GetShardListReq == nil {
			return errors.New("TCaplusPkgBody.GetShardListReq is nil")
		}
		if cutVer >= TCaplusPkgBodyGetShardListReqVersion {

			err = this.GetShardListReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetShardListReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_SHARD_LIST_RES:
		if this.GetShardListRes == nil {
			return errors.New("TCaplusPkgBody.GetShardListRes is nil")
		}
		if cutVer >= TCaplusPkgBodyGetShardListResVersion {

			err = this.GetShardListRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetShardListRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_TABLE_TRAVERSE_REQ:
		if this.TableTraverseReq == nil {
			return errors.New("TCaplusPkgBody.TableTraverseReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTableTraverseReqVersion {

			err = this.TableTraverseReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TableTraverseReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_TABLE_TRAVERSE_RES:
		if this.TableTraverseRes == nil {
			return errors.New("TCaplusPkgBody.TableTraverseRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTableTraverseResVersion {

			err = this.TableTraverseRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TableTraverseRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_REQ:
		if this.BatchGetByPartkeyReq == nil {
			return errors.New("TCaplusPkgBody.BatchGetByPartkeyReq is nil")
		}
		if cutVer >= TCaplusPkgBodyBatchGetByPartkeyReqVersion {

			err = this.BatchGetByPartkeyReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.BatchGetByPartkeyReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_RES:
		if this.BatchGetByPartkeyRes == nil {
			return errors.New("TCaplusPkgBody.BatchGetByPartkeyRes is nil")
		}
		if cutVer >= TCaplusPkgBodyBatchGetByPartkeyResVersion {

			err = this.BatchGetByPartkeyRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.BatchGetByPartkeyRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_DOCUMENT_OPERATION_REQ:
		if this.TCaplusDocumentOperationReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusDocumentOperationReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusDocumentOperationReqVersion {

			err = this.TCaplusDocumentOperationReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusDocumentOperationReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_DOCUMENT_OPERATION_RES:
		if this.TCaplusDocumentOperationRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusDocumentOperationRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusDocumentOperationResVersion {

			err = this.TCaplusDocumentOperationRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusDocumentOperationRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_REQ:
		if this.GetTableRecordCountReq == nil {
			return errors.New("TCaplusPkgBody.GetTableRecordCountReq is nil")
		}
		if cutVer >= TCaplusPkgBodyGetTableRecordCountReqVersion {

			err = this.GetTableRecordCountReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetTableRecordCountReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_RES:
		if this.GetTableRecordCountRes == nil {
			return errors.New("TCaplusPkgBody.GetTableRecordCountRes is nil")
		}
		if cutVer >= TCaplusPkgBodyGetTableRecordCountResVersion {

			err = this.GetTableRecordCountRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetTableRecordCountRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_HTTP_GENERIC_REQ:
		if this.HttpGenericReq == nil {
			return errors.New("TCaplusPkgBody.HttpGenericReq is nil")
		}
		if cutVer >= TCaplusPkgBodyHttpGenericReqVersion {

			err = this.HttpGenericReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.HttpGenericReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_HTTP_GENERIC_RES:
		if this.HttpGenericRes == nil {
			return errors.New("TCaplusPkgBody.HttpGenericRes is nil")
		}
		if cutVer >= TCaplusPkgBodyHttpGenericResVersion {

			err = this.HttpGenericRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.HttpGenericRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_TABLE_TRAVERSE_REQ:
		if this.ListTableTraverseReq == nil {
			return errors.New("TCaplusPkgBody.ListTableTraverseReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListTableTraverseReqVersion {

			err = this.ListTableTraverseReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListTableTraverseReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_TABLE_TRAVERSE_RES:
		if this.ListTableTraverseRes == nil {
			return errors.New("TCaplusPkgBody.ListTableTraverseRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListTableTraverseResVersion {

			err = this.ListTableTraverseRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListTableTraverseRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_GET_REQ:
		if this.SysListGetReq == nil {
			return errors.New("TCaplusPkgBody.SysListGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysListGetReqVersion {

			err = this.SysListGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_GET_RES:
		if this.SysListGetRes == nil {
			return errors.New("TCaplusPkgBody.SysListGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysListGetResVersion {

			err = this.SysListGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_GET_ALL_REQ:
		if this.SysListGetAllReq == nil {
			return errors.New("TCaplusPkgBody.SysListGetAllReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysListGetAllReqVersion {

			err = this.SysListGetAllReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetAllReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_GET_ALL_RES:
		if this.SysListGetAllRes == nil {
			return errors.New("TCaplusPkgBody.SysListGetAllRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysListGetAllResVersion {

			err = this.SysListGetAllRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetAllRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_REQ:
		if this.GetDuringMoveReq == nil {
			return errors.New("TCaplusPkgBody.GetDuringMoveReq is nil")
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveReqVersion {

			err = this.GetDuringMoveReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_RES:
		if this.GetDuringMoveRes == nil {
			return errors.New("TCaplusPkgBody.GetDuringMoveRes is nil")
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveResVersion {

			err = this.GetDuringMoveRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_REQ:
		if this.GetDuringMoveFromSrcReq == nil {
			return errors.New("TCaplusPkgBody.GetDuringMoveFromSrcReq is nil")
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveFromSrcReqVersion {

			err = this.GetDuringMoveFromSrcReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveFromSrcReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_RES:
		if this.GetDuringMoveFromSrcRes == nil {
			return errors.New("TCaplusPkgBody.GetDuringMoveFromSrcRes is nil")
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveFromSrcResVersion {

			err = this.GetDuringMoveFromSrcRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveFromSrcRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_NEGOTIATE_VERSION_REQ:
		if this.NegotiateVersionReq == nil {
			return errors.New("TCaplusPkgBody.NegotiateVersionReq is nil")
		}
		if cutVer >= TCaplusPkgBodyNegotiateVersionReqVersion {

			err = this.NegotiateVersionReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.NegotiateVersionReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_NEGOTIATE_VERSION_RES:
		if this.NegotiateVersionRes == nil {
			return errors.New("TCaplusPkgBody.NegotiateVersionRes is nil")
		}
		if cutVer >= TCaplusPkgBodyNegotiateVersionResVersion {

			err = this.NegotiateVersionRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.NegotiateVersionRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_REQ:
		if this.CheckConnectDuringMoveReq == nil {
			return errors.New("TCaplusPkgBody.CheckConnectDuringMoveReq is nil")
		}
		if cutVer >= TCaplusPkgBodyCheckConnectDuringMoveReqVersion {

			err = this.CheckConnectDuringMoveReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.CheckConnectDuringMoveReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_RES:
		if this.CheckConnectDuringMoveRes == nil {
			return errors.New("TCaplusPkgBody.CheckConnectDuringMoveRes is nil")
		}
		if cutVer >= TCaplusPkgBodyCheckConnectDuringMoveResVersion {

			err = this.CheckConnectDuringMoveRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.CheckConnectDuringMoveRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_REQ:
		if this.MsSyncDataExpireDeleteReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncDataExpireDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataExpireDeleteReqVersion {

			err = this.MsSyncDataExpireDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataExpireDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_RES:
		if this.MsSyncDataExpireDeleteRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncDataExpireDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataExpireDeleteResVersion {

			err = this.MsSyncDataExpireDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataExpireDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_REQ:
		if this.MsSyncDataMoveDeleteReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncDataMoveDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataMoveDeleteReqVersion {

			err = this.MsSyncDataMoveDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataMoveDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_RES:
		if this.MsSyncDataMoveDeleteRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncDataMoveDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataMoveDeleteResVersion {

			err = this.MsSyncDataMoveDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataMoveDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_REQ:
		if this.ListMsSyncDataExpireDeleteReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncDataExpireDeleteReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDataExpireDeleteReqVersion {

			err = this.ListMsSyncDataExpireDeleteReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDataExpireDeleteReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_RES:
		if this.ListMsSyncDataExpireDeleteRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncDataExpireDeleteRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDataExpireDeleteResVersion {

			err = this.ListMsSyncDataExpireDeleteRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDataExpireDeleteRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_GET_REQ:
		if this.TCaplusPbFieldGetReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbFieldGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldGetReqVersion {

			err = this.TCaplusPbFieldGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_GET_RES:
		if this.TCaplusPbFieldGetRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbFieldGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldGetResVersion {

			err = this.TCaplusPbFieldGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_REQ:
		if this.TCaplusPbFieldUpdateReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbFieldUpdateReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldUpdateReqVersion {

			err = this.TCaplusPbFieldUpdateReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldUpdateReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_RES:
		if this.TCaplusPbFieldUpdateRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbFieldUpdateRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldUpdateResVersion {

			err = this.TCaplusPbFieldUpdateRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldUpdateRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_REQ:
		if this.TCaplusPbFieldIncReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbFieldIncReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldIncReqVersion {

			err = this.TCaplusPbFieldIncReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldIncReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_RES:
		if this.TCaplusPbFieldIncRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbFieldIncRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldIncResVersion {

			err = this.TCaplusPbFieldIncRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldIncRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_GET_REQ:
		if this.MsSyncGetReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncGetReqVersion {

			err = this.MsSyncGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_GET_RES:
		if this.MsSyncGetRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncGetResVersion {

			err = this.MsSyncGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GET_REQ:
		if this.ListMsSyncGetReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetReqVersion {

			err = this.ListMsSyncGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GET_RES:
		if this.ListMsSyncGetRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetResVersion {

			err = this.ListMsSyncGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GETALL_REQ:
		if this.ListMsSyncGetAllReq == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncGetAllReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetAllReqVersion {

			err = this.ListMsSyncGetAllReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetAllReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GETALL_RES:
		if this.ListMsSyncGetAllRes == nil {
			return errors.New("TCaplusPkgBody.ListMsSyncGetAllRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetAllResVersion {

			err = this.ListMsSyncGetAllRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetAllRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_PARTKEY_GET_REQ:
		if this.MsSyncPartkeyGetReq == nil {
			return errors.New("TCaplusPkgBody.MsSyncPartkeyGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncPartkeyGetReqVersion {

			err = this.MsSyncPartkeyGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncPartkeyGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_MSSYNC_PARTKEY_GET_RES:
		if this.MsSyncPartkeyGetRes == nil {
			return errors.New("TCaplusPkgBody.MsSyncPartkeyGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodyMsSyncPartkeyGetResVersion {

			err = this.MsSyncPartkeyGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncPartkeyGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_MAKE_CONSIST_REQ:
		if this.SysMakeConsistReq == nil {
			return errors.New("TCaplusPkgBody.SysMakeConsistReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysMakeConsistReqVersion {

			err = this.SysMakeConsistReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysMakeConsistReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_MAKE_CONSIST_RES:
		if this.SysMakeConsistRes == nil {
			return errors.New("TCaplusPkgBody.SysMakeConsistRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysMakeConsistResVersion {

			err = this.SysMakeConsistRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysMakeConsistRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_REQ:
		if this.SysListMakeConsistReq == nil {
			return errors.New("TCaplusPkgBody.SysListMakeConsistReq is nil")
		}
		if cutVer >= TCaplusPkgBodySysListMakeConsistReqVersion {

			err = this.SysListMakeConsistReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListMakeConsistReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_RES:
		if this.SysListMakeConsistRes == nil {
			return errors.New("TCaplusPkgBody.SysListMakeConsistRes is nil")
		}
		if cutVer >= TCaplusPkgBodySysListMakeConsistResVersion {

			err = this.SysListMakeConsistRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListMakeConsistRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_REQ:
		if this.LosslessMoveReplaceReq == nil {
			return errors.New("TCaplusPkgBody.LosslessMoveReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveReplaceReqVersion {

			err = this.LosslessMoveReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_RES:
		if this.LosslessMoveReplaceRes == nil {
			return errors.New("TCaplusPkgBody.LosslessMoveReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveReplaceResVersion {

			err = this.LosslessMoveReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_REQ:
		if this.LosslessMoveListIndexReplaceReq == nil {
			return errors.New("TCaplusPkgBody.LosslessMoveListIndexReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListIndexReplaceReqVersion {

			err = this.LosslessMoveListIndexReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListIndexReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_RES:
		if this.LosslessMoveListIndexReplaceRes == nil {
			return errors.New("TCaplusPkgBody.LosslessMoveListIndexReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListIndexReplaceResVersion {

			err = this.LosslessMoveListIndexReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListIndexReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_REQ:
		if this.LosslessMoveListElemReplaceReq == nil {
			return errors.New("TCaplusPkgBody.LosslessMoveListElemReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListElemReplaceReqVersion {

			err = this.LosslessMoveListElemReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListElemReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_RES:
		if this.LosslessMoveListElemReplaceRes == nil {
			return errors.New("TCaplusPkgBody.LosslessMoveListElemReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListElemReplaceResVersion {

			err = this.LosslessMoveListElemReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListElemReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_REQ:
		if this.TCaplusPbBatchFieldGetReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbBatchFieldGetReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbBatchFieldGetReqVersion {

			err = this.TCaplusPbBatchFieldGetReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbBatchFieldGetReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_RES:
		if this.TCaplusPbBatchFieldGetRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusPbBatchFieldGetRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbBatchFieldGetResVersion {

			err = this.TCaplusPbBatchFieldGetRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbBatchFieldGetRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_REQ:
		if this.ListIndexMoveReplaceReq == nil {
			return errors.New("TCaplusPkgBody.ListIndexMoveReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveReplaceReqVersion {

			err = this.ListIndexMoveReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_RES:
		if this.ListIndexMoveReplaceRes == nil {
			return errors.New("TCaplusPkgBody.ListIndexMoveReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveReplaceResVersion {

			err = this.ListIndexMoveReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_REQ:
		if this.ListElementMoveReplaceReq == nil {
			return errors.New("TCaplusPkgBody.ListElementMoveReplaceReq is nil")
		}
		if cutVer >= TCaplusPkgBodyListElementMoveReplaceReqVersion {

			err = this.ListElementMoveReplaceReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElementMoveReplaceReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_RES:
		if this.ListElementMoveReplaceRes == nil {
			return errors.New("TCaplusPkgBody.ListElementMoveReplaceRes is nil")
		}
		if cutVer >= TCaplusPkgBodyListElementMoveReplaceResVersion {

			err = this.ListElementMoveReplaceRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElementMoveReplaceRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SQL_REQ:
		if this.TCaplusSqlReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusSqlReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusSqlReqVersion {

			err = this.TCaplusSqlReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusSqlReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_SQL_RES:
		if this.TCaplusSqlRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusSqlRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusSqlResVersion {

			err = this.TCaplusSqlRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusSqlRes pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_FOR_SQL_QUERY_REQ:
		if this.TCaplusGetForSqlQueryReq == nil {
			return errors.New("TCaplusPkgBody.TCaplusGetForSqlQueryReq is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusGetForSqlQueryReqVersion {

			err = this.TCaplusGetForSqlQueryReq.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusGetForSqlQueryReq pack error\n" + err.Error())
			}

		}
	case TCAPLUS_CMD_GET_FOR_SQL_QUERY_RES:
		if this.TCaplusGetForSqlQueryRes == nil {
			return errors.New("TCaplusPkgBody.TCaplusGetForSqlQueryRes is nil")
		}
		if cutVer >= TCaplusPkgBodyTCaplusGetForSqlQueryResVersion {

			err = this.TCaplusGetForSqlQueryRes.PackTo(cutVer, w)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusGetForSqlQueryRes pack error\n" + err.Error())
			}

		}
	}

	return nil
}

func (this *TCaplusPkgBody) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("TCaplusPkgBody data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}

func (this *TCaplusPkgBody) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
	var err error = nil
	// adjust version
	if cutVer == 0 || cutVer > TCaplusPkgBodyCurrentVersion {
		cutVer = TCaplusPkgBodyCurrentVersion
	}
	// check version
	if cutVer < TCaplusPkgBodyBaseVersion {
		errors.New("TCaplusPkgBody cut version must large than TCaplusPkgBodyBaseVersion\n")
	}

	switch selector {
	case TCAPLUS_CMD_INSERT_REQ:
		if this.InsertReq == nil {
			this.InsertReq = NewTCaplusInsertReq()
		}

		err = this.InsertReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.InsertReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_INSERT_RES:
		if this.InsertRes == nil {
			this.InsertRes = NewTCaplusInsertRes()
		}

		err = this.InsertRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.InsertRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_REPLACE_REQ:
		if this.ReplaceReq == nil {
			this.ReplaceReq = NewTCaplusReplaceReq()
		}

		err = this.ReplaceReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ReplaceReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_REPLACE_RES:
		if this.ReplaceRes == nil {
			this.ReplaceRes = NewTCaplusReplaceRes()
		}

		err = this.ReplaceRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ReplaceRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_UPDATE_REQ:
		if this.UpdateReq == nil {
			this.UpdateReq = NewTCaplusReplaceReq()
		}

		err = this.UpdateReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.UpdateReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_UPDATE_RES:
		if this.UpdateRes == nil {
			this.UpdateRes = NewTCaplusReplaceRes()
		}

		err = this.UpdateRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.UpdateRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_INCREASE_REQ:
		if this.IncreaseReq == nil {
			this.IncreaseReq = NewTCaplusIncreaseReq()
		}

		err = this.IncreaseReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.IncreaseReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_INCREASE_RES:
		if this.IncreaseRes == nil {
			this.IncreaseRes = NewTCaplusIncreaseRes()
		}

		err = this.IncreaseRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.IncreaseRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_REQ:
		if this.GetReq == nil {
			this.GetReq = NewTCaplusGetReq()
		}

		err = this.GetReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_RES:
		if this.GetRes == nil {
			this.GetRes = NewTCaplusGetRes()
		}

		err = this.GetRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SYS_GET_REQ:
		if this.SysGetReq == nil {
			this.SysGetReq = NewTCaplusSysGetReq()
		}
		if cutVer >= TCaplusPkgBodySysGetReqVersion {

			err = this.SysGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysGetReq unpack error\n" + err.Error())
			}

		} else {
			this.SysGetReq.Init()

		}
	case TCAPLUS_CMD_SYS_GET_RES:
		if this.SysGetRes == nil {
			this.SysGetRes = NewTCaplusSysGetRes()
		}
		if cutVer >= TCaplusPkgBodySysGetResVersion {

			err = this.SysGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysGetRes unpack error\n" + err.Error())
			}

		} else {
			this.SysGetRes.Init()

		}
	case TCAPLUS_CMD_DELETE_REQ:
		if this.DeleteReq == nil {
			this.DeleteReq = NewTCaplusDeleteReq()
		}

		err = this.DeleteReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.DeleteReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_DELETE_RES:
		if this.DeleteRes == nil {
			this.DeleteRes = NewTCaplusDeleteRes()
		}

		err = this.DeleteRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.DeleteRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SYS_DELETE_REQ:
		if this.SysDeleteReq == nil {
			this.SysDeleteReq = NewTCaplusSysDeleteReq()
		}
		if cutVer >= TCaplusPkgBodySysDeleteReqVersion {

			err = this.SysDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.SysDeleteReq.Init()

		}
	case TCAPLUS_CMD_SYS_DELETE_RES:
		if this.SysDeleteRes == nil {
			this.SysDeleteRes = NewTCaplusSysDeleteRes()
		}
		if cutVer >= TCaplusPkgBodySysDeleteResVersion {

			err = this.SysDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.SysDeleteRes.Init()

		}
	case TCAPLUS_CMD_BATCH_GET_REQ:
		if this.BatchGetReq == nil {
			this.BatchGetReq = NewTCaplusBatchGetReq()
		}

		err = this.BatchGetReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.BatchGetReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_BATCH_GET_RES:
		if this.BatchGetRes == nil {
			this.BatchGetRes = NewTCaplusBatchGetRes()
		}

		err = this.BatchGetRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.BatchGetRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_GETALL_REQ:
		if this.ListGetAllReq == nil {
			this.ListGetAllReq = NewTCaplusListGetAllReq()
		}

		err = this.ListGetAllReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetAllReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_GETALL_RES:
		if this.ListGetAllRes == nil {
			this.ListGetAllRes = NewTCaplusListGetAllRes()
		}

		err = this.ListGetAllRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetAllRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETEALL_REQ:
		if this.ListDeleteAllReq == nil {
			this.ListDeleteAllReq = NewTCaplusListDeleteAllReq()
		}

		err = this.ListDeleteAllReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteAllReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETEALL_RES:
		if this.ListDeleteAllRes == nil {
			this.ListDeleteAllRes = NewTCaplusListDeleteAllRes()
		}

		err = this.ListDeleteAllRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteAllRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETE_BATCH_REQ:
		if this.ListDeleteBatchReq == nil {
			this.ListDeleteBatchReq = NewTCaplusListDeleteBatchReq()
		}
		if cutVer >= TCaplusPkgBodyListDeleteBatchReqVersion {

			err = this.ListDeleteBatchReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListDeleteBatchReq unpack error\n" + err.Error())
			}

		} else {
			this.ListDeleteBatchReq.Init()

		}
	case TCAPLUS_CMD_LIST_DELETE_BATCH_RES:
		if this.ListDeleteBatchRes == nil {
			this.ListDeleteBatchRes = NewTCaplusListDeleteBatchRes()
		}
		if cutVer >= TCaplusPkgBodyListDeleteBatchResVersion {

			err = this.ListDeleteBatchRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListDeleteBatchRes unpack error\n" + err.Error())
			}

		} else {
			this.ListDeleteBatchRes.Init()

		}
	case TCAPLUS_CMD_LIST_GET_REQ:
		if this.ListGetReq == nil {
			this.ListGetReq = NewTCaplusListGetReq()
		}

		err = this.ListGetReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_GET_RES:
		if this.ListGetRes == nil {
			this.ListGetRes = NewTCaplusListGetRes()
		}

		err = this.ListGetRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListGetRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_ADDAFTER_REQ:
		if this.ListAddAfterReq == nil {
			this.ListAddAfterReq = NewTCaplusListAddAfterReq()
		}

		err = this.ListAddAfterReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListAddAfterReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_ADDAFTER_RES:
		if this.ListAddAfterRes == nil {
			this.ListAddAfterRes = NewTCaplusListAddAfterRes()
		}

		err = this.ListAddAfterRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListAddAfterRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETE_REQ:
		if this.ListDeleteReq == nil {
			this.ListDeleteReq = NewTCaplusListDeleteReq()
		}

		err = this.ListDeleteReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_DELETE_RES:
		if this.ListDeleteRes == nil {
			this.ListDeleteRes = NewTCaplusListDeleteRes()
		}

		err = this.ListDeleteRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListDeleteRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SYS_LIST_DELETE_REQ:
		if this.SysListDeleteReq == nil {
			this.SysListDeleteReq = NewTCaplusSysListDeleteReq()
		}
		if cutVer >= TCaplusPkgBodySysListDeleteReqVersion {

			err = this.SysListDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.SysListDeleteReq.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_DELETE_RES:
		if this.SysListDeleteRes == nil {
			this.SysListDeleteRes = NewTCaplusSysListDeleteRes()
		}
		if cutVer >= TCaplusPkgBodySysListDeleteResVersion {

			err = this.SysListDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.SysListDeleteRes.Init()

		}
	case TCAPLUS_CMD_LIST_REPLACE_REQ:
		if this.ListReplaceReq == nil {
			this.ListReplaceReq = NewTCaplusListReplaceReq()
		}

		err = this.ListReplaceReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListReplaceReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_REPLACE_RES:
		if this.ListReplaceRes == nil {
			this.ListReplaceRes = NewTCaplusListReplaceRes()
		}

		err = this.ListReplaceRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListReplaceRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_BY_PARTKEY_REQ:
		if this.GetByPartKeyReq == nil {
			this.GetByPartKeyReq = NewTCaplusGetByPartKeyReq()
		}

		err = this.GetByPartKeyReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetByPartKeyReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_GET_BY_PARTKEY_RES:
		if this.GetByPartKeyRes == nil {
			this.GetByPartKeyRes = NewTCaplusGetByPartKeyRes()
		}

		err = this.GetByPartKeyRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.GetByPartKeyRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_UPDATE_BY_PARTKEY_REQ:
		if this.UpdateByPartkeyReq == nil {
			this.UpdateByPartkeyReq = NewTCaplusUpdateByPartkeyReq()
		}
		if cutVer >= TCaplusPkgBodyUpdateByPartkeyReqVersion {

			err = this.UpdateByPartkeyReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.UpdateByPartkeyReq unpack error\n" + err.Error())
			}

		} else {
			this.UpdateByPartkeyReq.Init()

		}
	case TCAPLUS_CMD_UPDATE_BY_PARTKEY_RES:
		if this.UpdateByPartkeyRes == nil {
			this.UpdateByPartkeyRes = NewTCaplusUpdateByPartkeyRes()
		}
		if cutVer >= TCaplusPkgBodyUpdateByPartkeyResVersion {

			err = this.UpdateByPartkeyRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.UpdateByPartkeyRes unpack error\n" + err.Error())
			}

		} else {
			this.UpdateByPartkeyRes.Init()

		}
	case TCAPLUS_CMD_DELETE_BY_PARTKEY_REQ:
		if this.DeleteByPartkeyReq == nil {
			this.DeleteByPartkeyReq = NewTCaplusDeleteByPartkeyReq()
		}
		if cutVer >= TCaplusPkgBodyDeleteByPartkeyReqVersion {

			err = this.DeleteByPartkeyReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.DeleteByPartkeyReq unpack error\n" + err.Error())
			}

		} else {
			this.DeleteByPartkeyReq.Init()

		}
	case TCAPLUS_CMD_DELETE_BY_PARTKEY_RES:
		if this.DeleteByPartkeyRes == nil {
			this.DeleteByPartkeyRes = NewTCaplusDeleteByPartkeyRes()
		}
		if cutVer >= TCaplusPkgBodyDeleteByPartkeyResVersion {

			err = this.DeleteByPartkeyRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.DeleteByPartkeyRes unpack error\n" + err.Error())
			}

		} else {
			this.DeleteByPartkeyRes.Init()

		}
	case TCAPLUS_CMD_INSERT_BY_PARTKEY_REQ:
		if this.InsertByPartKeyReq == nil {
			this.InsertByPartKeyReq = NewTCaplusInsertByPartKeyReq()
		}
		if cutVer >= TCaplusPkgBodyInsertByPartKeyReqVersion {

			err = this.InsertByPartKeyReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.InsertByPartKeyReq unpack error\n" + err.Error())
			}

		} else {
			this.InsertByPartKeyReq.Init()

		}
	case TCAPLUS_CMD_INSERT_BY_PARTKEY_RES:
		if this.InsertByPartKeyRes == nil {
			this.InsertByPartKeyRes = NewTCaplusInsertByPartKeyRes()
		}
		if cutVer >= TCaplusPkgBodyInsertByPartKeyResVersion {

			err = this.InsertByPartKeyRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.InsertByPartKeyRes unpack error\n" + err.Error())
			}

		} else {
			this.InsertByPartKeyRes.Init()

		}
	case TCAPLUS_CMD_METADATA_GET_REQ:
		if this.MetadataGetReq == nil {
			this.MetadataGetReq = NewTCaplusMetadataGetReq()
		}

		err = this.MetadataGetReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.MetadataGetReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_METADATA_GET_RES:
		if this.MetadataGetRes == nil {
			this.MetadataGetRes = NewTCaplusMetadataGetRes()
		}

		err = this.MetadataGetRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.MetadataGetRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SPECIAL_GET_REQ:
		if this.SpecialGetReq == nil {
			this.SpecialGetReq = NewTCaplusSpecialGetReq()
		}

		err = this.SpecialGetReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.SpecialGetReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_SPECIAL_GET_RES:
		if this.SpecialGetRes == nil {
			this.SpecialGetRes = NewTCaplusSpecialGetRes()
		}

		err = this.SpecialGetRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.SpecialGetRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_MOVE_INSERT_REQ:
		if this.MoveInsertReq == nil {
			this.MoveInsertReq = NewTCaplusMoveInsertReq()
		}

		err = this.MoveInsertReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.MoveInsertReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_MOVE_INSERT_RES:
		if this.MoveInsertRes == nil {
			this.MoveInsertRes = NewTCaplusMoveInsertRes()
		}

		err = this.MoveInsertRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.MoveInsertRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_MSSYNC_INSERT_REQ:
		if this.MsSyncInsertReq == nil {
			this.MsSyncInsertReq = NewTCaplusMsSyncInsertReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncInsertReqVersion {

			err = this.MsSyncInsertReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncInsertReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncInsertReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_INSERT_RES:
		if this.MsSyncInsertRes == nil {
			this.MsSyncInsertRes = NewTCaplusMsSyncInsertRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncInsertResVersion {

			err = this.MsSyncInsertRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncInsertRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncInsertRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_REPLACE_REQ:
		if this.MsSyncReplaceReq == nil {
			this.MsSyncReplaceReq = NewTCaplusMsSyncReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncReplaceReqVersion {

			err = this.MsSyncReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncReplaceReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_REPLACE_RES:
		if this.MsSyncReplaceRes == nil {
			this.MsSyncReplaceRes = NewTCaplusMsSyncReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncReplaceResVersion {

			err = this.MsSyncReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncReplaceRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_DELETE_REQ:
		if this.MsSyncDeleteReq == nil {
			this.MsSyncDeleteReq = NewTCaplusMsSyncDeleteReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncDeleteReqVersion {

			err = this.MsSyncDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncDeleteReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_DELETE_RES:
		if this.MsSyncDeleteRes == nil {
			this.MsSyncDeleteRes = NewTCaplusMsSyncDeleteRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncDeleteResVersion {

			err = this.MsSyncDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncDeleteRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_UPDATE_REQ:
		if this.MsSyncUpdateReq == nil {
			this.MsSyncUpdateReq = NewTCaplusMsSyncUpdateReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncUpdateReqVersion {

			err = this.MsSyncUpdateReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncUpdateReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncUpdateReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_UPDATE_RES:
		if this.MsSyncUpdateRes == nil {
			this.MsSyncUpdateRes = NewTCaplusMsSyncUpdateRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncUpdateResVersion {

			err = this.MsSyncUpdateRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncUpdateRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncUpdateRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_REQ:
		if this.ListMsSyncDeleteAllReq == nil {
			this.ListMsSyncDeleteAllReq = NewTCaplusListMsSyncDeleteAllReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteAllReqVersion {

			err = this.ListMsSyncDeleteAllReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteAllReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncDeleteAllReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETEALL_RES:
		if this.ListMsSyncDeleteAllRes == nil {
			this.ListMsSyncDeleteAllRes = NewTCaplusListMsSyncDeleteAllRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteAllResVersion {

			err = this.ListMsSyncDeleteAllRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteAllRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncDeleteAllRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_REQ:
		if this.ListMsSyncAddAfterReq == nil {
			this.ListMsSyncAddAfterReq = NewTCaplusListMsSyncAddAfterReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncAddAfterReqVersion {

			err = this.ListMsSyncAddAfterReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncAddAfterReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncAddAfterReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_ADDAFTER_RES:
		if this.ListMsSyncAddAfterRes == nil {
			this.ListMsSyncAddAfterRes = NewTCaplusListMsSyncAddAfterRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncAddAfterResVersion {

			err = this.ListMsSyncAddAfterRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncAddAfterRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncAddAfterRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETE_REQ:
		if this.ListMsSyncDeleteReq == nil {
			this.ListMsSyncDeleteReq = NewTCaplusListMsSyncDeleteReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteReqVersion {

			err = this.ListMsSyncDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncDeleteReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DELETE_RES:
		if this.ListMsSyncDeleteRes == nil {
			this.ListMsSyncDeleteRes = NewTCaplusListMsSyncDeleteRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDeleteResVersion {

			err = this.ListMsSyncDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncDeleteRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_REPLACE_REQ:
		if this.ListMsSyncReplaceReq == nil {
			this.ListMsSyncReplaceReq = NewTCaplusListMsSyncReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncReplaceReqVersion {

			err = this.ListMsSyncReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncReplaceReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_REPLACE_RES:
		if this.ListMsSyncReplaceRes == nil {
			this.ListMsSyncReplaceRes = NewTCaplusListMsSyncReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncReplaceResVersion {

			err = this.ListMsSyncReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncReplaceRes.Init()

		}
	case TCAPLUS_CMD_SERV_APP_SIGNUP_REQ:
		if this.AppSignupReq == nil {
			this.AppSignupReq = NewTCaplusAppSignupReq()
		}
		if cutVer >= TCaplusPkgBodyAppSignupReqVersion {

			err = this.AppSignupReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.AppSignupReq unpack error\n" + err.Error())
			}

		} else {
			this.AppSignupReq.Init()

		}
	case TCAPLUS_CMD_SERV_APP_SIGNUP_RES:
		if this.AppSignupRes == nil {
			this.AppSignupRes = NewTCaplusAppSignupRes()
		}
		if cutVer >= TCaplusPkgBodyAppSignupResVersion {

			err = this.AppSignupRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.AppSignupRes unpack error\n" + err.Error())
			}

		} else {
			this.AppSignupRes.Init()

		}
	case TCAPLUS_CMD_SERV_HEART_BEAT_REQ:
		if this.HeartBeatReq == nil {
			this.HeartBeatReq = NewTCaplusHeartBeatReq()
		}
		if cutVer >= TCaplusPkgBodyHeartBeatReqVersion {

			err = this.HeartBeatReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.HeartBeatReq unpack error\n" + err.Error())
			}

		} else {
			this.HeartBeatReq.Init()

		}
	case TCAPLUS_CMD_SERV_HEART_BEAT_RES:
		if this.HeartBeatRes == nil {
			this.HeartBeatRes = NewTCaplusHeartBeatRes()
		}
		if cutVer >= TCaplusPkgBodyHeartBeatResVersion {

			err = this.HeartBeatRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.HeartBeatRes unpack error\n" + err.Error())
			}

		} else {
			this.HeartBeatRes.Init()

		}
	case TCAPLUS_CMD_PREPARE_MOVE_REQ:
		if this.PrepareMoveReq == nil {
			this.PrepareMoveReq = NewTCaplusPrepareMoveReq()
		}
		if cutVer >= TCaplusPkgBodyPrepareMoveReqVersion {

			err = this.PrepareMoveReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.PrepareMoveReq unpack error\n" + err.Error())
			}

		} else {
			this.PrepareMoveReq.Init()

		}
	case TCAPLUS_CMD_PREPARE_MOVE_RES:
		if this.PrepareMoveRes == nil {
			this.PrepareMoveRes = NewTCaplusPrepareMoveRes()
		}
		if cutVer >= TCaplusPkgBodyPrepareMoveResVersion {

			err = this.PrepareMoveRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.PrepareMoveRes unpack error\n" + err.Error())
			}

		} else {
			this.PrepareMoveRes.Init()

		}
	case TCAPLUS_CMD_FINISH_MOVE_REQ:
		if this.FinishMoveReq == nil {
			this.FinishMoveReq = NewTCaplusFinishMoveReq()
		}
		if cutVer >= TCaplusPkgBodyFinishMoveReqVersion {

			err = this.FinishMoveReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.FinishMoveReq unpack error\n" + err.Error())
			}

		} else {
			this.FinishMoveReq.Init()

		}
	case TCAPLUS_CMD_FINISH_MOVE_RES:
		if this.FinishMoveRes == nil {
			this.FinishMoveRes = NewTCaplusFinishMoveRes()
		}
		if cutVer >= TCaplusPkgBodyFinishMoveResVersion {

			err = this.FinishMoveRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.FinishMoveRes unpack error\n" + err.Error())
			}

		} else {
			this.FinishMoveRes.Init()

		}
	case TCAPLUS_CMD_LIST_CHECK_REQ:
		if this.ListCheckReq == nil {
			this.ListCheckReq = NewTCaplusListCheckReq()
		}

		err = this.ListCheckReq.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListCheckReq unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_CHECK_RES:
		if this.ListCheckRes == nil {
			this.ListCheckRes = NewTCaplusListCheckRes()
		}

		err = this.ListCheckRes.UnpackFrom(cutVer, r)
		if err != nil {
			return errors.New("TCaplusPkgBody.ListCheckRes unpack error\n" + err.Error())
		}

	case TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_REQ:
		if this.ListIndexMoveInsertReq == nil {
			this.ListIndexMoveInsertReq = NewTCaplusListIndexMoveInsertReq()
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveInsertReqVersion {

			err = this.ListIndexMoveInsertReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveInsertReq unpack error\n" + err.Error())
			}

		} else {
			this.ListIndexMoveInsertReq.Init()

		}
	case TCAPLUS_CMD_LIST_INDEX_MOVEINSERT_RES:
		if this.ListIndexMoveInsertRes == nil {
			this.ListIndexMoveInsertRes = NewTCaplusListIndexMoveInsertRes()
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveInsertResVersion {

			err = this.ListIndexMoveInsertRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveInsertRes unpack error\n" + err.Error())
			}

		} else {
			this.ListIndexMoveInsertRes.Init()

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_REQ:
		if this.ListElemMoveInsertReq == nil {
			this.ListElemMoveInsertReq = NewTCaplusListElemMoveInsertReq()
		}
		if cutVer >= TCaplusPkgBodyListElemMoveInsertReqVersion {

			err = this.ListElemMoveInsertReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElemMoveInsertReq unpack error\n" + err.Error())
			}

		} else {
			this.ListElemMoveInsertReq.Init()

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEINSERT_RES:
		if this.ListElemMoveInsertRes == nil {
			this.ListElemMoveInsertRes = NewTCaplusListElemMoveInsertRes()
		}
		if cutVer >= TCaplusPkgBodyListElemMoveInsertResVersion {

			err = this.ListElemMoveInsertRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElemMoveInsertRes unpack error\n" + err.Error())
			}

		} else {
			this.ListElemMoveInsertRes.Init()

		}
	case TCAPLUS_CMD_GET_SHARD_LIST_REQ:
		if this.GetShardListReq == nil {
			this.GetShardListReq = NewTCaplusGetShardListReq()
		}
		if cutVer >= TCaplusPkgBodyGetShardListReqVersion {

			err = this.GetShardListReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetShardListReq unpack error\n" + err.Error())
			}

		} else {
			this.GetShardListReq.Init()

		}
	case TCAPLUS_CMD_GET_SHARD_LIST_RES:
		if this.GetShardListRes == nil {
			this.GetShardListRes = NewTCaplusGetShardListRes()
		}
		if cutVer >= TCaplusPkgBodyGetShardListResVersion {

			err = this.GetShardListRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetShardListRes unpack error\n" + err.Error())
			}

		} else {
			this.GetShardListRes.Init()

		}
	case TCAPLUS_CMD_TABLE_TRAVERSE_REQ:
		if this.TableTraverseReq == nil {
			this.TableTraverseReq = NewTCaplusTableTraverseReq()
		}
		if cutVer >= TCaplusPkgBodyTableTraverseReqVersion {

			err = this.TableTraverseReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TableTraverseReq unpack error\n" + err.Error())
			}

		} else {
			this.TableTraverseReq.Init()

		}
	case TCAPLUS_CMD_TABLE_TRAVERSE_RES:
		if this.TableTraverseRes == nil {
			this.TableTraverseRes = NewTCaplusTableTraverseRes()
		}
		if cutVer >= TCaplusPkgBodyTableTraverseResVersion {

			err = this.TableTraverseRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TableTraverseRes unpack error\n" + err.Error())
			}

		} else {
			this.TableTraverseRes.Init()

		}
	case TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_REQ:
		if this.BatchGetByPartkeyReq == nil {
			this.BatchGetByPartkeyReq = NewTCaplusBatchGetByPartkeyReq()
		}
		if cutVer >= TCaplusPkgBodyBatchGetByPartkeyReqVersion {

			err = this.BatchGetByPartkeyReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.BatchGetByPartkeyReq unpack error\n" + err.Error())
			}

		} else {
			this.BatchGetByPartkeyReq.Init()

		}
	case TCAPLUS_CMD_BATCH_GET_BY_PARTKEY_RES:
		if this.BatchGetByPartkeyRes == nil {
			this.BatchGetByPartkeyRes = NewTCaplusBatchGetByPartkeyRes()
		}
		if cutVer >= TCaplusPkgBodyBatchGetByPartkeyResVersion {

			err = this.BatchGetByPartkeyRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.BatchGetByPartkeyRes unpack error\n" + err.Error())
			}

		} else {
			this.BatchGetByPartkeyRes.Init()

		}
	case TCAPLUS_CMD_DOCUMENT_OPERATION_REQ:
		if this.TCaplusDocumentOperationReq == nil {
			this.TCaplusDocumentOperationReq = NewTCaplusDocumentOperationReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusDocumentOperationReqVersion {

			err = this.TCaplusDocumentOperationReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusDocumentOperationReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusDocumentOperationReq.Init()

		}
	case TCAPLUS_CMD_DOCUMENT_OPERATION_RES:
		if this.TCaplusDocumentOperationRes == nil {
			this.TCaplusDocumentOperationRes = NewTCaplusDocumentOperationRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusDocumentOperationResVersion {

			err = this.TCaplusDocumentOperationRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusDocumentOperationRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusDocumentOperationRes.Init()

		}
	case TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_REQ:
		if this.GetTableRecordCountReq == nil {
			this.GetTableRecordCountReq = NewTCaplusGetTableRecordCountReq()
		}
		if cutVer >= TCaplusPkgBodyGetTableRecordCountReqVersion {

			err = this.GetTableRecordCountReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetTableRecordCountReq unpack error\n" + err.Error())
			}

		} else {
			this.GetTableRecordCountReq.Init()

		}
	case TCAPLUS_CMD_GET_TABLE_RECORD_COUNT_RES:
		if this.GetTableRecordCountRes == nil {
			this.GetTableRecordCountRes = NewTCaplusGetTableRecordCountRes()
		}
		if cutVer >= TCaplusPkgBodyGetTableRecordCountResVersion {

			err = this.GetTableRecordCountRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetTableRecordCountRes unpack error\n" + err.Error())
			}

		} else {
			this.GetTableRecordCountRes.Init()

		}
	case TCAPLUS_CMD_HTTP_GENERIC_REQ:
		if this.HttpGenericReq == nil {
			this.HttpGenericReq = NewTCaplusHttpGenericReq()
		}
		if cutVer >= TCaplusPkgBodyHttpGenericReqVersion {

			err = this.HttpGenericReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.HttpGenericReq unpack error\n" + err.Error())
			}

		} else {
			this.HttpGenericReq.Init()

		}
	case TCAPLUS_CMD_HTTP_GENERIC_RES:
		if this.HttpGenericRes == nil {
			this.HttpGenericRes = NewTCaplusHttpGenericRes()
		}
		if cutVer >= TCaplusPkgBodyHttpGenericResVersion {

			err = this.HttpGenericRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.HttpGenericRes unpack error\n" + err.Error())
			}

		} else {
			this.HttpGenericRes.Init()

		}
	case TCAPLUS_CMD_LIST_TABLE_TRAVERSE_REQ:
		if this.ListTableTraverseReq == nil {
			this.ListTableTraverseReq = NewTCaplusListTableTraverseReq()
		}
		if cutVer >= TCaplusPkgBodyListTableTraverseReqVersion {

			err = this.ListTableTraverseReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListTableTraverseReq unpack error\n" + err.Error())
			}

		} else {
			this.ListTableTraverseReq.Init()

		}
	case TCAPLUS_CMD_LIST_TABLE_TRAVERSE_RES:
		if this.ListTableTraverseRes == nil {
			this.ListTableTraverseRes = NewTCaplusListTableTraverseRes()
		}
		if cutVer >= TCaplusPkgBodyListTableTraverseResVersion {

			err = this.ListTableTraverseRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListTableTraverseRes unpack error\n" + err.Error())
			}

		} else {
			this.ListTableTraverseRes.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_GET_REQ:
		if this.SysListGetReq == nil {
			this.SysListGetReq = NewTCaplusSysListGetReq()
		}
		if cutVer >= TCaplusPkgBodySysListGetReqVersion {

			err = this.SysListGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetReq unpack error\n" + err.Error())
			}

		} else {
			this.SysListGetReq.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_GET_RES:
		if this.SysListGetRes == nil {
			this.SysListGetRes = NewTCaplusSysListGetRes()
		}
		if cutVer >= TCaplusPkgBodySysListGetResVersion {

			err = this.SysListGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetRes unpack error\n" + err.Error())
			}

		} else {
			this.SysListGetRes.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_GET_ALL_REQ:
		if this.SysListGetAllReq == nil {
			this.SysListGetAllReq = NewTCaplusSysListGetAllReq()
		}
		if cutVer >= TCaplusPkgBodySysListGetAllReqVersion {

			err = this.SysListGetAllReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetAllReq unpack error\n" + err.Error())
			}

		} else {
			this.SysListGetAllReq.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_GET_ALL_RES:
		if this.SysListGetAllRes == nil {
			this.SysListGetAllRes = NewTCaplusSysListGetAllRes()
		}
		if cutVer >= TCaplusPkgBodySysListGetAllResVersion {

			err = this.SysListGetAllRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListGetAllRes unpack error\n" + err.Error())
			}

		} else {
			this.SysListGetAllRes.Init()

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_REQ:
		if this.GetDuringMoveReq == nil {
			this.GetDuringMoveReq = NewTCaplusGetDuringMoveReq()
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveReqVersion {

			err = this.GetDuringMoveReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveReq unpack error\n" + err.Error())
			}

		} else {
			this.GetDuringMoveReq.Init()

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_RES:
		if this.GetDuringMoveRes == nil {
			this.GetDuringMoveRes = NewTCaplusGetDuringMoveRes()
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveResVersion {

			err = this.GetDuringMoveRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveRes unpack error\n" + err.Error())
			}

		} else {
			this.GetDuringMoveRes.Init()

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_REQ:
		if this.GetDuringMoveFromSrcReq == nil {
			this.GetDuringMoveFromSrcReq = NewTCaplusGetDuringMoveFromSrcReq()
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveFromSrcReqVersion {

			err = this.GetDuringMoveFromSrcReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveFromSrcReq unpack error\n" + err.Error())
			}

		} else {
			this.GetDuringMoveFromSrcReq.Init()

		}
	case TCAPLUS_CMD_GET_DURING_MOVE_FROM_SRC_RES:
		if this.GetDuringMoveFromSrcRes == nil {
			this.GetDuringMoveFromSrcRes = NewTCaplusGetDuringMoveFromSrcRes()
		}
		if cutVer >= TCaplusPkgBodyGetDuringMoveFromSrcResVersion {

			err = this.GetDuringMoveFromSrcRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.GetDuringMoveFromSrcRes unpack error\n" + err.Error())
			}

		} else {
			this.GetDuringMoveFromSrcRes.Init()

		}
	case TCAPLUS_CMD_NEGOTIATE_VERSION_REQ:
		if this.NegotiateVersionReq == nil {
			this.NegotiateVersionReq = NewTCaplusNegotiateVersionReq()
		}
		if cutVer >= TCaplusPkgBodyNegotiateVersionReqVersion {

			err = this.NegotiateVersionReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.NegotiateVersionReq unpack error\n" + err.Error())
			}

		} else {
			this.NegotiateVersionReq.Init()

		}
	case TCAPLUS_CMD_NEGOTIATE_VERSION_RES:
		if this.NegotiateVersionRes == nil {
			this.NegotiateVersionRes = NewTCaplusNegotiateVersionRes()
		}
		if cutVer >= TCaplusPkgBodyNegotiateVersionResVersion {

			err = this.NegotiateVersionRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.NegotiateVersionRes unpack error\n" + err.Error())
			}

		} else {
			this.NegotiateVersionRes.Init()

		}
	case TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_REQ:
		if this.CheckConnectDuringMoveReq == nil {
			this.CheckConnectDuringMoveReq = NewTCaplusCheckConnectDuringMoveReq()
		}
		if cutVer >= TCaplusPkgBodyCheckConnectDuringMoveReqVersion {

			err = this.CheckConnectDuringMoveReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.CheckConnectDuringMoveReq unpack error\n" + err.Error())
			}

		} else {
			this.CheckConnectDuringMoveReq.Init()

		}
	case TCAPLUS_CMD_CHECK_CONNECT_DURING_MOVE_RES:
		if this.CheckConnectDuringMoveRes == nil {
			this.CheckConnectDuringMoveRes = NewTCaplusCheckConnectDuringMoveRes()
		}
		if cutVer >= TCaplusPkgBodyCheckConnectDuringMoveResVersion {

			err = this.CheckConnectDuringMoveRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.CheckConnectDuringMoveRes unpack error\n" + err.Error())
			}

		} else {
			this.CheckConnectDuringMoveRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_REQ:
		if this.MsSyncDataExpireDeleteReq == nil {
			this.MsSyncDataExpireDeleteReq = NewTCaplusMsSyncDeleteReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataExpireDeleteReqVersion {

			err = this.MsSyncDataExpireDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataExpireDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncDataExpireDeleteReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_DATAEXPIRE_DELETE_RES:
		if this.MsSyncDataExpireDeleteRes == nil {
			this.MsSyncDataExpireDeleteRes = NewTCaplusMsSyncDeleteRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataExpireDeleteResVersion {

			err = this.MsSyncDataExpireDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataExpireDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncDataExpireDeleteRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_REQ:
		if this.MsSyncDataMoveDeleteReq == nil {
			this.MsSyncDataMoveDeleteReq = NewTCaplusMsSyncDeleteReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataMoveDeleteReqVersion {

			err = this.MsSyncDataMoveDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataMoveDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncDataMoveDeleteReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_DATAMOVE_DELETE_RES:
		if this.MsSyncDataMoveDeleteRes == nil {
			this.MsSyncDataMoveDeleteRes = NewTCaplusMsSyncDeleteRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncDataMoveDeleteResVersion {

			err = this.MsSyncDataMoveDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncDataMoveDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncDataMoveDeleteRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_REQ:
		if this.ListMsSyncDataExpireDeleteReq == nil {
			this.ListMsSyncDataExpireDeleteReq = NewTCaplusListMsSyncDeleteReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDataExpireDeleteReqVersion {

			err = this.ListMsSyncDataExpireDeleteReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDataExpireDeleteReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncDataExpireDeleteReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_DATAEXPIRE_DELETE_RES:
		if this.ListMsSyncDataExpireDeleteRes == nil {
			this.ListMsSyncDataExpireDeleteRes = NewTCaplusListMsSyncDeleteRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncDataExpireDeleteResVersion {

			err = this.ListMsSyncDataExpireDeleteRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncDataExpireDeleteRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncDataExpireDeleteRes.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_GET_REQ:
		if this.TCaplusPbFieldGetReq == nil {
			this.TCaplusPbFieldGetReq = NewTCaplusProtobufFieldGetReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldGetReqVersion {

			err = this.TCaplusPbFieldGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldGetReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbFieldGetReq.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_GET_RES:
		if this.TCaplusPbFieldGetRes == nil {
			this.TCaplusPbFieldGetRes = NewTCaplusProtobufFieldGetRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldGetResVersion {

			err = this.TCaplusPbFieldGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldGetRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbFieldGetRes.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_REQ:
		if this.TCaplusPbFieldUpdateReq == nil {
			this.TCaplusPbFieldUpdateReq = NewTCaplusProtobufFieldUpdateReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldUpdateReqVersion {

			err = this.TCaplusPbFieldUpdateReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldUpdateReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbFieldUpdateReq.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_UPDATE_RES:
		if this.TCaplusPbFieldUpdateRes == nil {
			this.TCaplusPbFieldUpdateRes = NewTCaplusProtobufFieldUpdateRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldUpdateResVersion {

			err = this.TCaplusPbFieldUpdateRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldUpdateRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbFieldUpdateRes.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_REQ:
		if this.TCaplusPbFieldIncReq == nil {
			this.TCaplusPbFieldIncReq = NewTCaplusProtobufFieldIncreaseReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldIncReqVersion {

			err = this.TCaplusPbFieldIncReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldIncReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbFieldIncReq.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_FIELD_INCREASE_RES:
		if this.TCaplusPbFieldIncRes == nil {
			this.TCaplusPbFieldIncRes = NewTCaplusProtobufFieldIncreaseRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbFieldIncResVersion {

			err = this.TCaplusPbFieldIncRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbFieldIncRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbFieldIncRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_GET_REQ:
		if this.MsSyncGetReq == nil {
			this.MsSyncGetReq = NewTCaplusMsSyncGetReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncGetReqVersion {

			err = this.MsSyncGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncGetReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncGetReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_GET_RES:
		if this.MsSyncGetRes == nil {
			this.MsSyncGetRes = NewTCaplusMsSyncGetRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncGetResVersion {

			err = this.MsSyncGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncGetRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncGetRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GET_REQ:
		if this.ListMsSyncGetReq == nil {
			this.ListMsSyncGetReq = NewTCaplusListMsSyncGetReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetReqVersion {

			err = this.ListMsSyncGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncGetReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GET_RES:
		if this.ListMsSyncGetRes == nil {
			this.ListMsSyncGetRes = NewTCaplusListMsSyncGetRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetResVersion {

			err = this.ListMsSyncGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncGetRes.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GETALL_REQ:
		if this.ListMsSyncGetAllReq == nil {
			this.ListMsSyncGetAllReq = NewTCaplusListMsSyncGetAllReq()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetAllReqVersion {

			err = this.ListMsSyncGetAllReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetAllReq unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncGetAllReq.Init()

		}
	case TCAPLUS_CMD_LIST_MSSYNC_GETALL_RES:
		if this.ListMsSyncGetAllRes == nil {
			this.ListMsSyncGetAllRes = NewTCaplusListMsSyncGetAllRes()
		}
		if cutVer >= TCaplusPkgBodyListMsSyncGetAllResVersion {

			err = this.ListMsSyncGetAllRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListMsSyncGetAllRes unpack error\n" + err.Error())
			}

		} else {
			this.ListMsSyncGetAllRes.Init()

		}
	case TCAPLUS_CMD_MSSYNC_PARTKEY_GET_REQ:
		if this.MsSyncPartkeyGetReq == nil {
			this.MsSyncPartkeyGetReq = NewTCaplusMsSyncPartkeyGetReq()
		}
		if cutVer >= TCaplusPkgBodyMsSyncPartkeyGetReqVersion {

			err = this.MsSyncPartkeyGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncPartkeyGetReq unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncPartkeyGetReq.Init()

		}
	case TCAPLUS_CMD_MSSYNC_PARTKEY_GET_RES:
		if this.MsSyncPartkeyGetRes == nil {
			this.MsSyncPartkeyGetRes = NewTCaplusMsSyncPartkeyGetRes()
		}
		if cutVer >= TCaplusPkgBodyMsSyncPartkeyGetResVersion {

			err = this.MsSyncPartkeyGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.MsSyncPartkeyGetRes unpack error\n" + err.Error())
			}

		} else {
			this.MsSyncPartkeyGetRes.Init()

		}
	case TCAPLUS_CMD_SYS_MAKE_CONSIST_REQ:
		if this.SysMakeConsistReq == nil {
			this.SysMakeConsistReq = NewTCaplusSysMakeConsistReq()
		}
		if cutVer >= TCaplusPkgBodySysMakeConsistReqVersion {

			err = this.SysMakeConsistReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysMakeConsistReq unpack error\n" + err.Error())
			}

		} else {
			this.SysMakeConsistReq.Init()

		}
	case TCAPLUS_CMD_SYS_MAKE_CONSIST_RES:
		if this.SysMakeConsistRes == nil {
			this.SysMakeConsistRes = NewTCaplusSysMakeConsistRes()
		}
		if cutVer >= TCaplusPkgBodySysMakeConsistResVersion {

			err = this.SysMakeConsistRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysMakeConsistRes unpack error\n" + err.Error())
			}

		} else {
			this.SysMakeConsistRes.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_REQ:
		if this.SysListMakeConsistReq == nil {
			this.SysListMakeConsistReq = NewTCaplusSysListMakeConsistReq()
		}
		if cutVer >= TCaplusPkgBodySysListMakeConsistReqVersion {

			err = this.SysListMakeConsistReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListMakeConsistReq unpack error\n" + err.Error())
			}

		} else {
			this.SysListMakeConsistReq.Init()

		}
	case TCAPLUS_CMD_SYS_LIST_MAKE_CONSIST_RES:
		if this.SysListMakeConsistRes == nil {
			this.SysListMakeConsistRes = NewTCaplusSysListMakeConsistRes()
		}
		if cutVer >= TCaplusPkgBodySysListMakeConsistResVersion {

			err = this.SysListMakeConsistRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.SysListMakeConsistRes unpack error\n" + err.Error())
			}

		} else {
			this.SysListMakeConsistRes.Init()

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_REQ:
		if this.LosslessMoveReplaceReq == nil {
			this.LosslessMoveReplaceReq = NewTCaplusLosslessMoveReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveReplaceReqVersion {

			err = this.LosslessMoveReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.LosslessMoveReplaceReq.Init()

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_REPLACE_RES:
		if this.LosslessMoveReplaceRes == nil {
			this.LosslessMoveReplaceRes = NewTCaplusLosslessMoveReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveReplaceResVersion {

			err = this.LosslessMoveReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.LosslessMoveReplaceRes.Init()

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_REQ:
		if this.LosslessMoveListIndexReplaceReq == nil {
			this.LosslessMoveListIndexReplaceReq = NewTCaplusLosslessMoveListIndexReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListIndexReplaceReqVersion {

			err = this.LosslessMoveListIndexReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListIndexReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.LosslessMoveListIndexReplaceReq.Init()

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_INDEX_REPLACE_RES:
		if this.LosslessMoveListIndexReplaceRes == nil {
			this.LosslessMoveListIndexReplaceRes = NewTCaplusLosslessMoveListIndexReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListIndexReplaceResVersion {

			err = this.LosslessMoveListIndexReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListIndexReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.LosslessMoveListIndexReplaceRes.Init()

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_REQ:
		if this.LosslessMoveListElemReplaceReq == nil {
			this.LosslessMoveListElemReplaceReq = NewTCaplusLosslessMoveListElemReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListElemReplaceReqVersion {

			err = this.LosslessMoveListElemReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListElemReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.LosslessMoveListElemReplaceReq.Init()

		}
	case TCAPLUS_CMD_LOSSLESS_MOVE_LIST_ELEM_REPLACE_RES:
		if this.LosslessMoveListElemReplaceRes == nil {
			this.LosslessMoveListElemReplaceRes = NewTCaplusLosslessMoveListElemReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyLosslessMoveListElemReplaceResVersion {

			err = this.LosslessMoveListElemReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.LosslessMoveListElemReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.LosslessMoveListElemReplaceRes.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_REQ:
		if this.TCaplusPbBatchFieldGetReq == nil {
			this.TCaplusPbBatchFieldGetReq = NewTCaplusProtobufBatchFieldGetReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbBatchFieldGetReqVersion {

			err = this.TCaplusPbBatchFieldGetReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbBatchFieldGetReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbBatchFieldGetReq.Init()

		}
	case TCAPLUS_CMD_PROTOBUF_BATCH_FIELD_GET_RES:
		if this.TCaplusPbBatchFieldGetRes == nil {
			this.TCaplusPbBatchFieldGetRes = NewTCaplusProtobufBatchFieldGetRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusPbBatchFieldGetResVersion {

			err = this.TCaplusPbBatchFieldGetRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusPbBatchFieldGetRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusPbBatchFieldGetRes.Init()

		}
	case TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_REQ:
		if this.ListIndexMoveReplaceReq == nil {
			this.ListIndexMoveReplaceReq = NewTCaplusListIndexMoveReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveReplaceReqVersion {

			err = this.ListIndexMoveReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.ListIndexMoveReplaceReq.Init()

		}
	case TCAPLUS_CMD_LIST_INDEX_MOVEREPLACE_RES:
		if this.ListIndexMoveReplaceRes == nil {
			this.ListIndexMoveReplaceRes = NewTCaplusListIndexMoveReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyListIndexMoveReplaceResVersion {

			err = this.ListIndexMoveReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListIndexMoveReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.ListIndexMoveReplaceRes.Init()

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_REQ:
		if this.ListElementMoveReplaceReq == nil {
			this.ListElementMoveReplaceReq = NewTCaplusListElementMoveReplaceReq()
		}
		if cutVer >= TCaplusPkgBodyListElementMoveReplaceReqVersion {

			err = this.ListElementMoveReplaceReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElementMoveReplaceReq unpack error\n" + err.Error())
			}

		} else {
			this.ListElementMoveReplaceReq.Init()

		}
	case TCAPLUS_CMD_LIST_ELEMENT_MOVEREPLACE_RES:
		if this.ListElementMoveReplaceRes == nil {
			this.ListElementMoveReplaceRes = NewTCaplusListElementMoveReplaceRes()
		}
		if cutVer >= TCaplusPkgBodyListElementMoveReplaceResVersion {

			err = this.ListElementMoveReplaceRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.ListElementMoveReplaceRes unpack error\n" + err.Error())
			}

		} else {
			this.ListElementMoveReplaceRes.Init()

		}
	case TCAPLUS_CMD_SQL_REQ:
		if this.TCaplusSqlReq == nil {
			this.TCaplusSqlReq = NewTCaplusSqlReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusSqlReqVersion {

			err = this.TCaplusSqlReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusSqlReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusSqlReq.Init()

		}
	case TCAPLUS_CMD_SQL_RES:
		if this.TCaplusSqlRes == nil {
			this.TCaplusSqlRes = NewTCaplusSqlRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusSqlResVersion {

			err = this.TCaplusSqlRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusSqlRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusSqlRes.Init()

		}
	case TCAPLUS_CMD_GET_FOR_SQL_QUERY_REQ:
		if this.TCaplusGetForSqlQueryReq == nil {
			this.TCaplusGetForSqlQueryReq = NewTCaplusGetForSqlQueryReq()
		}
		if cutVer >= TCaplusPkgBodyTCaplusGetForSqlQueryReqVersion {

			err = this.TCaplusGetForSqlQueryReq.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusGetForSqlQueryReq unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusGetForSqlQueryReq.Init()

		}
	case TCAPLUS_CMD_GET_FOR_SQL_QUERY_RES:
		if this.TCaplusGetForSqlQueryRes == nil {
			this.TCaplusGetForSqlQueryRes = NewTCaplusGetForSqlQueryRes()
		}
		if cutVer >= TCaplusPkgBodyTCaplusGetForSqlQueryResVersion {

			err = this.TCaplusGetForSqlQueryRes.UnpackFrom(cutVer, r)
			if err != nil {
				return errors.New("TCaplusPkgBody.TCaplusGetForSqlQueryRes unpack error\n" + err.Error())
			}

		} else {
			this.TCaplusGetForSqlQueryRes.Init()

		}
	}

	return err
}

const (
	TCaplusPkgBaseVersion    uint32 = 1
	TCaplusPkgCurrentVersion uint32 = 117
)

// TCaplusPkg
type TCaplusPkg struct {
	Head *TCaplusPkgHead `tdr_field:"Head"`

	Body *TCaplusPkgBody `tdr_field:"Body" tdr_select:"Head.Cmd"`
}

func NewTCaplusPkg() *TCaplusPkg {
	obj := new(TCaplusPkg)
	obj.Init()
	return obj
}

func (this *TCaplusPkg) GetBaseVersion() uint32 {
	return TCaplusPkgBaseVersion
}

func (this *TCaplusPkg) GetCurrentVersion() uint32 {
	return TCaplusPkgCurrentVersion
}

func (this *TCaplusPkg) Init() {
	this.Head = NewTCaplusPkgHead()

	this.Body = NewTCaplusPkgBody(int64(this.Head.Cmd))

}

func (this *TCaplusPkg) Pack(cutVer uint32) ([]byte, error) {
	w := tdrcom.NewWriter()
	if err := this.PackTo(cutVer, w); err != nil {
		return nil, errors.New("TCaplusPkg Pack error\n" + err.Error())
	} else {
		return w.Bytes(), nil
	}
}

func (this *TCaplusPkg) PackTo(cutVer uint32, w *tdrcom.Writer) error {
	// adjust cut version
	if cutVer == 0 || cutVer > TCaplusPkgCurrentVersion {
		cutVer = TCaplusPkgCurrentVersion
	}
	// check cut version
	if cutVer < TCaplusPkgBaseVersion {
		return errors.New("TCaplusPkg cut version must large than TCaplusPkgBaseVersion\n")
	}
	// versionindicator
	this.Head.Version = uint16(cutVer)

	beginPos := w.Tell()

	var err error

	err = this.Head.PackTo(cutVer, w)
	if err != nil {
		return errors.New("TCaplusPkg.Head pack error\n" + err.Error())
	}

	BodyBeginPos := w.Tell()

	err = this.Body.PackTo(cutVer, w, int64(this.Head.Cmd))
	if err != nil {
		return errors.New("TCaplusPkg.Body pack error\n" + err.Error())
	}

	BodyEndPos := w.Tell()
	w.Seek(beginPos+8, io.SeekStart)
	err = binary.Write(w, binary.BigEndian, uint32(BodyEndPos-BodyBeginPos))
	if err != nil {
		return errors.New("Body's sizeinfo Head.BodyLen pack error\n" + err.Error())
	}
	w.Seek(BodyEndPos, io.SeekStart)

	return nil
}

func (this *TCaplusPkg) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("TCaplusPkg data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}

func (this *TCaplusPkg) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
	var err error = nil
	// get net version
	var netVer uint16
	oriPos := r.Tell()
	r.Seek(oriPos+2, io.SeekStart)
	err = binary.Read(r, binary.BigEndian, &netVer)
	if err != nil {
		return errors.New("TCaplusPkg get net version error\n" + err.Error())
	}
	r.Seek(oriPos, io.SeekStart)
	cutVer = uint32(netVer)
	// check version
	if cutVer < TCaplusPkgBaseVersion || cutVer > TCaplusPkgCurrentVersion {
		return errors.New("TCaplusPkg wrong cut version")
	}

	err = this.Head.UnpackFrom(cutVer, r)
	if err != nil {
		return errors.New("TCaplusPkg.Head unpack error\n" + err.Error())
	}

	err = this.Body.UnpackFrom(cutVer, r, int64(this.Head.Cmd))
	if err != nil {
		return errors.New("TCaplusPkg.Body unpack error\n" + err.Error())
	}

	return err
}
